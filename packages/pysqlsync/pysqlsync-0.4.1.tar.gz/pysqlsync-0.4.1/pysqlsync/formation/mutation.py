from dataclasses import dataclass
from typing import Optional

from ..model.data_types import constant
from ..model.id_types import SupportsName
from .object_types import (
    Catalog,
    Column,
    ColumnFormationError,
    EnumType,
    FormationError,
    Namespace,
    StatementList,
    StructType,
    Table,
    TableFormationError,
    join_or_none,
)


@dataclass
class MutatorOptions:
    """
    Options for synchronizing an existing source state with a desired target state.

    :param allow_drop_enum: Permit dropping enumeration types.
    :param allow_drop_struct: Permit dropping (non-table) structure types.
    :param allow_drop_table: Permit dropping tables.
    :param allow_drop_namespace: Permit dropping namespaces (database schemas) and all objects within.
    """

    allow_drop_enum: bool = True
    allow_drop_struct: bool = True
    allow_drop_table: bool = True
    allow_drop_namespace: bool = True


class Mutator:
    "Morphs an existing source state into a desired target state."

    options: MutatorOptions

    def __init__(self, options: Optional[MutatorOptions] = None) -> None:
        self.options = options or MutatorOptions()

    def check_identity(self, source: SupportsName, target: SupportsName) -> None:
        if source.name != target.name:
            raise FormationError(f"object mismatch: {source.name} != {target.name}")

    def mutate_enum_stmt(self, source: EnumType, target: EnumType) -> Optional[str]:
        self.check_identity(source, target)

        removed_values = [
            value for value in source.values if value not in target.values
        ]
        if removed_values:
            raise FormationError(
                f"operation not permitted; cannot drop values in an enumeration: {''.join(removed_values)}"
            )

        added_values = [value for value in target.values if value not in source.values]
        if added_values:
            return (
                f"ALTER TYPE {source.name}\n"
                + ",\n".join(f"ADD VALUE {constant(v)}" for v in added_values)
                + ";"
            )
        else:
            return None

    def mutate_struct_stmt(
        self, source: StructType, target: StructType
    ) -> Optional[str]:
        self.check_identity(source, target)

        statements: list[str] = []
        statements.extend(
            f"DROP ATTRIBUTE {member.name}"
            for member in source.members.difference(target.members)
        )
        for source_member, target_member in source.members.intersection(target.members):
            if source_member != target_member:
                statements.append(
                    f"ALTER ATTRIBUTE {source_member.name} SET DATA TYPE {target_member.data_type}"
                )
        statements.extend(
            f"ADD ATTRIBUTE {member}"
            for member in target.members.difference(source.members)
        )
        if statements:
            return f"ALTER TYPE {source.name}\n" + ",\n".join(statements) + ";\n"
        else:
            return None

    def mutate_column_stmt(self, source: Column, target: Column) -> Optional[str]:
        if source == target:
            return None

        statements: list[str] = []

        if source.data_type != target.data_type:
            statements.append(f"SET DATA TYPE {target.data_type}")

        if source.nullable and not target.nullable:
            statements.append("SET NOT NULL")
        elif not source.nullable and target.nullable:
            statements.append("DROP NOT NULL")

        if source.default is not None and target.default is None:
            statements.append("DROP DEFAULT")
        elif source.default != target.default:
            statements.append(f"SET DEFAULT {target.default}")

        if source.identity and not target.identity:
            statements.append("DROP IDENTITY")
        elif not source.identity and target.identity:
            statements.append("ADD GENERATED BY DEFAULT AS IDENTITY")

        if statements:
            return ",\n".join(f"ALTER COLUMN {source.name} {s}" for s in statements)
        else:
            return None

    def mutate_table_stmt(self, source: Table, target: Table) -> Optional[str]:
        self.check_identity(source, target)

        statements: list[str] = []
        try:
            statements.extend(
                column.create_stmt()
                for column in target.columns.difference(source.columns)
            )
        except ColumnFormationError as e:
            raise TableFormationError(
                "failed to create columns in table", target.name
            ) from e

        try:
            common_columns = source.columns.intersection(target.columns)
            for source_column, target_column in common_columns:
                statement = self.mutate_column_stmt(source_column, target_column)
                if statement:
                    statements.append(statement)
        except ColumnFormationError as e:
            raise TableFormationError(
                "failed to update columns in table", target.name
            ) from e

        try:
            statements.extend(
                column.drop_stmt()
                for column in source.columns.difference(target.columns)
            )
        except ColumnFormationError as e:
            raise TableFormationError(
                "failed to drop columns in table", target.name
            ) from e

        statements.extend(
            f"DROP CONSTRAINT {constraint.name}"
            for constraint in source.constraints.difference(target.constraints)
            if constraint.is_alter_table()
        )

        common_constraints = source.constraints.intersection(target.constraints)
        for source_constraint, target_constraint in common_constraints:
            if source_constraint != target_constraint:
                raise TableFormationError(
                    f"failed to mutate constraint `{source_constraint.name}`",
                    target.name,
                )

        statements.extend(
            f"ADD CONSTRAINT {constraint.spec}"
            for constraint in target.constraints.difference(source.constraints)
            if constraint.is_alter_table()
        )

        if statements:
            return source.alter_table_stmt(statements)
        else:
            return None

    def mutate_namespace_stmt(
        self, source: Namespace, target: Namespace
    ) -> Optional[str]:
        self.check_identity(source, target)

        statements: StatementList = StatementList()

        # create new objects
        enum_create = target.enums.difference(source.enums)
        statements.extend(enum.create_stmt() for enum in enum_create)

        struct_create = target.structs.difference(source.structs)
        statements.extend(struct.create_stmt() for struct in struct_create)

        table_create = target.tables.difference(source.tables)
        statements.extend(table.create_stmt() for table in table_create)
        statements.extend(table.add_constraints_stmt() for table in table_create)

        # mutate existing object
        enum_mutate = source.enums.intersection(target.enums)
        statements.extend(
            self.mutate_enum_stmt(source_enum, target_enum)
            for source_enum, target_enum in enum_mutate
        )

        struct_mutate = source.structs.intersection(target.structs)
        statements.extend(
            self.mutate_struct_stmt(source_struct, target_struct)
            for source_struct, target_struct in struct_mutate
        )

        table_mutate = source.tables.intersection(target.tables)
        statements.extend(
            self.mutate_table_stmt(source_table, target_table)
            for source_table, target_table in table_mutate
        )

        # drop old objects
        if self.options.allow_drop_table:
            table_drop = source.tables.difference(target.tables)
            statements.extend(table.drop_stmt() for table in table_drop)

        if self.options.allow_drop_struct:
            struct_drop = source.structs.difference(target.structs)
            statements.extend(struct.drop_stmt() for struct in struct_drop)

        if self.options.allow_drop_enum:
            enum_drop = source.enums.difference(target.enums)
            statements.extend(enum.drop_stmt() for enum in enum_drop)

        return join_or_none(statements)

    def mutate_catalog_stmt(self, source: Catalog, target: Catalog) -> Optional[str]:
        statements: StatementList = StatementList()

        source.sort()
        target.sort()

        ns_create = list(target.namespaces.difference(source.namespaces))
        ns_drop = list(source.namespaces.difference(target.namespaces))
        ns_mutate = list(source.namespaces.intersection(target.namespaces))

        # create new namespaces
        statements.extend(namespace.create_schema_stmt() for namespace in ns_create)

        # create objects in each namespace added
        statements.extend(namespace.create_objects_stmt() for namespace in ns_create)

        # add new constraints
        statements.extend(namespace.add_constraints_stmt() for namespace in ns_create)

        # mutate existing namespaces
        statements.extend(
            self.mutate_namespace_stmt(source_ns, target_ns)
            for source_ns, target_ns in ns_mutate
        )

        # remove old constraints
        statements.extend(namespace.drop_constraints_stmt() for namespace in ns_drop)
        if self.options.allow_drop_namespace:
            # drop objects in each namespace removed
            statements.extend(namespace.drop_objects_stmt() for namespace in ns_drop)

            # drop old namespaces
            statements.extend(namespace.drop_schema_stmt() for namespace in ns_drop)

        return join_or_none(statements)
