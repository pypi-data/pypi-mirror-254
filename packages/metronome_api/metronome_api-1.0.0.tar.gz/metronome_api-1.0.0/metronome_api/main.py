"""Generated by Sideko (sideko.dev)"""
import typing

import httpx
from urllib.parse import quote_plus

from metronome_api.schemas import *
import metronome_api.auth as sdk_auth
import metronome_api.errors as sdk_errors
import metronome_api.response as sdk_response


T = typing.TypeVar("T")


class Client:
    def __init__(
        self,
        *,
        bearer_auth: typing.Optional[str] = None,
        base_url: typing.Optional[str] = None,
    ):
        url = base_url or "https://api.metronome.com/v1"
        self.base_url = url
        self.session = httpx.Client()

        # register auth providers
        self._auth: typing.Dict[str, sdk_auth.AuthProvider] = {}
        self._auth["bearerAuth"] = sdk_auth.AuthBearer(val=bearer_auth)

    def _to_json_encodable(self, target: typing.Any) -> typing.Any:
        if isinstance(target, list):
            return [self._to_json_encodable(el) for el in target]

        dump_method = getattr(target, "model_api_dump", None)
        if callable(dump_method):
            return target.model_api_dump()

        return target

    def _format_param(
        self,
        value: typing.Union[str, int, typing.List[typing.Union[str, int]], dict],
        explode: bool,
    ) -> typing.List[typing.Union[str, int]]:
        if isinstance(value, (list, dict)) and not explode:
            return quote_plus(",".join(map(str, value)))
        else:
            return value

    def _add_auth(self, auth_names: typing.List[str], **req_kwargs) -> typing.Dict:
        for auth_name in auth_names:
            provider = self._auth.get(auth_name, None)
            if provider is not None:
                req_kwargs = provider.add_auth(req_kwargs)

        return req_kwargs

    def delete_billing_config_for_customer(
        self,
        *,
        customer_id: str,
        billing_provider_type: DeleteCustomersCustomerIdBillingConfigBillingProviderTypeBillingProviderTypeEnum,
    ) -> typing.Any:
        """
        Delete the billing configuration for a given customer. Note: this is unsupported for Azure and AWS Marketplace customers.

        """
        _endpoint = f"/customers/{customer_id}/billing-config/{billing_provider_type}"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = self.session.delete(_url, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200, expected_type=typing.Any, is_error=False
            ),
            sdk_response.ResponseCaster(
                status_code=404,
                expected_type=DeleteCustomersCustomerIdBillingConfigBillingProviderTypeResponse404,
                is_error=True,
            ),
        ]

        _matching_casters = [
            c for c in _casters if c.match_code(_raw_response.status_code)
        ]
        if len(_matching_casters) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )
        _caster = _matching_casters[0]
        _response_data = _caster.cast_response(_raw_response)

        if _caster.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    def get_audit_logs(
        self,
        *,
        limit: typing.Optional[int] = None,
        next_page: typing.Optional[str] = None,
        starting_on: typing.Optional[str] = None,
    ) -> GetAuditLogsResponse:
        """
        Retrieves a range of audit logs. If no further audit logs are currently available, the data array will be empty. As new audit logs are created, subsequent requests using the same next_page value will be in the returned data array, ensuring a continuous and uninterrupted reading of audit logs.

        """
        _endpoint = f"/auditLogs"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        if limit is not None:
            _params["limit"] = limit
        if next_page is not None:
            _params["next_page"] = next_page
        if starting_on is not None:
            _params["starting_on"] = starting_on
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = self.session.get(_url, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200, expected_type=GetAuditLogsResponse, is_error=False
            ),
        ]

        _matching_casters = [
            c for c in _casters if c.match_code(_raw_response.status_code)
        ]
        if len(_matching_casters) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )
        _caster = _matching_casters[0]
        _response_data = _caster.cast_response(_raw_response)

        if _caster.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    def list_credit_types(
        self,
        *,
        limit: typing.Optional[int] = None,
        next_page: typing.Optional[str] = None,
    ) -> GetCreditTypesListResponse:
        """
        List all pricing units (known in the API by the legacy term "credit types").
        """
        _endpoint = f"/credit-types/list"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        if limit is not None:
            _params["limit"] = limit
        if next_page is not None:
            _params["next_page"] = next_page
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = self.session.get(_url, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200,
                expected_type=GetCreditTypesListResponse,
                is_error=False,
            ),
        ]

        _matching_casters = [
            c for c in _casters if c.match_code(_raw_response.status_code)
        ]
        if len(_matching_casters) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )
        _caster = _matching_casters[0]
        _response_data = _caster.cast_response(_raw_response)

        if _caster.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    def list_customers(
        self,
        *,
        customer_ids: typing.Optional[typing.List[str]] = None,
        ingest_alias: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        next_page: typing.Optional[str] = None,
        only_archived: typing.Optional[bool] = None,
        salesforce_account_ids: typing.Optional[typing.List[str]] = None,
    ) -> GetCustomersResponse:
        """
        List all customers.
        """
        _endpoint = f"/customers"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        if customer_ids is not None:
            _params["customer_ids"] = customer_ids
        if ingest_alias is not None:
            _params["ingest_alias"] = ingest_alias
        if limit is not None:
            _params["limit"] = limit
        if next_page is not None:
            _params["next_page"] = next_page
        if only_archived is not None:
            _params["only_archived"] = only_archived
        if salesforce_account_ids is not None:
            _params["salesforce_account_ids"] = salesforce_account_ids
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = self.session.get(_url, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200, expected_type=GetCustomersResponse, is_error=False
            ),
        ]

        _matching_casters = [
            c for c in _casters if c.match_code(_raw_response.status_code)
        ]
        if len(_matching_casters) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )
        _caster = _matching_casters[0]
        _response_data = _caster.cast_response(_raw_response)

        if _caster.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    def get_customer(self, *, customer_id: str) -> GetCustomersCustomerIdResponse:
        """
        Get a customer by Metronome ID.
        """
        _endpoint = f"/customers/{customer_id}"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = self.session.get(_url, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200,
                expected_type=GetCustomersCustomerIdResponse,
                is_error=False,
            ),
        ]

        _matching_casters = [
            c for c in _casters if c.match_code(_raw_response.status_code)
        ]
        if len(_matching_casters) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )
        _caster = _matching_casters[0]
        _response_data = _caster.cast_response(_raw_response)

        if _caster.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    def list_billable_metrics(
        self,
        *,
        customer_id: str,
        limit: typing.Optional[int] = None,
        next_page: typing.Optional[str] = None,
        on_current_plan: typing.Optional[bool] = None,
    ) -> GetCustomersCustomerIdBillableMetricsResponse:
        """
        List all billable metrics.
        """
        _endpoint = f"/customers/{customer_id}/billable-metrics"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        if limit is not None:
            _params["limit"] = limit
        if next_page is not None:
            _params["next_page"] = next_page
        if on_current_plan is not None:
            _params["on_current_plan"] = on_current_plan
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = self.session.get(_url, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200,
                expected_type=GetCustomersCustomerIdBillableMetricsResponse,
                is_error=False,
            ),
        ]

        _matching_casters = [
            c for c in _casters if c.match_code(_raw_response.status_code)
        ]
        if len(_matching_casters) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )
        _caster = _matching_casters[0]
        _response_data = _caster.cast_response(_raw_response)

        if _caster.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    def get_billing_config(
        self,
        *,
        customer_id: str,
        billing_provider_type: GetCustomersCustomerIdBillingConfigBillingProviderTypeBillingProviderTypeEnum,
    ) -> GetCustomersCustomerIdBillingConfigBillingProviderTypeResponse:
        """
        Fetch the billing configuration for the given customer.
        """
        _endpoint = f"/customers/{customer_id}/billing-config/{billing_provider_type}"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = self.session.get(_url, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200,
                expected_type=GetCustomersCustomerIdBillingConfigBillingProviderTypeResponse,
                is_error=False,
            ),
            sdk_response.ResponseCaster(
                status_code=404,
                expected_type=GetCustomersCustomerIdBillingConfigBillingProviderTypeResponse404,
                is_error=True,
            ),
        ]

        _matching_casters = [
            c for c in _casters if c.match_code(_raw_response.status_code)
        ]
        if len(_matching_casters) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )
        _caster = _matching_casters[0]
        _response_data = _caster.cast_response(_raw_response)

        if _caster.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    def get_costs(
        self,
        *,
        customer_id: str,
        ending_before: str,
        starting_on: str,
        limit: typing.Optional[int] = None,
        next_page: typing.Optional[str] = None,
    ) -> GetCustomersCustomerIdCostsResponse:
        """
        Fetch daily pending costs for the specified customer, broken down by credit type and line items. Note: this is not supported for customers whose plan includes a UNIQUE-type billable metric.
        """
        _endpoint = f"/customers/{customer_id}/costs"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        _params["ending_before"] = self._format_param(ending_before, False)
        _params["starting_on"] = self._format_param(starting_on, False)
        if limit is not None:
            _params["limit"] = limit
        if next_page is not None:
            _params["next_page"] = next_page
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = self.session.get(_url, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200,
                expected_type=GetCustomersCustomerIdCostsResponse,
                is_error=False,
            ),
            sdk_response.ResponseCaster(
                status_code=400,
                expected_type=GetCustomersCustomerIdCostsResponse400,
                is_error=True,
            ),
            sdk_response.ResponseCaster(
                status_code=404,
                expected_type=GetCustomersCustomerIdCostsResponse404,
                is_error=True,
            ),
        ]

        _matching_casters = [
            c for c in _casters if c.match_code(_raw_response.status_code)
        ]
        if len(_matching_casters) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )
        _caster = _matching_casters[0]
        _response_data = _caster.cast_response(_raw_response)

        if _caster.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    def list_invoices(
        self,
        *,
        customer_id: str,
        credit_type_id: typing.Optional[str] = None,
        ending_before: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        next_page: typing.Optional[str] = None,
        sort: typing.Optional[GetCustomersCustomerIdInvoicesSortEnum] = None,
        starting_on: typing.Optional[str] = None,
        status: typing.Optional[str] = None,
    ) -> GetCustomersCustomerIdInvoicesResponse:
        """
        List all invoices for a given customer, optionally filtered by status, date range, and/or credit type.
        """
        _endpoint = f"/customers/{customer_id}/invoices"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        if credit_type_id is not None:
            _params["credit_type_id"] = credit_type_id
        if ending_before is not None:
            _params["ending_before"] = ending_before
        if limit is not None:
            _params["limit"] = limit
        if next_page is not None:
            _params["next_page"] = next_page
        if sort is not None:
            _params["sort"] = sort
        if starting_on is not None:
            _params["starting_on"] = starting_on
        if status is not None:
            _params["status"] = status
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = self.session.get(_url, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200,
                expected_type=GetCustomersCustomerIdInvoicesResponse,
                is_error=False,
            ),
            sdk_response.ResponseCaster(
                status_code=404,
                expected_type=GetCustomersCustomerIdInvoicesResponse404,
                is_error=True,
            ),
        ]

        _matching_casters = [
            c for c in _casters if c.match_code(_raw_response.status_code)
        ]
        if len(_matching_casters) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )
        _caster = _matching_casters[0]
        _response_data = _caster.cast_response(_raw_response)

        if _caster.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    def get_invoice(
        self, *, customer_id: str, invoice_id: str
    ) -> GetCustomersCustomerIdInvoicesInvoiceIdResponse:
        """
        Fetch a specific invoice for a given customer.
        """
        _endpoint = f"/customers/{customer_id}/invoices/{invoice_id}"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = self.session.get(_url, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200,
                expected_type=GetCustomersCustomerIdInvoicesInvoiceIdResponse,
                is_error=False,
            ),
            sdk_response.ResponseCaster(
                status_code=404,
                expected_type=GetCustomersCustomerIdInvoicesInvoiceIdResponse404,
                is_error=True,
            ),
        ]

        _matching_casters = [
            c for c in _casters if c.match_code(_raw_response.status_code)
        ]
        if len(_matching_casters) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )
        _caster = _matching_casters[0]
        _response_data = _caster.cast_response(_raw_response)

        if _caster.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    def list_customer_plans(
        self,
        *,
        customer_id: str,
        limit: typing.Optional[int] = None,
        next_page: typing.Optional[str] = None,
    ) -> GetCustomersCustomerIdPlansResponse:
        """
        List the given customer's plans in reverse-chronological order.
        """
        _endpoint = f"/customers/{customer_id}/plans"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        if limit is not None:
            _params["limit"] = limit
        if next_page is not None:
            _params["next_page"] = next_page
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = self.session.get(_url, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200,
                expected_type=GetCustomersCustomerIdPlansResponse,
                is_error=False,
            ),
        ]

        _matching_casters = [
            c for c in _casters if c.match_code(_raw_response.status_code)
        ]
        if len(_matching_casters) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )
        _caster = _matching_casters[0]
        _response_data = _caster.cast_response(_raw_response)

        if _caster.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    def get_plan_price_adjustments(
        self,
        *,
        customer_id: str,
        customer_plan_id: str,
        limit: typing.Optional[int] = None,
        next_page: typing.Optional[str] = None,
    ) -> GetCustomersCustomerIdPlansCustomerPlanIdPriceAdjustmentsResponse:
        """
        Lists a customer plans adjustments. See the [price adjustments documentation](https://docs.metronome.com/pricing/managing-plans/#price-adjustments) for details.
        """
        _endpoint = (
            f"/customers/{customer_id}/plans/{customer_plan_id}/priceAdjustments"
        )
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        if limit is not None:
            _params["limit"] = limit
        if next_page is not None:
            _params["next_page"] = next_page
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = self.session.get(_url, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200,
                expected_type=GetCustomersCustomerIdPlansCustomerPlanIdPriceAdjustmentsResponse,
                is_error=False,
            ),
        ]

        _matching_casters = [
            c for c in _casters if c.match_code(_raw_response.status_code)
        ]
        if len(_matching_casters) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )
        _caster = _matching_casters[0]
        _response_data = _caster.cast_response(_raw_response)

        if _caster.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    def get_plan_details(self, *, plan_id: str) -> GetPlanDetailsPlanIdResponse:
        """
        Fetch high level details of a specific plan.
        """
        _endpoint = f"/planDetails/{plan_id}"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = self.session.get(_url, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200,
                expected_type=GetPlanDetailsPlanIdResponse,
                is_error=False,
            ),
        ]

        _matching_casters = [
            c for c in _casters if c.match_code(_raw_response.status_code)
        ]
        if len(_matching_casters) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )
        _caster = _matching_casters[0]
        _response_data = _caster.cast_response(_raw_response)

        if _caster.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    def get_plan_charges(
        self,
        *,
        plan_id: str,
        limit: typing.Optional[int] = None,
        next_page: typing.Optional[str] = None,
    ) -> GetPlanDetailsPlanIdChargesResponse:
        """
        Fetches a list of charges of a specific plan.
        """
        _endpoint = f"/planDetails/{plan_id}/charges"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        if limit is not None:
            _params["limit"] = limit
        if next_page is not None:
            _params["next_page"] = next_page
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = self.session.get(_url, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200,
                expected_type=GetPlanDetailsPlanIdChargesResponse,
                is_error=False,
            ),
        ]

        _matching_casters = [
            c for c in _casters if c.match_code(_raw_response.status_code)
        ]
        if len(_matching_casters) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )
        _caster = _matching_casters[0]
        _response_data = _caster.cast_response(_raw_response)

        if _caster.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    def get_plan_customers(
        self,
        *,
        plan_id: str,
        limit: typing.Optional[int] = None,
        next_page: typing.Optional[str] = None,
        status: typing.Optional[GetPlanDetailsPlanIdCustomersStatusEnum] = None,
    ) -> GetPlanDetailsPlanIdCustomersResponse:
        """
        Fetches a list of customers on a specific plan (by default, only currently active plans are included)
        """
        _endpoint = f"/planDetails/{plan_id}/customers"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        if limit is not None:
            _params["limit"] = limit
        if next_page is not None:
            _params["next_page"] = next_page
        if status is not None:
            _params["status"] = status
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = self.session.get(_url, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200,
                expected_type=GetPlanDetailsPlanIdCustomersResponse,
                is_error=False,
            ),
        ]

        _matching_casters = [
            c for c in _casters if c.match_code(_raw_response.status_code)
        ]
        if len(_matching_casters) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )
        _caster = _matching_casters[0]
        _response_data = _caster.cast_response(_raw_response)

        if _caster.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    def list_plans(
        self,
        *,
        limit: typing.Optional[int] = None,
        next_page: typing.Optional[str] = None,
    ) -> GetPlansResponse:
        """
        List all available plans.
        """
        _endpoint = f"/plans"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        if limit is not None:
            _params["limit"] = limit
        if next_page is not None:
            _params["next_page"] = next_page
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = self.session.get(_url, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200, expected_type=GetPlansResponse, is_error=False
            ),
        ]

        _matching_casters = [
            c for c in _casters if c.match_code(_raw_response.status_code)
        ]
        if len(_matching_casters) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )
        _caster = _matching_casters[0]
        _response_data = _caster.cast_response(_raw_response)

        if _caster.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    def archive_alert(
        self, *, data: typing.Optional[PostAlertsArchiveBody] = None
    ) -> PostAlertsArchiveResponse:
        """
        Archive an existing alert
        """
        _endpoint = f"/alerts/archive"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        _json_data = self._to_json_encodable(data)
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = self.session.post(_url, json=_json_data, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200, expected_type=PostAlertsArchiveResponse, is_error=False
            ),
            sdk_response.ResponseCaster(
                status_code=404,
                expected_type=PostAlertsArchiveResponse404,
                is_error=True,
            ),
        ]

        _matching_casters = [
            c for c in _casters if c.match_code(_raw_response.status_code)
        ]
        if len(_matching_casters) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )
        _caster = _matching_casters[0]
        _response_data = _caster.cast_response(_raw_response)

        if _caster.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    def create_alert(
        self, *, data: typing.Optional[PostAlertsCreateBody] = None
    ) -> PostAlertsCreateResponse:
        """
        Create a new alert
        """
        _endpoint = f"/alerts/create"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        _json_data = self._to_json_encodable(data)
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = self.session.post(_url, json=_json_data, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200, expected_type=PostAlertsCreateResponse, is_error=False
            ),
        ]

        _matching_casters = [
            c for c in _casters if c.match_code(_raw_response.status_code)
        ]
        if len(_matching_casters) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )
        _caster = _matching_casters[0]
        _response_data = _caster.cast_response(_raw_response)

        if _caster.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    def create_grant(
        self, *, data: typing.Optional[PostCreditsCreateGrantBody] = None
    ) -> PostCreditsCreateGrantResponse:
        """
        Create a new credit grant
        """
        _endpoint = f"/credits/createGrant"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        _json_data = self._to_json_encodable(data)
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = self.session.post(_url, json=_json_data, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200,
                expected_type=PostCreditsCreateGrantResponse,
                is_error=False,
            ),
        ]

        _matching_casters = [
            c for c in _casters if c.match_code(_raw_response.status_code)
        ]
        if len(_matching_casters) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )
        _caster = _matching_casters[0]
        _response_data = _caster.cast_response(_raw_response)

        if _caster.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    def edit_grant(
        self, *, data: typing.Optional[PostCreditsEditGrantBody] = None
    ) -> PostCreditsEditGrantResponse:
        """
        Edit an existing credit grant
        """
        _endpoint = f"/credits/editGrant"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        _json_data = self._to_json_encodable(data)
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = self.session.post(_url, json=_json_data, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200,
                expected_type=PostCreditsEditGrantResponse,
                is_error=False,
            ),
            sdk_response.ResponseCaster(
                status_code=400,
                expected_type=PostCreditsEditGrantResponse400,
                is_error=True,
            ),
        ]

        _matching_casters = [
            c for c in _casters if c.match_code(_raw_response.status_code)
        ]
        if len(_matching_casters) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )
        _caster = _matching_casters[0]
        _response_data = _caster.cast_response(_raw_response)

        if _caster.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    def list_credit_ledger_entries(
        self,
        *,
        data: typing.Optional[PostCreditsListEntriesBody] = None,
        next_page: typing.Optional[str] = None,
    ) -> PostCreditsListEntriesResponse:
        """
        Fetches a list of credit ledger entries. Returns lists of ledgers per customer. Ledger entries are returned in reverse chronological order. Ledger entries associated with voided credit grants are not included.
        """
        _endpoint = f"/credits/listEntries"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        if next_page is not None:
            _params["next_page"] = next_page
        _json_data = self._to_json_encodable(data)
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = self.session.post(_url, json=_json_data, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200,
                expected_type=PostCreditsListEntriesResponse,
                is_error=False,
            ),
            sdk_response.ResponseCaster(
                status_code=404,
                expected_type=PostCreditsListEntriesResponse404,
                is_error=True,
            ),
        ]

        _matching_casters = [
            c for c in _casters if c.match_code(_raw_response.status_code)
        ]
        if len(_matching_casters) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )
        _caster = _matching_casters[0]
        _response_data = _caster.cast_response(_raw_response)

        if _caster.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    def list_grants(
        self,
        *,
        data: typing.Optional[PostCreditsListGrantsBody] = None,
        next_page: typing.Optional[str] = None,
    ) -> PostCreditsListGrantsResponse:
        """
        List credit grants. This list does not included voided grants.
        """
        _endpoint = f"/credits/listGrants"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        if next_page is not None:
            _params["next_page"] = next_page
        _json_data = self._to_json_encodable(data)
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = self.session.post(_url, json=_json_data, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200,
                expected_type=PostCreditsListGrantsResponse,
                is_error=False,
            ),
        ]

        _matching_casters = [
            c for c in _casters if c.match_code(_raw_response.status_code)
        ]
        if len(_matching_casters) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )
        _caster = _matching_casters[0]
        _response_data = _caster.cast_response(_raw_response)

        if _caster.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    def void_grant(
        self, *, data: typing.Optional[PostCreditsVoidGrantBody] = None
    ) -> PostCreditsVoidGrantResponse:
        """
        Void a credit grant
        """
        _endpoint = f"/credits/voidGrant"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        _json_data = self._to_json_encodable(data)
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = self.session.post(_url, json=_json_data, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200,
                expected_type=PostCreditsVoidGrantResponse,
                is_error=False,
            ),
            sdk_response.ResponseCaster(
                status_code=400,
                expected_type=PostCreditsVoidGrantResponse400,
                is_error=True,
            ),
        ]

        _matching_casters = [
            c for c in _casters if c.match_code(_raw_response.status_code)
        ]
        if len(_matching_casters) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )
        _caster = _matching_casters[0]
        _response_data = _caster.cast_response(_raw_response)

        if _caster.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    def add_custom_field_key(
        self, *, data: typing.Optional[PostCustomFieldsAddKeyBody] = None
    ) -> typing.Any:
        """
        Add a key to the allow list for a given entity. There is a 100 character limit on custom field keys.

        """
        _endpoint = f"/customFields/addKey"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        _json_data = self._to_json_encodable(data)
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = self.session.post(_url, json=_json_data, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200, expected_type=typing.Any, is_error=False
            ),
        ]

        _matching_casters = [
            c for c in _casters if c.match_code(_raw_response.status_code)
        ]
        if len(_matching_casters) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )
        _caster = _matching_casters[0]
        _response_data = _caster.cast_response(_raw_response)

        if _caster.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    def delete_custom_fields(
        self, *, data: typing.Optional[PostCustomFieldsDeleteValuesBody] = None
    ) -> typing.Any:
        """
        Deletes one or more custom fields on an instance of a Metronome entity.

        """
        _endpoint = f"/customFields/deleteValues"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        _json_data = self._to_json_encodable(data)
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = self.session.post(_url, json=_json_data, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200, expected_type=typing.Any, is_error=False
            ),
        ]

        _matching_casters = [
            c for c in _casters if c.match_code(_raw_response.status_code)
        ]
        if len(_matching_casters) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )
        _caster = _matching_casters[0]
        _response_data = _caster.cast_response(_raw_response)

        if _caster.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    def list_custom_field_keys(
        self,
        *,
        data: typing.Optional[PostCustomFieldsListKeysBody] = None,
        next_page: typing.Optional[str] = None,
    ) -> PostCustomFieldsListKeysResponse:
        """
        List all active custom field keys, optionally filtered by entity type.

        """
        _endpoint = f"/customFields/listKeys"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        if next_page is not None:
            _params["next_page"] = next_page
        _json_data = self._to_json_encodable(data)
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = self.session.post(_url, json=_json_data, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200,
                expected_type=PostCustomFieldsListKeysResponse,
                is_error=False,
            ),
        ]

        _matching_casters = [
            c for c in _casters if c.match_code(_raw_response.status_code)
        ]
        if len(_matching_casters) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )
        _caster = _matching_casters[0]
        _response_data = _caster.cast_response(_raw_response)

        if _caster.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    def disable_custom_field_key(
        self, *, data: typing.Optional[PostCustomFieldsRemoveKeyBody] = None
    ) -> typing.Any:
        """
        Remove a key from the allow list for a given entity.

        """
        _endpoint = f"/customFields/removeKey"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        _json_data = self._to_json_encodable(data)
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = self.session.post(_url, json=_json_data, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200, expected_type=typing.Any, is_error=False
            ),
        ]

        _matching_casters = [
            c for c in _casters if c.match_code(_raw_response.status_code)
        ]
        if len(_matching_casters) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )
        _caster = _matching_casters[0]
        _response_data = _caster.cast_response(_raw_response)

        if _caster.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    def set_custom_fields(
        self, *, data: typing.Optional[PostCustomFieldsSetValuesBody] = None
    ) -> typing.Any:
        """
        Sets one or more custom fields on an instance of a Metronome entity. If a key/value pair passed in this request matches one already set on the entity, its value will be overwritten. Any key/value pairs that exist on the entity that do not match those passed in this request will remain untouched. This endpoint is transactional and will update all key/value pairs or no key/value pairs. Partial updates are not supported. There is a 200 character limit on custom field values.

        """
        _endpoint = f"/customFields/setValues"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        _json_data = self._to_json_encodable(data)
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = self.session.post(_url, json=_json_data, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200, expected_type=typing.Any, is_error=False
            ),
        ]

        _matching_casters = [
            c for c in _casters if c.match_code(_raw_response.status_code)
        ]
        if len(_matching_casters) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )
        _caster = _matching_casters[0]
        _response_data = _caster.cast_response(_raw_response)

        if _caster.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    def get_customer_alert(
        self, *, data: typing.Optional[PostCustomerAlertsGetBody] = None
    ) -> PostCustomerAlertsGetResponse:
        """
        Get the customer alert status and alert information for the specified customer and alert
        """
        _endpoint = f"/customer-alerts/get"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        _json_data = self._to_json_encodable(data)
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = self.session.post(_url, json=_json_data, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200,
                expected_type=PostCustomerAlertsGetResponse,
                is_error=False,
            ),
            sdk_response.ResponseCaster(
                status_code=404,
                expected_type=PostCustomerAlertsGetResponse404,
                is_error=True,
            ),
        ]

        _matching_casters = [
            c for c in _casters if c.match_code(_raw_response.status_code)
        ]
        if len(_matching_casters) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )
        _caster = _matching_casters[0]
        _response_data = _caster.cast_response(_raw_response)

        if _caster.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    def list_customer_alerts(
        self,
        *,
        data: typing.Optional[PostCustomerAlertsListBody] = None,
        next_page: typing.Optional[str] = None,
    ) -> PostCustomerAlertsListResponse:
        """
        Fetch all customer alert statuses and alert information for a customer
        """
        _endpoint = f"/customer-alerts/list"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        if next_page is not None:
            _params["next_page"] = next_page
        _json_data = self._to_json_encodable(data)
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = self.session.post(_url, json=_json_data, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200,
                expected_type=PostCustomerAlertsListResponse,
                is_error=False,
            ),
        ]

        _matching_casters = [
            c for c in _casters if c.match_code(_raw_response.status_code)
        ]
        if len(_matching_casters) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )
        _caster = _matching_casters[0]
        _response_data = _caster.cast_response(_raw_response)

        if _caster.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    def create_customer(
        self, *, data: typing.Optional[PostCustomersBody] = None
    ) -> PostCustomersResponse:
        """
        Create a new customer
        """
        _endpoint = f"/customers"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        _json_data = self._to_json_encodable(data)
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = self.session.post(_url, json=_json_data, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200, expected_type=PostCustomersResponse, is_error=False
            ),
            sdk_response.ResponseCaster(
                status_code=409, expected_type=PostCustomersResponse409, is_error=True
            ),
        ]

        _matching_casters = [
            c for c in _casters if c.match_code(_raw_response.status_code)
        ]
        if len(_matching_casters) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )
        _caster = _matching_casters[0]
        _response_data = _caster.cast_response(_raw_response)

        if _caster.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    def archive_customer(
        self, *, data: typing.Optional[PostCustomersArchiveBody] = None
    ) -> PostCustomersArchiveResponse:
        """
        Archive a customer
        """
        _endpoint = f"/customers/archive"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        _json_data = self._to_json_encodable(data)
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = self.session.post(_url, json=_json_data, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200,
                expected_type=PostCustomersArchiveResponse,
                is_error=False,
            ),
            sdk_response.ResponseCaster(
                status_code=400,
                expected_type=PostCustomersArchiveResponse400,
                is_error=True,
            ),
            sdk_response.ResponseCaster(
                status_code=404,
                expected_type=PostCustomersArchiveResponse404,
                is_error=True,
            ),
        ]

        _matching_casters = [
            c for c in _casters if c.match_code(_raw_response.status_code)
        ]
        if len(_matching_casters) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )
        _caster = _matching_casters[0]
        _response_data = _caster.cast_response(_raw_response)

        if _caster.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    def set_billing_config_for_customer(
        self,
        *,
        data: typing.Optional[
            PostCustomersCustomerIdBillingConfigBillingProviderTypeBody
        ] = None,
        customer_id: str,
        billing_provider_type: PostCustomersCustomerIdBillingConfigBillingProviderTypeBillingProviderTypeEnum,
    ) -> typing.Any:
        """
        Set the billing configuration for a given customer.
        """
        _endpoint = f"/customers/{customer_id}/billing-config/{billing_provider_type}"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        _json_data = self._to_json_encodable(data)
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = self.session.post(_url, json=_json_data, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200, expected_type=typing.Any, is_error=False
            ),
            sdk_response.ResponseCaster(
                status_code=400,
                expected_type=PostCustomersCustomerIdBillingConfigBillingProviderTypeResponse400,
                is_error=True,
            ),
            sdk_response.ResponseCaster(
                status_code=404,
                expected_type=PostCustomersCustomerIdBillingConfigBillingProviderTypeResponse404,
                is_error=True,
            ),
        ]

        _matching_casters = [
            c for c in _casters if c.match_code(_raw_response.status_code)
        ]
        if len(_matching_casters) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )
        _caster = _matching_casters[0]
        _response_data = _caster.cast_response(_raw_response)

        if _caster.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    def add_plan_to_customer(
        self,
        *,
        data: typing.Optional[PostCustomersCustomerIdPlansAddBody] = None,
        customer_id: str,
    ) -> PostCustomersCustomerIdPlansAddResponse:
        """
        Associate an existing customer with a plan for a specified date range.  See the [price adjustments documentation](https://docs.metronome.com/pricing/managing-plans/#price-adjustments) for details on the price adjustments.
        """
        _endpoint = f"/customers/{customer_id}/plans/add"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        _json_data = self._to_json_encodable(data)
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = self.session.post(_url, json=_json_data, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200,
                expected_type=PostCustomersCustomerIdPlansAddResponse,
                is_error=False,
            ),
        ]

        _matching_casters = [
            c for c in _casters if c.match_code(_raw_response.status_code)
        ]
        if len(_matching_casters) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )
        _caster = _matching_casters[0]
        _response_data = _caster.cast_response(_raw_response)

        if _caster.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    def end_customer_plan(
        self,
        *,
        data: typing.Optional[PostCustomersCustomerIdPlansCustomerPlanIdEndBody] = None,
        customer_id: str,
        customer_plan_id: str,
    ) -> typing.Dict[str, typing.Any]:
        """
        Change the end date of a customer's plan.
        """
        _endpoint = f"/customers/{customer_id}/plans/{customer_plan_id}/end"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        _json_data = self._to_json_encodable(data)
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = self.session.post(_url, json=_json_data, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200,
                expected_type=typing.Dict[str, typing.Any],
                is_error=False,
            ),
        ]

        _matching_casters = [
            c for c in _casters if c.match_code(_raw_response.status_code)
        ]
        if len(_matching_casters) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )
        _caster = _matching_casters[0]
        _response_data = _caster.cast_response(_raw_response)

        if _caster.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    def set_ingest_aliases(
        self,
        *,
        data: typing.Optional[PostCustomersCustomerIdSetIngestAliasesBody] = None,
        customer_id: str,
    ) -> typing.Any:
        """
        Sets the ingest aliases for a customer. Ingest aliases can be used in the `customer_id` field when sending usage events to Metronome. This call is idempotent. It fully replaces the set of ingest aliases for the given customer.

        """
        _endpoint = f"/customers/{customer_id}/setIngestAliases"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        _json_data = self._to_json_encodable(data)
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = self.session.post(_url, json=_json_data, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200, expected_type=typing.Any, is_error=False
            ),
        ]

        _matching_casters = [
            c for c in _casters if c.match_code(_raw_response.status_code)
        ]
        if len(_matching_casters) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )
        _caster = _matching_casters[0]
        _response_data = _caster.cast_response(_raw_response)

        if _caster.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    def set_customer_name(
        self,
        *,
        data: typing.Optional[PostCustomersCustomerIdSetNameBody] = None,
        customer_id: str,
    ) -> PostCustomersCustomerIdSetNameResponse:
        """
        Updates the specified customer's name.

        """
        _endpoint = f"/customers/{customer_id}/setName"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        _json_data = self._to_json_encodable(data)
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = self.session.post(_url, json=_json_data, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200,
                expected_type=PostCustomersCustomerIdSetNameResponse,
                is_error=False,
            ),
        ]

        _matching_casters = [
            c for c in _casters if c.match_code(_raw_response.status_code)
        ]
        if len(_matching_casters) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )
        _caster = _matching_casters[0]
        _response_data = _caster.cast_response(_raw_response)

        if _caster.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    def update_customer_config(
        self,
        *,
        data: typing.Optional[PostCustomersCustomerIdUpdateConfigBody] = None,
        customer_id: str,
    ) -> typing.Any:
        """
        Updates the specified customer's config.

        """
        _endpoint = f"/customers/{customer_id}/updateConfig"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        _json_data = self._to_json_encodable(data)
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = self.session.post(_url, json=_json_data, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200, expected_type=typing.Any, is_error=False
            ),
            sdk_response.ResponseCaster(
                status_code=400,
                expected_type=PostCustomersCustomerIdUpdateConfigResponse400,
                is_error=True,
            ),
            sdk_response.ResponseCaster(
                status_code=404,
                expected_type=PostCustomersCustomerIdUpdateConfigResponse404,
                is_error=True,
            ),
        ]

        _matching_casters = [
            c for c in _casters if c.match_code(_raw_response.status_code)
        ]
        if len(_matching_casters) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )
        _caster = _matching_casters[0]
        _response_data = _caster.cast_response(_raw_response)

        if _caster.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    def embeddable_dashboard(
        self, *, data: typing.Optional[PostDashboardsGetEmbeddableUrlBody] = None
    ) -> PostDashboardsGetEmbeddableUrlResponse:
        """
        Retrieve an embeddable dashboard url for a customer.  The dashboard can be embedded using an iframe in a website.  This will show information such as usage data and customer invoices.
        """
        _endpoint = f"/dashboards/getEmbeddableUrl"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        _json_data = self._to_json_encodable(data)
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = self.session.post(_url, json=_json_data, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200,
                expected_type=PostDashboardsGetEmbeddableUrlResponse,
                is_error=False,
            ),
            sdk_response.ResponseCaster(
                status_code=400,
                expected_type=PostDashboardsGetEmbeddableUrlResponse400,
                is_error=True,
            ),
        ]

        _matching_casters = [
            c for c in _casters if c.match_code(_raw_response.status_code)
        ]
        if len(_matching_casters) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )
        _caster = _matching_casters[0]
        _response_data = _caster.cast_response(_raw_response)

        if _caster.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    def ingest(
        self, *, data: typing.Optional[typing.List[PostIngestBodyItem]] = None
    ) -> typing.Any:
        """
        Send usage events to Metronome. The body of this request is expected to be a JSON array of between 1 and 100 usage events. Compressed request bodies are supported with a `Content-Encoding: gzip` header. See [Getting usage into Metronome](https://docs.metronome.com/getting-usage-data-into-metronome/overview) to learn more about usage events.

        """
        _endpoint = f"/ingest"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        _json_data = self._to_json_encodable(data)
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = self.session.post(_url, json=_json_data, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200, expected_type=typing.Any, is_error=False
            ),
        ]

        _matching_casters = [
            c for c in _casters if c.match_code(_raw_response.status_code)
        ]
        if len(_matching_casters) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )
        _caster = _matching_casters[0]
        _response_data = _caster.cast_response(_raw_response)

        if _caster.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    def get_usage_batch(
        self,
        *,
        data: typing.Optional[PostUsageBody] = None,
        next_page: typing.Optional[str] = None,
    ) -> PostUsageResponse:
        """
        Fetch aggregated usage data for multiple customers and billable-metrics, broken into intervals of the specified length.
        """
        _endpoint = f"/usage"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        if next_page is not None:
            _params["next_page"] = next_page
        _json_data = self._to_json_encodable(data)
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = self.session.post(_url, json=_json_data, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200, expected_type=PostUsageResponse, is_error=False
            ),
        ]

        _matching_casters = [
            c for c in _casters if c.match_code(_raw_response.status_code)
        ]
        if len(_matching_casters) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )
        _caster = _matching_casters[0]
        _response_data = _caster.cast_response(_raw_response)

        if _caster.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data

    def get_paged_usage(
        self,
        *,
        data: typing.Optional[PostUsageGroupsBody] = None,
        limit: typing.Optional[int] = None,
        next_page: typing.Optional[str] = None,
    ) -> PostUsageGroupsResponse:
        """
        Fetch aggregated usage data for the specified customer, billable-metric, and optional group, broken into intervals of the specified length.
        """
        _endpoint = f"/usage/groups"
        _url = f"{self.base_url}{_endpoint}"

        _params = {}  # type: dict[str, typing.Any]
        if limit is not None:
            _params["limit"] = limit
        if next_page is not None:
            _params["next_page"] = next_page
        _json_data = self._to_json_encodable(data)
        _authed_kwargs = self._add_auth(
            [
                "bearerAuth",
            ],
            params=_params,
        )
        _raw_response = self.session.post(_url, json=_json_data, **_authed_kwargs)

        _casters = [
            sdk_response.ResponseCaster(
                status_code=200, expected_type=PostUsageGroupsResponse, is_error=False
            ),
        ]

        _matching_casters = [
            c for c in _casters if c.match_code(_raw_response.status_code)
        ]
        if len(_matching_casters) == 0:
            raise sdk_errors.UnexpectedStatusCodeException(
                response=_raw_response,
                expected_codes=[c.status_code_str for c in _casters],
            )
        _caster = _matching_casters[0]
        _response_data = _caster.cast_response(_raw_response)

        if _caster.is_error:
            raise sdk_errors.RequestException(
                response=_raw_response, data=_response_data
            )

        return _response_data
