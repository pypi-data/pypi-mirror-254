# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/05_solv.ipynb.

# %% auto 0
__all__ = ['EulerODE', 'EulerSDE', 'SRK', 'MidpointODE', 'MidpointSDE', 'LogODEMidpoint', 'Heun', 'EulerHeun', 'ReversibleHeun',
           'AdjointReversibleHeun', 'MilsteinIto', 'MilsteinStratonovich', 'RungeKutta4', 'DormandPrince45',
           'Tsitouras45', 'ImplicitEuler', 'AsynchronousLeapfrog', 'SolverSystem', 'SolverModule', 'SolverKind',
           'Solvers', 'SolverSpecification', 'BaseODE', 'BaseSDE']

# %% ../nbs/05_solv.ipynb 6
from importlib import import_module
from enum import Enum, StrEnum, auto
from itertools import zip_longest

# %% ../nbs/05_solv.ipynb 8
#| export


# %% ../nbs/05_solv.ipynb 10
#| export


# %% ../nbs/05_solv.ipynb 12
#| export


# %% ../nbs/05_solv.ipynb 14
from .util import missing

# %% ../nbs/05_solv.ipynb 16
class SolverSystem(StrEnum):
    ode = auto(); sde = auto();
    @classmethod
    def _missing_(cls, val: str): return missing(cls, val, cls.ode)

class SolverModule(StrEnum):
    ode = 'torchdyn.numerics.solvers.ode'; 
    sde = 'torchsde._core.methods';
    @classmethod
    def _missing_(cls, val: str): return missing(cls, val, cls.ode)
    
class SolverKind(StrEnum):
    ito = auto(); stratonovich = auto();
    @classmethod
    def _missing_(cls, val: str): return missing(cls, val, cls.ito)

# %% ../nbs/05_solv.ipynb 17
class Solvers:
    _registry = {}
    @classmethod
    def keys(cls): return sorted([v.regkey for v in cls._registry.values()])
    @classmethod
    def values(cls): return [cls._registry[k] for k in cls.keys()]
    @classmethod
    def attrs(cls): return [v.regattr for v in cls.values()]
    @classmethod
    def items(cls): return {cls._registry[k].regattr: cls._registry[k] for k in cls.keys()}
    @classmethod
    def all(cls): return [str(v) for v in cls.values()]
    @classmethod
    def odes(cls): return [str(s) for s in cls.values() if s.system == SolverSystem.ode]
    @classmethod
    def sdes(cls): return [str(s) for s in cls.values() if s.system == SolverSystem.sde]
    def __str__(cls): return str(cls.all())

    def __contains__(cls, item):
        for sol in cls._registry.values():
            if sol.match(item): return True
        return item in cls.all()
    
    @classmethod
    def get(cls, key: str):
        if isinstance(key, str):
            key = key.casefold()
            for reg, ins in cls._registry.items():
                if ins.match(key) or key == ins.regattr:
                    return ins
            raise KeyError(f'''Solver '{key}' not found.''')
        elif isinstance(key, tuple):
            nkey = cls.matchtuple(key)
            return cls._registry[nkey]
        elif isinstance(key, dict):
            nkey = cls.matchtuple(key)
            return cls._registry[nkey]
        
        else:
            raise KeyError(f'Invalid key type: {type(key)}')
        
    @classmethod
    def askey(cls, solv: 'SolverSpecification'): return solv.regkey
    @classmethod
    def asattr(cls, solv: 'SolverSpecification'): return solv.regattr
    
    @classmethod
    def matchdict(cls, key: dict):
        defs = (None, SolverSystem.ode, SolverModule.ode, None)
        strs = (key.get(s, None) for s in ('name', 'system', 'module', 'kind'))
        skey = tuple(next(iter(e)) for e in zip_longest(strs, defs))
        return cls.matchtuple(skey)
    
    @classmethod
    def lienent_equality(cls, a: tuple, b: tuple) -> bool:
        iseq = True
        for (x, y) in zip(a, b):
            if x is None: continue
            if x == y: continue
            if isinstance(x, str) and isinstance(y, str):
                if x.casefold() == y.casefold(): 
                    continue
            iseq = False
            break
        return iseq
    
    @classmethod
    def matchtuple(cls, key: tuple):
        defs = (None, SolverSystem.ode, SolverModule.ode, None)
        skey = list(next(iter(e)) for e in zip_longest(tuple(key), defs))
        if skey[1] is not None: skey[1] = SolverSystem(skey[1])
        if skey[2] is not None: skey[2] = SolverModule(skey[2])
        skey = tuple(skey)
        for rkey in cls._registry:
            if cls.lienent_equality(skey, rkey):  return rkey
        return skey
    
    @classmethod
    def register(cls, solv: 'SolverSpecification'):
        # Check for existing entry with case-insensitive name/synonyms
        skey = solv.regkey
        rkey = cls.matchtuple(skey)
        for rkey, rval in cls._registry.items():
            nam = solv.match(rkey[0])
            sys = solv.system == rval.system 
            mod = solv.module == rval.module 
            knd = solv.kind == rval.kind
            if nam and sys and mod and knd:
                solv = rval
                return solv
        
        # Register the instance
        cls._registry[skey] = solv
        setattr(cls, solv.regattr, solv)
        return solv

# %% ../nbs/05_solv.ipynb 18
class SolverSpecification:
    system: SolverSystem = SolverSystem.ode, 
    module: SolverModule = SolverModule.ode,
    def __init__(
        self, 
        name: str | None = None,         
        synonyms: set[str] = set(), 
        kind: SolverKind | None = None,
        system: SolverSystem | None = None,
        module: SolverModule | None = None,
        *args, **kwargs,
    ):
        cstr = type(self).__name__        
        self.name = name or cstr
        self.synonyms = synonyms | {name, cstr}
        self.system = system or SolverSystem(type(self).system)
        self.module = module or SolverModule(type(self).module)
        self.kind = kind if kind is None else SolverKind(kind)
        self.synonyms |= {self.regattr}
        # Register the instance
        self = Solvers.register(self)
        
    @property
    def lib(self) -> str: 
        return self.module.partition('.')[0]
    
    @classmethod
    def askey(cls, solv: 'SolverSpecification') -> tuple[str, SolverSystem, SolverModule, SolverKind | None]: 
        return (solv.name, solv.system, solv.module, solv.kind)

    @classmethod
    def asattr(cls, solv: 'SolverSpecification') -> str:
        n, s, m, k = cls.askey(solv)
        attr = f'{n}'
        if k is not None: attr += f'{k.capitalize()}'
        if s is not None: attr += f'{s.upper()}'
        return attr
        
    @property
    def regkey(self) -> tuple[str, SolverSystem, SolverModule, SolverKind | None]: 
        return type(self).askey(self)
    
    @property
    def regattr(self) -> str:
        return type(self).asattr(self)
    
    def __str__(self) -> str:
        return self.name
     
    def __repr__(self) -> str:
        return f'{self.name}({self.system.upper()}Solver)'
        
    def load(self) -> type:
        mod = import_module(str(self.module))
        attr = f'{self.name}'
        if self.kind is not None:
            attr = f'{attr}{self.kind.capitalize()}'
        return getattr(mod, attr)

    def names(self) -> set[str]:
        return {n.casefold() for n in self.synonyms}

    def match(self, s: str) -> bool:
        return str(s).casefold() in self.names()

    def __contains__(self, other: str) -> bool:
        if isinstance(other, SolverSpecification):
            return any(map(self.match, other.names()))
        return self.match(other)

    def __eq__(self, other):
        match = other in self
        if not isinstance(other, SolverSpecification): return match
        attrs = self.system == other.system and self.kind == other.kind and self.module == other.module
        return match and attrs and self.name == other.name
    


# %% ../nbs/05_solv.ipynb 19
class BaseODE(SolverSpecification):
    module = SolverModule.ode; system = SolverSystem.ode;
    
class BaseSDE(SolverSpecification):
    module = SolverModule.sde; system = SolverSystem.sde;

# %% ../nbs/05_solv.ipynb 20
EulerODE = BaseODE('Euler')
EulerSDE = BaseSDE('Euler')
SRK = BaseSDE('SRK')
MidpointODE = BaseODE('Midpoint')
MidpointSDE = BaseSDE('Midpoint')
LogODEMidpoint = BaseSDE('LogODEMidpoint')
Heun = BaseSDE('Heun')
EulerHeun = BaseSDE('EulerHeun')
ReversibleHeun = BaseSDE('ReversibleHeun', synonyms={'rheun'})
AdjointReversibleHeun = BaseSDE('AdjointReversibleHeun', synonyms={'arheun'})
MilsteinIto = BaseSDE('MilsteinIto', kind=SolverKind.ito, synonyms={'milito'})
MilsteinStratonovich = BaseSDE('MilsteinStratonovich', kind=SolverKind.stratonovich, synonyms={'milvich'})
RungeKutta4 = BaseODE('RungeKutta4', synonyms={'rk4', 'rk-4'})
DormandPrince45 = BaseODE('DormandPrince45', synonyms={'dopri5', 'dp45', 'dp-45'})
Tsitouras45 = BaseODE('Tsitouras45', synonyms={'tsit5', 'tsit-5'})
ImplicitEuler = BaseODE('ImplicitEuler', synonyms={'ieuler', 'ie'})
AsynchronousLeapfrog =  BaseODE('AsynchronousLeapfrog', synonyms={'alf'})

# %% ../nbs/05_solv.ipynb 26
#| export
