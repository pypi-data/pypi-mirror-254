# -*- coding: utf-8 -*-
# This file is auto-generated, don't edit it. Thanks.
from Tea.model import TeaModel
from typing import Dict, List, Any


class AddDataForApiSourceRequest(TeaModel):
    def __init__(
        self,
        api_id: str = None,
        content: str = None,
        iot_instance_id: str = None,
    ):
        self.api_id = api_id
        self.content = content
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.api_id is not None:
            result['ApiId'] = self.api_id
        if self.content is not None:
            result['Content'] = self.content
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApiId') is not None:
            self.api_id = m.get('ApiId')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class AddDataForApiSourceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: int = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class AddDataForApiSourceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddDataForApiSourceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddDataForApiSourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddDeviceToSharePromotionRequestDeviceSimpleInfoList(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        product_key: str = None,
    ):
        self.device_name = device_name
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class AddDeviceToSharePromotionRequest(TeaModel):
    def __init__(
        self,
        device_simple_info_list: List[AddDeviceToSharePromotionRequestDeviceSimpleInfoList] = None,
        iot_instance_id: str = None,
        share_promotion_activity_id: str = None,
        share_task_code: str = None,
    ):
        self.device_simple_info_list = device_simple_info_list
        self.iot_instance_id = iot_instance_id
        self.share_promotion_activity_id = share_promotion_activity_id
        self.share_task_code = share_task_code

    def validate(self):
        if self.device_simple_info_list:
            for k in self.device_simple_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DeviceSimpleInfoList'] = []
        if self.device_simple_info_list is not None:
            for k in self.device_simple_info_list:
                result['DeviceSimpleInfoList'].append(k.to_map() if k else None)
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.share_promotion_activity_id is not None:
            result['SharePromotionActivityId'] = self.share_promotion_activity_id
        if self.share_task_code is not None:
            result['ShareTaskCode'] = self.share_task_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.device_simple_info_list = []
        if m.get('DeviceSimpleInfoList') is not None:
            for k in m.get('DeviceSimpleInfoList'):
                temp_model = AddDeviceToSharePromotionRequestDeviceSimpleInfoList()
                self.device_simple_info_list.append(temp_model.from_map(k))
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('SharePromotionActivityId') is not None:
            self.share_promotion_activity_id = m.get('SharePromotionActivityId')
        if m.get('ShareTaskCode') is not None:
            self.share_task_code = m.get('ShareTaskCode')
        return self


class AddDeviceToSharePromotionResponseBodyDataFailDeviceSimpleInfoListItem(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        fail_code: int = None,
        fail_reason: str = None,
        product_key: str = None,
    ):
        self.device_name = device_name
        self.fail_code = fail_code
        self.fail_reason = fail_reason
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.fail_code is not None:
            result['FailCode'] = self.fail_code
        if self.fail_reason is not None:
            result['FailReason'] = self.fail_reason
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('FailCode') is not None:
            self.fail_code = m.get('FailCode')
        if m.get('FailReason') is not None:
            self.fail_reason = m.get('FailReason')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class AddDeviceToSharePromotionResponseBodyDataFailDeviceSimpleInfoList(TeaModel):
    def __init__(
        self,
        item: List[AddDeviceToSharePromotionResponseBodyDataFailDeviceSimpleInfoListItem] = None,
    ):
        self.item = item

    def validate(self):
        if self.item:
            for k in self.item:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['item'] = []
        if self.item is not None:
            for k in self.item:
                result['item'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.item = []
        if m.get('item') is not None:
            for k in m.get('item'):
                temp_model = AddDeviceToSharePromotionResponseBodyDataFailDeviceSimpleInfoListItem()
                self.item.append(temp_model.from_map(k))
        return self


class AddDeviceToSharePromotionResponseBodyData(TeaModel):
    def __init__(
        self,
        fail_device_simple_info_list: AddDeviceToSharePromotionResponseBodyDataFailDeviceSimpleInfoList = None,
    ):
        self.fail_device_simple_info_list = fail_device_simple_info_list

    def validate(self):
        if self.fail_device_simple_info_list:
            self.fail_device_simple_info_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fail_device_simple_info_list is not None:
            result['FailDeviceSimpleInfoList'] = self.fail_device_simple_info_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FailDeviceSimpleInfoList') is not None:
            temp_model = AddDeviceToSharePromotionResponseBodyDataFailDeviceSimpleInfoList()
            self.fail_device_simple_info_list = temp_model.from_map(m['FailDeviceSimpleInfoList'])
        return self


class AddDeviceToSharePromotionResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: AddDeviceToSharePromotionResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = AddDeviceToSharePromotionResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class AddDeviceToSharePromotionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddDeviceToSharePromotionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddDeviceToSharePromotionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddPowerStationRequest(TeaModel):
    def __init__(
        self,
        algorithm_instance_uid: str = None,
        description: str = None,
        iot_instance_id: str = None,
        power_station_name: str = None,
        rated_power: int = None,
    ):
        self.algorithm_instance_uid = algorithm_instance_uid
        self.description = description
        self.iot_instance_id = iot_instance_id
        self.power_station_name = power_station_name
        self.rated_power = rated_power

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.algorithm_instance_uid is not None:
            result['AlgorithmInstanceUid'] = self.algorithm_instance_uid
        if self.description is not None:
            result['Description'] = self.description
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.power_station_name is not None:
            result['PowerStationName'] = self.power_station_name
        if self.rated_power is not None:
            result['RatedPower'] = self.rated_power
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlgorithmInstanceUid') is not None:
            self.algorithm_instance_uid = m.get('AlgorithmInstanceUid')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('PowerStationName') is not None:
            self.power_station_name = m.get('PowerStationName')
        if m.get('RatedPower') is not None:
            self.rated_power = m.get('RatedPower')
        return self


class AddPowerStationResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class AddPowerStationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddPowerStationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddPowerStationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddShareTaskDeviceRequest(TeaModel):
    def __init__(
        self,
        iot_id_list: List[str] = None,
        iot_instance_id: str = None,
        product_key: str = None,
        share_task_id: str = None,
    ):
        self.iot_id_list = iot_id_list
        self.iot_instance_id = iot_instance_id
        self.product_key = product_key
        self.share_task_id = share_task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_id_list is not None:
            result['IotIdList'] = self.iot_id_list
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.share_task_id is not None:
            result['ShareTaskId'] = self.share_task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotIdList') is not None:
            self.iot_id_list = m.get('IotIdList')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('ShareTaskId') is not None:
            self.share_task_id = m.get('ShareTaskId')
        return self


class AddShareTaskDeviceResponseBodyData(TeaModel):
    def __init__(
        self,
        fail_sum: int = None,
        failed_result_csv_file: str = None,
        progress: int = None,
        progress_id: str = None,
        success_sum: int = None,
    ):
        self.fail_sum = fail_sum
        self.failed_result_csv_file = failed_result_csv_file
        self.progress = progress
        self.progress_id = progress_id
        self.success_sum = success_sum

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fail_sum is not None:
            result['FailSum'] = self.fail_sum
        if self.failed_result_csv_file is not None:
            result['FailedResultCsvFile'] = self.failed_result_csv_file
        if self.progress is not None:
            result['Progress'] = self.progress
        if self.progress_id is not None:
            result['ProgressId'] = self.progress_id
        if self.success_sum is not None:
            result['SuccessSum'] = self.success_sum
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FailSum') is not None:
            self.fail_sum = m.get('FailSum')
        if m.get('FailedResultCsvFile') is not None:
            self.failed_result_csv_file = m.get('FailedResultCsvFile')
        if m.get('Progress') is not None:
            self.progress = m.get('Progress')
        if m.get('ProgressId') is not None:
            self.progress_id = m.get('ProgressId')
        if m.get('SuccessSum') is not None:
            self.success_sum = m.get('SuccessSum')
        return self


class AddShareTaskDeviceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: AddShareTaskDeviceResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = AddShareTaskDeviceResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class AddShareTaskDeviceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddShareTaskDeviceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddShareTaskDeviceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AsyncRRpcRequest(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        ext_info: str = None,
        iot_instance_id: str = None,
        message_content: str = None,
        product_key: str = None,
        topic_full_name: str = None,
    ):
        self.device_name = device_name
        self.ext_info = ext_info
        self.iot_instance_id = iot_instance_id
        self.message_content = message_content
        self.product_key = product_key
        self.topic_full_name = topic_full_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.ext_info is not None:
            result['ExtInfo'] = self.ext_info
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.message_content is not None:
            result['MessageContent'] = self.message_content
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.topic_full_name is not None:
            result['TopicFullName'] = self.topic_full_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('ExtInfo') is not None:
            self.ext_info = m.get('ExtInfo')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('MessageContent') is not None:
            self.message_content = m.get('MessageContent')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('TopicFullName') is not None:
            self.topic_full_name = m.get('TopicFullName')
        return self


class AsyncRRpcResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        message_id: int = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.message_id = message_id
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.message_id is not None:
            result['MessageId'] = self.message_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('MessageId') is not None:
            self.message_id = m.get('MessageId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class AsyncRRpcResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AsyncRRpcResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AsyncRRpcResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AttachDestinationRequest(TeaModel):
    def __init__(
        self,
        destination_id: int = None,
        iot_instance_id: str = None,
        is_failover: bool = None,
        parser_id: int = None,
    ):
        self.destination_id = destination_id
        self.iot_instance_id = iot_instance_id
        self.is_failover = is_failover
        self.parser_id = parser_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.destination_id is not None:
            result['DestinationId'] = self.destination_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.is_failover is not None:
            result['IsFailover'] = self.is_failover
        if self.parser_id is not None:
            result['ParserId'] = self.parser_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DestinationId') is not None:
            self.destination_id = m.get('DestinationId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('IsFailover') is not None:
            self.is_failover = m.get('IsFailover')
        if m.get('ParserId') is not None:
            self.parser_id = m.get('ParserId')
        return self


class AttachDestinationResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class AttachDestinationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AttachDestinationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AttachDestinationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AttachParserDataSourceRequest(TeaModel):
    def __init__(
        self,
        data_source_id: int = None,
        iot_instance_id: str = None,
        parser_id: int = None,
    ):
        self.data_source_id = data_source_id
        self.iot_instance_id = iot_instance_id
        self.parser_id = parser_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_source_id is not None:
            result['DataSourceId'] = self.data_source_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.parser_id is not None:
            result['ParserId'] = self.parser_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataSourceId') is not None:
            self.data_source_id = m.get('DataSourceId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ParserId') is not None:
            self.parser_id = m.get('ParserId')
        return self


class AttachParserDataSourceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class AttachParserDataSourceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AttachParserDataSourceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AttachParserDataSourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchAddDataForApiSourceRequest(TeaModel):
    def __init__(
        self,
        api_id: str = None,
        content_list: str = None,
        iot_instance_id: str = None,
    ):
        self.api_id = api_id
        self.content_list = content_list
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.api_id is not None:
            result['ApiId'] = self.api_id
        if self.content_list is not None:
            result['ContentList'] = self.content_list
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApiId') is not None:
            self.api_id = m.get('ApiId')
        if m.get('ContentList') is not None:
            self.content_list = m.get('ContentList')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class BatchAddDataForApiSourceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class BatchAddDataForApiSourceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BatchAddDataForApiSourceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchAddDataForApiSourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchAddDeviceGroupRelationsRequestDevice(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        product_key: str = None,
    ):
        # The error message returned if the call fails.
        self.device_name = device_name
        # The names of the devices to be added. You can specify a maximum of 200 devices.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class BatchAddDeviceGroupRelationsRequest(TeaModel):
    def __init__(
        self,
        device: List[BatchAddDeviceGroupRelationsRequestDevice] = None,
        group_id: str = None,
        iot_instance_id: str = None,
    ):
        self.device = device
        # The ProductKeys of the products to which the devices belong. You can specify a maximum of 200 ProductKeys.
        self.group_id = group_id
        # The ID of the group. The ID is the globally unique identifier (GUID) for the group.
        self.iot_instance_id = iot_instance_id

    def validate(self):
        if self.device:
            for k in self.device:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Device'] = []
        if self.device is not None:
            for k in self.device:
                result['Device'].append(k.to_map() if k else None)
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.device = []
        if m.get('Device') is not None:
            for k in m.get('Device'):
                temp_model = BatchAddDeviceGroupRelationsRequestDevice()
                self.device.append(temp_model.from_map(k))
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class BatchAddDeviceGroupRelationsResponseBody(TeaModel):
    def __init__(
        self,
        already_related_group_device_count: int = None,
        code: str = None,
        error_message: str = None,
        exceed_ten_group_device_count: int = None,
        request_id: str = None,
        success: bool = None,
        success_added_device_count: int = None,
        valid_device_count: int = None,
    ):
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.already_related_group_device_count = already_related_group_device_count
        # The number of valid devices that you specified.
        self.code = code
        # The ID of the request.
        self.error_message = error_message
        # The number of devices that exist in the group.
        self.exceed_ten_group_device_count = exceed_ten_group_device_count
        # The number of the specified devices that are added to 10 or more groups. You can add a device to a maximum of 10 groups.
        self.request_id = request_id
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.success = success
        self.success_added_device_count = success_added_device_count
        # The number of devices that are added to the group.
        self.valid_device_count = valid_device_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.already_related_group_device_count is not None:
            result['AlreadyRelatedGroupDeviceCount'] = self.already_related_group_device_count
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.exceed_ten_group_device_count is not None:
            result['ExceedTenGroupDeviceCount'] = self.exceed_ten_group_device_count
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.success_added_device_count is not None:
            result['SuccessAddedDeviceCount'] = self.success_added_device_count
        if self.valid_device_count is not None:
            result['ValidDeviceCount'] = self.valid_device_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlreadyRelatedGroupDeviceCount') is not None:
            self.already_related_group_device_count = m.get('AlreadyRelatedGroupDeviceCount')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('ExceedTenGroupDeviceCount') is not None:
            self.exceed_ten_group_device_count = m.get('ExceedTenGroupDeviceCount')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('SuccessAddedDeviceCount') is not None:
            self.success_added_device_count = m.get('SuccessAddedDeviceCount')
        if m.get('ValidDeviceCount') is not None:
            self.valid_device_count = m.get('ValidDeviceCount')
        return self


class BatchAddDeviceGroupRelationsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BatchAddDeviceGroupRelationsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchAddDeviceGroupRelationsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchAddThingTopoRequestTopoAddItem(TeaModel):
    def __init__(
        self,
        client_id: str = None,
        device_name: str = None,
        product_key: str = None,
        sign: str = None,
        sign_method: str = None,
        timestamp: str = None,
    ):
        # The client ID of the sub-device. The ID can be the serial number (SN) or media access control (MAC) address of the device. This parameter is optional.
        # 
        # > If this parameter is included in the value of the **TopoAddItem.N.Sign** parameter, you must specify this parameter.
        self.client_id = client_id
        # The name of each sub-device.
        self.device_name = device_name
        # The key of the product to which the sub-device belongs.
        self.product_key = product_key
        # The signature of the sub-device.
        # 
        # Set the Sign parameter to the result of the **SignMethod(deviceSecret,content)** function.
        # 
        # To obtain the **content** parameter, sort all sub-device parameters that are submitted to the server, except the Sign and SignMethod parameters, in alphabetical order. Then, concatenate the parameters and values in sequence. No concatenation symbol is required to separate these parameters and values.
        # 
        # For example, you want to specify the following parameters for a sub-device: **ClientId=868575026974305, DeviceName=868575026974305, ProductKey=a1PB5fp1234, SignMethod=hmacmd5, timestamp=1646277090411, and deviceSecret=1234**. In this case, the signature function is `hmacmd5(1234, clientId868575026974305deviceName868575026974305productKeya1PB5fp1234timestamp1646277090411)`, and the calculation result is `3BA0DFA4C477B40C007D84D30D6466CC`.
        # 
        # >  In the preceding example, **ClientId** indicates the client ID of the sub-device. You can specify a custom client ID.
        # 
        # For more information about how to calculate the signature value, see [How do I obtain MQTT parameters for authentication?](~~292635~~). The signature value is the calculated value of the passwd parameter.
        self.sign = sign
        # The signature algorithm. Valid values: **hmacSha1**, **hmacSha256**, **hmacMd5**, and **Sha256**. The value is not case-sensitive.
        self.sign_method = sign_method
        # The timestamp in UTC. This parameter is optional.
        # 
        # > If this parameter is included in the value of the **TopoAddItem.N.Sign** parameter, you must specify this parameter.
        self.timestamp = timestamp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_id is not None:
            result['ClientId'] = self.client_id
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.sign is not None:
            result['Sign'] = self.sign
        if self.sign_method is not None:
            result['SignMethod'] = self.sign_method
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClientId') is not None:
            self.client_id = m.get('ClientId')
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('Sign') is not None:
            self.sign = m.get('Sign')
        if m.get('SignMethod') is not None:
            self.sign_method = m.get('SignMethod')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        return self


class BatchAddThingTopoRequest(TeaModel):
    def __init__(
        self,
        gw_device_name: str = None,
        gw_product_key: str = None,
        iot_instance_id: str = None,
        topo_add_item: List[BatchAddThingTopoRequestTopoAddItem] = None,
    ):
        # The name of the gateway.
        self.gw_device_name = gw_device_name
        # The key of the product to which the gateway belongs.
        self.gw_product_key = gw_product_key
        # The ID of the instance. On the **Overview** page in the IoT Platform console, you can view the ID of the instance.
        # 
        # >*   If your instance has an ID, you must specify this parameter. Otherwise, the call fails.
        # >*   If no **Overview** page or instance ID appears in the IoT Platform console, ignore this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        self.topo_add_item = topo_add_item

    def validate(self):
        if self.topo_add_item:
            for k in self.topo_add_item:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gw_device_name is not None:
            result['GwDeviceName'] = self.gw_device_name
        if self.gw_product_key is not None:
            result['GwProductKey'] = self.gw_product_key
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        result['TopoAddItem'] = []
        if self.topo_add_item is not None:
            for k in self.topo_add_item:
                result['TopoAddItem'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GwDeviceName') is not None:
            self.gw_device_name = m.get('GwDeviceName')
        if m.get('GwProductKey') is not None:
            self.gw_product_key = m.get('GwProductKey')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        self.topo_add_item = []
        if m.get('TopoAddItem') is not None:
            for k in m.get('TopoAddItem'):
                temp_model = BatchAddThingTopoRequestTopoAddItem()
                self.topo_add_item.append(temp_model.from_map(k))
        return self


class BatchAddThingTopoResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class BatchAddThingTopoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BatchAddThingTopoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchAddThingTopoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchBindDeviceToEdgeInstanceWithDriverRequest(TeaModel):
    def __init__(
        self,
        driver_id: str = None,
        instance_id: str = None,
        iot_ids: List[str] = None,
        iot_instance_id: str = None,
    ):
        # The IDs of the devices.
        # 
        # You can call the [QueryDevice](~~69905~~) operation to query detailed information about all devices that belong to the current Alibaba Cloud account and obtain the required device IDs.
        # 
        # >  You can specify a maximum of 20 device IDs when you call the BatchBindDeviceToEdgeInstanceWithDriver operation.
        self.driver_id = driver_id
        # The ID of the driver. To obtain the driver ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Drivers** page, move the pointer over the name of the driver that you want to configure and obtain the driver ID.
        # 
        # You can also call the [QueryEdgeDriver](~~155776~~) operation to query the driver ID.
        self.instance_id = instance_id
        self.iot_ids = iot_ids
        # The ID of the edge instance. To obtain the instance ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Edge Instances** page, move the pointer over the name of the edge instance to which you want to bind multiple devices and obtain the instance ID.
        # 
        # You can also call the [QueryEdgeInstance](~~135214~~) operation to query the instance ID.
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.driver_id is not None:
            result['DriverId'] = self.driver_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.iot_ids is not None:
            result['IotIds'] = self.iot_ids
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DriverId') is not None:
            self.driver_id = m.get('DriverId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IotIds') is not None:
            self.iot_ids = m.get('IotIds')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class BatchBindDeviceToEdgeInstanceWithDriverResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error message that is returned if the call failed.
        self.code = code
        # The ID of the request.
        self.error_message = error_message
        # Indicates whether the call was successful. A value of true indicates that the call was successful. A value of false indicates that the call failed.
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class BatchBindDeviceToEdgeInstanceWithDriverResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BatchBindDeviceToEdgeInstanceWithDriverResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchBindDeviceToEdgeInstanceWithDriverResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchBindDevicesIntoProjectRequestDevices(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        product_key: str = None,
    ):
        self.device_name = device_name
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class BatchBindDevicesIntoProjectRequest(TeaModel):
    def __init__(
        self,
        devices: List[BatchBindDevicesIntoProjectRequestDevices] = None,
        iot_instance_id: str = None,
        project_id: str = None,
    ):
        self.devices = devices
        self.iot_instance_id = iot_instance_id
        self.project_id = project_id

    def validate(self):
        if self.devices:
            for k in self.devices:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Devices'] = []
        if self.devices is not None:
            for k in self.devices:
                result['Devices'].append(k.to_map() if k else None)
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.devices = []
        if m.get('Devices') is not None:
            for k in m.get('Devices'):
                temp_model = BatchBindDevicesIntoProjectRequestDevices()
                self.devices.append(temp_model.from_map(k))
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class BatchBindDevicesIntoProjectResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: bool = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class BatchBindDevicesIntoProjectResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BatchBindDevicesIntoProjectResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchBindDevicesIntoProjectResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchBindProductsIntoProjectRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        product_keys: List[str] = None,
        project_id: str = None,
    ):
        self.iot_instance_id = iot_instance_id
        self.product_keys = product_keys
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_keys is not None:
            result['ProductKeys'] = self.product_keys
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKeys') is not None:
            self.product_keys = m.get('ProductKeys')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class BatchBindProductsIntoProjectResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: bool = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class BatchBindProductsIntoProjectResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BatchBindProductsIntoProjectResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchBindProductsIntoProjectResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchCheckDeviceNamesRequestDeviceNameList(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        device_nickname: str = None,
    ):
        self.device_name = device_name
        self.device_nickname = device_nickname

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.device_nickname is not None:
            result['DeviceNickname'] = self.device_nickname
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('DeviceNickname') is not None:
            self.device_nickname = m.get('DeviceNickname')
        return self


class BatchCheckDeviceNamesRequest(TeaModel):
    def __init__(
        self,
        device_name: List[str] = None,
        device_name_list: List[BatchCheckDeviceNamesRequestDeviceNameList] = None,
        iot_instance_id: str = None,
        product_key: str = None,
    ):
        self.device_name = device_name
        self.device_name_list = device_name_list
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The ProductKey of the product to which the devices belong.
        self.product_key = product_key

    def validate(self):
        if self.device_name_list:
            for k in self.device_name_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        result['DeviceNameList'] = []
        if self.device_name_list is not None:
            for k in self.device_name_list:
                result['DeviceNameList'].append(k.to_map() if k else None)
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        self.device_name_list = []
        if m.get('DeviceNameList') is not None:
            for k in m.get('DeviceNameList'):
                temp_model = BatchCheckDeviceNamesRequestDeviceNameList()
                self.device_name_list.append(temp_model.from_map(k))
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class BatchCheckDeviceNamesResponseBodyDataInvalidDetailListInvalidDetailList(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        error_msg: str = None,
        nick_name: str = None,
    ):
        self.device_name = device_name
        self.error_msg = error_msg
        self.nick_name = nick_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.error_msg is not None:
            result['ErrorMsg'] = self.error_msg
        if self.nick_name is not None:
            result['NickName'] = self.nick_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('ErrorMsg') is not None:
            self.error_msg = m.get('ErrorMsg')
        if m.get('NickName') is not None:
            self.nick_name = m.get('NickName')
        return self


class BatchCheckDeviceNamesResponseBodyDataInvalidDetailList(TeaModel):
    def __init__(
        self,
        invalid_detail_list: List[BatchCheckDeviceNamesResponseBodyDataInvalidDetailListInvalidDetailList] = None,
    ):
        self.invalid_detail_list = invalid_detail_list

    def validate(self):
        if self.invalid_detail_list:
            for k in self.invalid_detail_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InvalidDetailList'] = []
        if self.invalid_detail_list is not None:
            for k in self.invalid_detail_list:
                result['InvalidDetailList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.invalid_detail_list = []
        if m.get('InvalidDetailList') is not None:
            for k in m.get('InvalidDetailList'):
                temp_model = BatchCheckDeviceNamesResponseBodyDataInvalidDetailListInvalidDetailList()
                self.invalid_detail_list.append(temp_model.from_map(k))
        return self


class BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNameList(TeaModel):
    def __init__(
        self,
        invalid_device_name: List[str] = None,
    ):
        self.invalid_device_name = invalid_device_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.invalid_device_name is not None:
            result['InvalidDeviceName'] = self.invalid_device_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InvalidDeviceName') is not None:
            self.invalid_device_name = m.get('InvalidDeviceName')
        return self


class BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNicknameList(TeaModel):
    def __init__(
        self,
        invalid_device_nickname: List[str] = None,
    ):
        self.invalid_device_nickname = invalid_device_nickname

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.invalid_device_nickname is not None:
            result['InvalidDeviceNickname'] = self.invalid_device_nickname
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InvalidDeviceNickname') is not None:
            self.invalid_device_nickname = m.get('InvalidDeviceNickname')
        return self


class BatchCheckDeviceNamesResponseBodyDataRepeatedDeviceNameList(TeaModel):
    def __init__(
        self,
        repeat_devie_name_list: List[str] = None,
    ):
        self.repeat_devie_name_list = repeat_devie_name_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.repeat_devie_name_list is not None:
            result['RepeatDevieNameList'] = self.repeat_devie_name_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RepeatDevieNameList') is not None:
            self.repeat_devie_name_list = m.get('RepeatDevieNameList')
        return self


class BatchCheckDeviceNamesResponseBodyData(TeaModel):
    def __init__(
        self,
        apply_id: int = None,
        invalid_detail_list: BatchCheckDeviceNamesResponseBodyDataInvalidDetailList = None,
        invalid_device_name_list: BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNameList = None,
        invalid_device_nickname_list: BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNicknameList = None,
        repeated_device_name_list: BatchCheckDeviceNamesResponseBodyDataRepeatedDeviceNameList = None,
    ):
        self.apply_id = apply_id
        self.invalid_detail_list = invalid_detail_list
        self.invalid_device_name_list = invalid_device_name_list
        self.invalid_device_nickname_list = invalid_device_nickname_list
        self.repeated_device_name_list = repeated_device_name_list

    def validate(self):
        if self.invalid_detail_list:
            self.invalid_detail_list.validate()
        if self.invalid_device_name_list:
            self.invalid_device_name_list.validate()
        if self.invalid_device_nickname_list:
            self.invalid_device_nickname_list.validate()
        if self.repeated_device_name_list:
            self.repeated_device_name_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.apply_id is not None:
            result['ApplyId'] = self.apply_id
        if self.invalid_detail_list is not None:
            result['InvalidDetailList'] = self.invalid_detail_list.to_map()
        if self.invalid_device_name_list is not None:
            result['InvalidDeviceNameList'] = self.invalid_device_name_list.to_map()
        if self.invalid_device_nickname_list is not None:
            result['InvalidDeviceNicknameList'] = self.invalid_device_nickname_list.to_map()
        if self.repeated_device_name_list is not None:
            result['RepeatedDeviceNameList'] = self.repeated_device_name_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApplyId') is not None:
            self.apply_id = m.get('ApplyId')
        if m.get('InvalidDetailList') is not None:
            temp_model = BatchCheckDeviceNamesResponseBodyDataInvalidDetailList()
            self.invalid_detail_list = temp_model.from_map(m['InvalidDetailList'])
        if m.get('InvalidDeviceNameList') is not None:
            temp_model = BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNameList()
            self.invalid_device_name_list = temp_model.from_map(m['InvalidDeviceNameList'])
        if m.get('InvalidDeviceNicknameList') is not None:
            temp_model = BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNicknameList()
            self.invalid_device_nickname_list = temp_model.from_map(m['InvalidDeviceNicknameList'])
        if m.get('RepeatedDeviceNameList') is not None:
            temp_model = BatchCheckDeviceNamesResponseBodyDataRepeatedDeviceNameList()
            self.repeated_device_name_list = temp_model.from_map(m['RepeatedDeviceNameList'])
        return self


class BatchCheckDeviceNamesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: BatchCheckDeviceNamesResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The returned data.
        self.code = code
        self.data = data
        # The application ID (ApplyId) returned if the call is successful. When you call the [BatchRegisterDeviceWithApplyId](~~69514~~) operation to register the devices, this parameter is required.
        self.error_message = error_message
        # The list of invalid device aliases returned if the call fails.
        self.request_id = request_id
        # The list of invalid DeviceNames returned if the call fails.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = BatchCheckDeviceNamesResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class BatchCheckDeviceNamesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BatchCheckDeviceNamesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchCheckDeviceNamesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchCheckImportDeviceRequestDeviceList(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        device_secret: str = None,
        sn: str = None,
    ):
        self.device_name = device_name
        self.device_secret = device_secret
        self.sn = sn

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.device_secret is not None:
            result['DeviceSecret'] = self.device_secret
        if self.sn is not None:
            result['Sn'] = self.sn
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('DeviceSecret') is not None:
            self.device_secret = m.get('DeviceSecret')
        if m.get('Sn') is not None:
            self.sn = m.get('Sn')
        return self


class BatchCheckImportDeviceRequest(TeaModel):
    def __init__(
        self,
        device_list: List[BatchCheckImportDeviceRequestDeviceList] = None,
        iot_instance_id: str = None,
        product_key: str = None,
    ):
        self.device_list = device_list
        # The instance ID. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
        # 
        # >  If your instance has an ID, you must specify this parameter. Otherwise, the request fails. If no Overview page exists or no instance ID is displayed, you do not need to specify this parameter.
        # 
        # For more information, see the [Overview](~~356505~~) topic of IoT instances.
        self.iot_instance_id = iot_instance_id
        # The **ProductKey** of the gateway product to which the devices belong.
        self.product_key = product_key

    def validate(self):
        if self.device_list:
            for k in self.device_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DeviceList'] = []
        if self.device_list is not None:
            for k in self.device_list:
                result['DeviceList'].append(k.to_map() if k else None)
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.device_list = []
        if m.get('DeviceList') is not None:
            for k in m.get('DeviceList'):
                temp_model = BatchCheckImportDeviceRequestDeviceList()
                self.device_list.append(temp_model.from_map(k))
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class BatchCheckImportDeviceResponseBodyDataInvalidDetailList(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        device_secret: str = None,
        error_msg: str = None,
        sn: str = None,
    ):
        self.device_name = device_name
        self.device_secret = device_secret
        self.error_msg = error_msg
        self.sn = sn

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.device_secret is not None:
            result['DeviceSecret'] = self.device_secret
        if self.error_msg is not None:
            result['ErrorMsg'] = self.error_msg
        if self.sn is not None:
            result['Sn'] = self.sn
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('DeviceSecret') is not None:
            self.device_secret = m.get('DeviceSecret')
        if m.get('ErrorMsg') is not None:
            self.error_msg = m.get('ErrorMsg')
        if m.get('Sn') is not None:
            self.sn = m.get('Sn')
        return self


class BatchCheckImportDeviceResponseBodyData(TeaModel):
    def __init__(
        self,
        invalid_detail_list: List[BatchCheckImportDeviceResponseBodyDataInvalidDetailList] = None,
        invalid_device_name_list: List[str] = None,
        invalid_device_secret_list: List[str] = None,
        invalid_sn_list: List[str] = None,
        repeated_device_name_list: List[str] = None,
    ):
        self.invalid_detail_list = invalid_detail_list
        self.invalid_device_name_list = invalid_device_name_list
        self.invalid_device_secret_list = invalid_device_secret_list
        self.invalid_sn_list = invalid_sn_list
        self.repeated_device_name_list = repeated_device_name_list

    def validate(self):
        if self.invalid_detail_list:
            for k in self.invalid_detail_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InvalidDetailList'] = []
        if self.invalid_detail_list is not None:
            for k in self.invalid_detail_list:
                result['InvalidDetailList'].append(k.to_map() if k else None)
        if self.invalid_device_name_list is not None:
            result['InvalidDeviceNameList'] = self.invalid_device_name_list
        if self.invalid_device_secret_list is not None:
            result['InvalidDeviceSecretList'] = self.invalid_device_secret_list
        if self.invalid_sn_list is not None:
            result['InvalidSnList'] = self.invalid_sn_list
        if self.repeated_device_name_list is not None:
            result['RepeatedDeviceNameList'] = self.repeated_device_name_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.invalid_detail_list = []
        if m.get('InvalidDetailList') is not None:
            for k in m.get('InvalidDetailList'):
                temp_model = BatchCheckImportDeviceResponseBodyDataInvalidDetailList()
                self.invalid_detail_list.append(temp_model.from_map(k))
        if m.get('InvalidDeviceNameList') is not None:
            self.invalid_device_name_list = m.get('InvalidDeviceNameList')
        if m.get('InvalidDeviceSecretList') is not None:
            self.invalid_device_secret_list = m.get('InvalidDeviceSecretList')
        if m.get('InvalidSnList') is not None:
            self.invalid_sn_list = m.get('InvalidSnList')
        if m.get('RepeatedDeviceNameList') is not None:
            self.repeated_device_name_list = m.get('RepeatedDeviceNameList')
        return self


class BatchCheckImportDeviceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: BatchCheckImportDeviceResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The data returned if the request succeeds. The data includes the information about devices that failed to be verified.
        self.data = data
        # The error message returned if the request fails.
        self.error_message = error_message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = BatchCheckImportDeviceResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class BatchCheckImportDeviceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BatchCheckImportDeviceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchCheckImportDeviceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchCheckVehicleDeviceRequestDeviceList(TeaModel):
    def __init__(
        self,
        device_id: str = None,
        device_model: str = None,
        device_name: str = None,
        device_secret: str = None,
        manufacturer: str = None,
    ):
        self.device_id = device_id
        self.device_model = device_model
        self.device_name = device_name
        self.device_secret = device_secret
        self.manufacturer = manufacturer

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.device_model is not None:
            result['DeviceModel'] = self.device_model
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.device_secret is not None:
            result['DeviceSecret'] = self.device_secret
        if self.manufacturer is not None:
            result['Manufacturer'] = self.manufacturer
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('DeviceModel') is not None:
            self.device_model = m.get('DeviceModel')
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('DeviceSecret') is not None:
            self.device_secret = m.get('DeviceSecret')
        if m.get('Manufacturer') is not None:
            self.manufacturer = m.get('Manufacturer')
        return self


class BatchCheckVehicleDeviceRequest(TeaModel):
    def __init__(
        self,
        device_list: List[BatchCheckVehicleDeviceRequestDeviceList] = None,
        iot_instance_id: str = None,
        product_key: str = None,
    ):
        self.device_list = device_list
        # BatchCheckVehicleDevice
        self.iot_instance_id = iot_instance_id
        self.product_key = product_key

    def validate(self):
        if self.device_list:
            for k in self.device_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DeviceList'] = []
        if self.device_list is not None:
            for k in self.device_list:
                result['DeviceList'].append(k.to_map() if k else None)
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.device_list = []
        if m.get('DeviceList') is not None:
            for k in m.get('DeviceList'):
                temp_model = BatchCheckVehicleDeviceRequestDeviceList()
                self.device_list.append(temp_model.from_map(k))
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class BatchCheckVehicleDeviceResponseBodyDataInvalidDetailList(TeaModel):
    def __init__(
        self,
        device_id: str = None,
        device_model: str = None,
        device_name: str = None,
        error_msg: str = None,
        manufacturer: str = None,
    ):
        self.device_id = device_id
        self.device_model = device_model
        self.device_name = device_name
        self.error_msg = error_msg
        self.manufacturer = manufacturer

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.device_model is not None:
            result['DeviceModel'] = self.device_model
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.error_msg is not None:
            result['ErrorMsg'] = self.error_msg
        if self.manufacturer is not None:
            result['Manufacturer'] = self.manufacturer
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('DeviceModel') is not None:
            self.device_model = m.get('DeviceModel')
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('ErrorMsg') is not None:
            self.error_msg = m.get('ErrorMsg')
        if m.get('Manufacturer') is not None:
            self.manufacturer = m.get('Manufacturer')
        return self


class BatchCheckVehicleDeviceResponseBodyData(TeaModel):
    def __init__(
        self,
        invalid_detail_list: List[BatchCheckVehicleDeviceResponseBodyDataInvalidDetailList] = None,
        invalid_device_id_list: List[str] = None,
        invalid_device_model_list: List[str] = None,
        invalid_device_name_list: List[str] = None,
        invalid_manufacturer_list: List[str] = None,
        repeated_device_id_list: List[str] = None,
        repeated_device_name_list: List[str] = None,
    ):
        self.invalid_detail_list = invalid_detail_list
        self.invalid_device_id_list = invalid_device_id_list
        self.invalid_device_model_list = invalid_device_model_list
        self.invalid_device_name_list = invalid_device_name_list
        self.invalid_manufacturer_list = invalid_manufacturer_list
        self.repeated_device_id_list = repeated_device_id_list
        self.repeated_device_name_list = repeated_device_name_list

    def validate(self):
        if self.invalid_detail_list:
            for k in self.invalid_detail_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InvalidDetailList'] = []
        if self.invalid_detail_list is not None:
            for k in self.invalid_detail_list:
                result['InvalidDetailList'].append(k.to_map() if k else None)
        if self.invalid_device_id_list is not None:
            result['InvalidDeviceIdList'] = self.invalid_device_id_list
        if self.invalid_device_model_list is not None:
            result['InvalidDeviceModelList'] = self.invalid_device_model_list
        if self.invalid_device_name_list is not None:
            result['InvalidDeviceNameList'] = self.invalid_device_name_list
        if self.invalid_manufacturer_list is not None:
            result['InvalidManufacturerList'] = self.invalid_manufacturer_list
        if self.repeated_device_id_list is not None:
            result['RepeatedDeviceIdList'] = self.repeated_device_id_list
        if self.repeated_device_name_list is not None:
            result['RepeatedDeviceNameList'] = self.repeated_device_name_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.invalid_detail_list = []
        if m.get('InvalidDetailList') is not None:
            for k in m.get('InvalidDetailList'):
                temp_model = BatchCheckVehicleDeviceResponseBodyDataInvalidDetailList()
                self.invalid_detail_list.append(temp_model.from_map(k))
        if m.get('InvalidDeviceIdList') is not None:
            self.invalid_device_id_list = m.get('InvalidDeviceIdList')
        if m.get('InvalidDeviceModelList') is not None:
            self.invalid_device_model_list = m.get('InvalidDeviceModelList')
        if m.get('InvalidDeviceNameList') is not None:
            self.invalid_device_name_list = m.get('InvalidDeviceNameList')
        if m.get('InvalidManufacturerList') is not None:
            self.invalid_manufacturer_list = m.get('InvalidManufacturerList')
        if m.get('RepeatedDeviceIdList') is not None:
            self.repeated_device_id_list = m.get('RepeatedDeviceIdList')
        if m.get('RepeatedDeviceNameList') is not None:
            self.repeated_device_name_list = m.get('RepeatedDeviceNameList')
        return self


class BatchCheckVehicleDeviceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: BatchCheckVehicleDeviceResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = BatchCheckVehicleDeviceResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class BatchCheckVehicleDeviceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BatchCheckVehicleDeviceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchCheckVehicleDeviceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchClearEdgeInstanceDeviceConfigRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        iot_ids: List[str] = None,
        iot_instance_id: str = None,
    ):
        # The ID of the edge instance. To obtain the instance ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Edge Instances** page, move the pointer over the name of the edge instance that you want to manage and obtain the instance ID.
        # 
        # You can also call the [QueryEdgeInstance](~~135214~~) operation to query the instance ID.
        self.instance_id = instance_id
        self.iot_ids = iot_ids
        # The ID of the Internet of Things (IoT) service instance. This parameter is not required for the public instance but required for Enterprise Edition instances.
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.iot_ids is not None:
            result['IotIds'] = self.iot_ids
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IotIds') is not None:
            self.iot_ids = m.get('IotIds')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class BatchClearEdgeInstanceDeviceConfigResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The return code of the operation. A value of Success indicates that the call was successful. Other values indicate that specific errors occurred. For more information, see [Error codes](~~135200~~).
        self.code = code
        # The error message that is returned if the call failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful. A value of true indicates that the call was successful. A value of false indicates that the call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class BatchClearEdgeInstanceDeviceConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BatchClearEdgeInstanceDeviceConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchClearEdgeInstanceDeviceConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchCreateSoundCodeLabelRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        iot_instance_id: str = None,
        schedule_code: str = None,
        total: int = None,
    ):
        self.description = description
        self.iot_instance_id = iot_instance_id
        self.schedule_code = schedule_code
        self.total = total

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.schedule_code is not None:
            result['ScheduleCode'] = self.schedule_code
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ScheduleCode') is not None:
            self.schedule_code = m.get('ScheduleCode')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class BatchCreateSoundCodeLabelResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class BatchCreateSoundCodeLabelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BatchCreateSoundCodeLabelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchCreateSoundCodeLabelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchCreateSoundCodeLabelWithLabelsRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        iot_instance_id: str = None,
        labels: List[str] = None,
        schedule_code: str = None,
    ):
        self.description = description
        self.iot_instance_id = iot_instance_id
        self.labels = labels
        self.schedule_code = schedule_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.labels is not None:
            result['Labels'] = self.labels
        if self.schedule_code is not None:
            result['ScheduleCode'] = self.schedule_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('Labels') is not None:
            self.labels = m.get('Labels')
        if m.get('ScheduleCode') is not None:
            self.schedule_code = m.get('ScheduleCode')
        return self


class BatchCreateSoundCodeLabelWithLabelsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class BatchCreateSoundCodeLabelWithLabelsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BatchCreateSoundCodeLabelWithLabelsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchCreateSoundCodeLabelWithLabelsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchDeleteDeviceGroupRelationsRequestDevice(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        product_key: str = None,
    ):
        # The names of the devices to be removed. You can specify a maximum of 200 devices.
        self.device_name = device_name
        # The ProductKeys of the products to which the devices belong. You can specify a maximum of 200 ProductKeys.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class BatchDeleteDeviceGroupRelationsRequest(TeaModel):
    def __init__(
        self,
        device: List[BatchDeleteDeviceGroupRelationsRequestDevice] = None,
        group_id: str = None,
        iot_instance_id: str = None,
    ):
        self.device = device
        # The ID of the group. The ID is the globally unique identifier (GUID) for the group.
        self.group_id = group_id
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id

    def validate(self):
        if self.device:
            for k in self.device:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Device'] = []
        if self.device is not None:
            for k in self.device:
                result['Device'].append(k.to_map() if k else None)
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.device = []
        if m.get('Device') is not None:
            for k in m.get('Device'):
                temp_model = BatchDeleteDeviceGroupRelationsRequestDevice()
                self.device.append(temp_model.from_map(k))
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class BatchDeleteDeviceGroupRelationsResponseBody(TeaModel):
    def __init__(
        self,
        already_related_group_device_count: int = None,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        success_device_count: int = None,
        valid_device_count: int = None,
    ):
        # The number of devices that exist in the group.
        self.already_related_group_device_count = already_related_group_device_count
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success
        # The number of devices that are removed from the group.
        self.success_device_count = success_device_count
        # The number of valid devices that you specified.
        self.valid_device_count = valid_device_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.already_related_group_device_count is not None:
            result['AlreadyRelatedGroupDeviceCount'] = self.already_related_group_device_count
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.success_device_count is not None:
            result['SuccessDeviceCount'] = self.success_device_count
        if self.valid_device_count is not None:
            result['ValidDeviceCount'] = self.valid_device_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlreadyRelatedGroupDeviceCount') is not None:
            self.already_related_group_device_count = m.get('AlreadyRelatedGroupDeviceCount')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('SuccessDeviceCount') is not None:
            self.success_device_count = m.get('SuccessDeviceCount')
        if m.get('ValidDeviceCount') is not None:
            self.valid_device_count = m.get('ValidDeviceCount')
        return self


class BatchDeleteDeviceGroupRelationsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BatchDeleteDeviceGroupRelationsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchDeleteDeviceGroupRelationsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchDeleteEdgeInstanceChannelRequest(TeaModel):
    def __init__(
        self,
        channel_ids: List[str] = None,
        driver_id: str = None,
        instance_id: str = None,
        iot_instance_id: str = None,
    ):
        self.channel_ids = channel_ids
        self.driver_id = driver_id
        self.instance_id = instance_id
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_ids is not None:
            result['ChannelIds'] = self.channel_ids
        if self.driver_id is not None:
            result['DriverId'] = self.driver_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelIds') is not None:
            self.channel_ids = m.get('ChannelIds')
        if m.get('DriverId') is not None:
            self.driver_id = m.get('DriverId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class BatchDeleteEdgeInstanceChannelResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class BatchDeleteEdgeInstanceChannelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BatchDeleteEdgeInstanceChannelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchDeleteEdgeInstanceChannelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchGetDeviceBindStatusRequest(TeaModel):
    def __init__(
        self,
        iot_ids: List[str] = None,
        iot_instance_id: str = None,
    ):
        self.iot_ids = iot_ids
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_ids is not None:
            result['IotIds'] = self.iot_ids
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotIds') is not None:
            self.iot_ids = m.get('IotIds')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class BatchGetDeviceBindStatusResponseBodyData(TeaModel):
    def __init__(
        self,
        bind_status: int = None,
        instance_id: str = None,
        iot_id: str = None,
    ):
        self.bind_status = bind_status
        # 实例ID。
        self.instance_id = instance_id
        self.iot_id = iot_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bind_status is not None:
            result['BindStatus'] = self.bind_status
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BindStatus') is not None:
            self.bind_status = m.get('BindStatus')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        return self


class BatchGetDeviceBindStatusResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[BatchGetDeviceBindStatusResponseBodyData] = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = BatchGetDeviceBindStatusResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class BatchGetDeviceBindStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BatchGetDeviceBindStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchGetDeviceBindStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchGetDeviceStateRequest(TeaModel):
    def __init__(
        self,
        device_name: List[str] = None,
        iot_id: List[str] = None,
        iot_instance_id: str = None,
        product_key: str = None,
    ):
        self.device_name = device_name
        self.iot_id = iot_id
        # The ID of the instance. You can view the ID of the instance on the **Overview** page in the IoT Platform console.
        # 
        # 
        # >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.
        # >*   If no **Overview** page or **ID** is generated for your instance, you do not need to configure this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The ProductKey of the product to which the device belongs.
        # 
        # 
        # > If you configure this parameter, you must also specify a value for the **DeviceName** parameter.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class BatchGetDeviceStateResponseBodyDeviceStatusListDeviceStatus(TeaModel):
    def __init__(
        self,
        as_address: str = None,
        device_id: str = None,
        device_name: str = None,
        iot_id: str = None,
        last_online_time: str = None,
        status: str = None,
        timestamp: int = None,
    ):
        # The IP address of the device.
        self.as_address = as_address
        # The ID of the device (expired).
        # 
        # >  This parameter is no longer supported. Do not use this parameter to identify a device. You can use the value of the **IotId**** parameter or a combination of the values of the ****ProductKey** and DeviceName parameters to identify a device.
        self.device_id = device_id
        # The DeviceName of the device.
        self.device_name = device_name
        # The ID of the device. The ID is the unique identifier that is issued by IoT Platform to the device.
        self.iot_id = iot_id
        # The last time when the device was online.
        self.last_online_time = last_online_time
        # The status of the device. Valid values: Valid values:
        # 
        # *   **ONLINE**: The device is online.
        # *   **OFFLINE**: The device is offline.
        # *   **UNACTIVE**: The device is not activated.
        # *   **DISABLE**: The device is disabled.
        self.status = status
        self.timestamp = timestamp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.as_address is not None:
            result['AsAddress'] = self.as_address
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.last_online_time is not None:
            result['LastOnlineTime'] = self.last_online_time
        if self.status is not None:
            result['Status'] = self.status
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AsAddress') is not None:
            self.as_address = m.get('AsAddress')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('LastOnlineTime') is not None:
            self.last_online_time = m.get('LastOnlineTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        return self


class BatchGetDeviceStateResponseBodyDeviceStatusList(TeaModel):
    def __init__(
        self,
        device_status: List[BatchGetDeviceStateResponseBodyDeviceStatusListDeviceStatus] = None,
    ):
        self.device_status = device_status

    def validate(self):
        if self.device_status:
            for k in self.device_status:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DeviceStatus'] = []
        if self.device_status is not None:
            for k in self.device_status:
                result['DeviceStatus'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.device_status = []
        if m.get('DeviceStatus') is not None:
            for k in m.get('DeviceStatus'):
                temp_model = BatchGetDeviceStateResponseBodyDeviceStatusListDeviceStatus()
                self.device_status.append(temp_model.from_map(k))
        return self


class BatchGetDeviceStateResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        device_status_list: BatchGetDeviceStateResponseBodyDeviceStatusList = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The device status information returned if the call is successful. For more information, see the following parameters that are included in the DeviceStatus parameter.
        self.device_status_list = device_status_list
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful. Valid values:
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.device_status_list:
            self.device_status_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.device_status_list is not None:
            result['DeviceStatusList'] = self.device_status_list.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('DeviceStatusList') is not None:
            temp_model = BatchGetDeviceStateResponseBodyDeviceStatusList()
            self.device_status_list = temp_model.from_map(m['DeviceStatusList'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class BatchGetDeviceStateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BatchGetDeviceStateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchGetDeviceStateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchGetEdgeDriverRequest(TeaModel):
    def __init__(
        self,
        driver_ids: List[str] = None,
        iot_instance_id: str = None,
    ):
        self.driver_ids = driver_ids
        # The ID of the Internet of Things (IoT) service instance. This parameter is not required for public instances. However, this parameter is required for the instances that you have purchased.
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.driver_ids is not None:
            result['DriverIds'] = self.driver_ids
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DriverIds') is not None:
            self.driver_ids = m.get('DriverIds')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class BatchGetEdgeDriverResponseBodyDriverList(TeaModel):
    def __init__(
        self,
        cpu_arch: str = None,
        driver_id: str = None,
        driver_name: str = None,
        driver_protocol: str = None,
        gmt_create_timestamp: int = None,
        gmt_modified_timestamp: int = None,
        is_built_in: bool = None,
        runtime: str = None,
        type: int = None,
    ):
        # The CPU architecture that the driver supports. Valid values:
        # 
        # *   ARMv7
        # *   ARMv7-HF
        # *   AArch64
        # *   x86-64
        # *   x86
        self.cpu_arch = cpu_arch
        # The ID of the driver.
        self.driver_id = driver_id
        # The name of the driver.
        self.driver_name = driver_name
        # The communications protocol that the driver uses. Valid values:
        # 
        # *   modbus: Modbus protocol
        # *   opc-ua: OPC UA protocol
        # *   customize: custom protocol
        self.driver_protocol = driver_protocol
        # The time when the driver was created. The time is displayed in UTC.
        self.gmt_create_timestamp = gmt_create_timestamp
        # The time when the driver was last modified. The time is displayed in UTC.
        self.gmt_modified_timestamp = gmt_modified_timestamp
        # Indicates whether the driver is a built-in driver.
        # 
        # *   true: indicates that the driver is a built-in driver, that is, the driver code is pre-configured on the gateway device.
        # *   false: indicates that the driver is not a built-in driver.
        self.is_built_in = is_built_in
        # The language in which the driver is programmed. Valid values:
        # 
        # *   nodejs8: Node.js v8
        # *   python3: Python v3.5
        # *   c: C
        self.runtime = runtime
        # The type of the driver. Valid values:
        # 
        # *   0: official driver
        # *   1: custom driver
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cpu_arch is not None:
            result['CpuArch'] = self.cpu_arch
        if self.driver_id is not None:
            result['DriverId'] = self.driver_id
        if self.driver_name is not None:
            result['DriverName'] = self.driver_name
        if self.driver_protocol is not None:
            result['DriverProtocol'] = self.driver_protocol
        if self.gmt_create_timestamp is not None:
            result['GmtCreateTimestamp'] = self.gmt_create_timestamp
        if self.gmt_modified_timestamp is not None:
            result['GmtModifiedTimestamp'] = self.gmt_modified_timestamp
        if self.is_built_in is not None:
            result['IsBuiltIn'] = self.is_built_in
        if self.runtime is not None:
            result['Runtime'] = self.runtime
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CpuArch') is not None:
            self.cpu_arch = m.get('CpuArch')
        if m.get('DriverId') is not None:
            self.driver_id = m.get('DriverId')
        if m.get('DriverName') is not None:
            self.driver_name = m.get('DriverName')
        if m.get('DriverProtocol') is not None:
            self.driver_protocol = m.get('DriverProtocol')
        if m.get('GmtCreateTimestamp') is not None:
            self.gmt_create_timestamp = m.get('GmtCreateTimestamp')
        if m.get('GmtModifiedTimestamp') is not None:
            self.gmt_modified_timestamp = m.get('GmtModifiedTimestamp')
        if m.get('IsBuiltIn') is not None:
            self.is_built_in = m.get('IsBuiltIn')
        if m.get('Runtime') is not None:
            self.runtime = m.get('Runtime')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class BatchGetEdgeDriverResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        driver_list: List[BatchGetEdgeDriverResponseBodyDriverList] = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code. Success indicates that the call was successful. Other values indicate that specific errors occurred. For more information, see [Error codes](~~135200~~).
        self.code = code
        # The information about each driver.
        self.driver_list = driver_list
        # The error message returned if the call failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful. true indicates that the call was successful. false indicates that the call failed.
        self.success = success

    def validate(self):
        if self.driver_list:
            for k in self.driver_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['DriverList'] = []
        if self.driver_list is not None:
            for k in self.driver_list:
                result['DriverList'].append(k.to_map() if k else None)
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.driver_list = []
        if m.get('DriverList') is not None:
            for k in m.get('DriverList'):
                temp_model = BatchGetEdgeDriverResponseBodyDriverList()
                self.driver_list.append(temp_model.from_map(k))
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class BatchGetEdgeDriverResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BatchGetEdgeDriverResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchGetEdgeDriverResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchGetEdgeInstanceChannelRequest(TeaModel):
    def __init__(
        self,
        channel_ids: List[str] = None,
        driver_id: str = None,
        instance_id: str = None,
        iot_instance_id: str = None,
    ):
        self.channel_ids = channel_ids
        self.driver_id = driver_id
        self.instance_id = instance_id
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_ids is not None:
            result['ChannelIds'] = self.channel_ids
        if self.driver_id is not None:
            result['DriverId'] = self.driver_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelIds') is not None:
            self.channel_ids = m.get('ChannelIds')
        if m.get('DriverId') is not None:
            self.driver_id = m.get('DriverId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigListConfig(TeaModel):
    def __init__(
        self,
        config_id: str = None,
        content: str = None,
        format: str = None,
        key: str = None,
    ):
        self.config_id = config_id
        self.content = content
        self.format = format
        self.key = key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config_id is not None:
            result['ConfigId'] = self.config_id
        if self.content is not None:
            result['Content'] = self.content
        if self.format is not None:
            result['Format'] = self.format
        if self.key is not None:
            result['Key'] = self.key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConfigId') is not None:
            self.config_id = m.get('ConfigId')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('Format') is not None:
            self.format = m.get('Format')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        return self


class BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigList(TeaModel):
    def __init__(
        self,
        config: List[BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigListConfig] = None,
    ):
        self.config = config

    def validate(self):
        if self.config:
            for k in self.config:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Config'] = []
        if self.config is not None:
            for k in self.config:
                result['Config'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.config = []
        if m.get('Config') is not None:
            for k in m.get('Config'):
                temp_model = BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigListConfig()
                self.config.append(temp_model.from_map(k))
        return self


class BatchGetEdgeInstanceChannelResponseBodyDataChannel(TeaModel):
    def __init__(
        self,
        channel_id: str = None,
        channel_name: str = None,
        config_list: BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigList = None,
    ):
        self.channel_id = channel_id
        self.channel_name = channel_name
        self.config_list = config_list

    def validate(self):
        if self.config_list:
            self.config_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.channel_name is not None:
            result['ChannelName'] = self.channel_name
        if self.config_list is not None:
            result['ConfigList'] = self.config_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('ChannelName') is not None:
            self.channel_name = m.get('ChannelName')
        if m.get('ConfigList') is not None:
            temp_model = BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigList()
            self.config_list = temp_model.from_map(m['ConfigList'])
        return self


class BatchGetEdgeInstanceChannelResponseBodyData(TeaModel):
    def __init__(
        self,
        channel: List[BatchGetEdgeInstanceChannelResponseBodyDataChannel] = None,
    ):
        self.channel = channel

    def validate(self):
        if self.channel:
            for k in self.channel:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Channel'] = []
        if self.channel is not None:
            for k in self.channel:
                result['Channel'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.channel = []
        if m.get('Channel') is not None:
            for k in m.get('Channel'):
                temp_model = BatchGetEdgeInstanceChannelResponseBodyDataChannel()
                self.channel.append(temp_model.from_map(k))
        return self


class BatchGetEdgeInstanceChannelResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: BatchGetEdgeInstanceChannelResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = BatchGetEdgeInstanceChannelResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class BatchGetEdgeInstanceChannelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BatchGetEdgeInstanceChannelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchGetEdgeInstanceChannelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchGetEdgeInstanceDeviceChannelRequest(TeaModel):
    def __init__(
        self,
        driver_id: str = None,
        instance_id: str = None,
        iot_ids: List[str] = None,
        iot_instance_id: str = None,
    ):
        self.driver_id = driver_id
        self.instance_id = instance_id
        self.iot_ids = iot_ids
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.driver_id is not None:
            result['DriverId'] = self.driver_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.iot_ids is not None:
            result['IotIds'] = self.iot_ids
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DriverId') is not None:
            self.driver_id = m.get('DriverId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IotIds') is not None:
            self.iot_ids = m.get('IotIds')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class BatchGetEdgeInstanceDeviceChannelResponseBodyDeviceChannelList(TeaModel):
    def __init__(
        self,
        channel_id: str = None,
        channel_name: str = None,
        iot_id: str = None,
    ):
        self.channel_id = channel_id
        self.channel_name = channel_name
        self.iot_id = iot_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.channel_name is not None:
            result['ChannelName'] = self.channel_name
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('ChannelName') is not None:
            self.channel_name = m.get('ChannelName')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        return self


class BatchGetEdgeInstanceDeviceChannelResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        device_channel_list: List[BatchGetEdgeInstanceDeviceChannelResponseBodyDeviceChannelList] = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.device_channel_list = device_channel_list
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.device_channel_list:
            for k in self.device_channel_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['DeviceChannelList'] = []
        if self.device_channel_list is not None:
            for k in self.device_channel_list:
                result['DeviceChannelList'].append(k.to_map() if k else None)
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.device_channel_list = []
        if m.get('DeviceChannelList') is not None:
            for k in m.get('DeviceChannelList'):
                temp_model = BatchGetEdgeInstanceDeviceChannelResponseBodyDeviceChannelList()
                self.device_channel_list.append(temp_model.from_map(k))
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class BatchGetEdgeInstanceDeviceChannelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BatchGetEdgeInstanceDeviceChannelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchGetEdgeInstanceDeviceChannelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchGetEdgeInstanceDeviceConfigRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        iot_ids: List[str] = None,
        iot_instance_id: str = None,
    ):
        # The ID of the edge instance. To obtain the instance ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Edge Instances** page, move the pointer over the name of the edge instance that you want to query and obtain the instance ID.
        # 
        # You can also call the [QueryEdgeInstance](~~135214~~) operation to query the instance ID.
        self.instance_id = instance_id
        self.iot_ids = iot_ids
        # The ID of the Internet of Things (IoT) service instance. This parameter is not required for the public instance but required for Enterprise Edition instances.
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.iot_ids is not None:
            result['IotIds'] = self.iot_ids
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IotIds') is not None:
            self.iot_ids = m.get('IotIds')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigListConfig(TeaModel):
    def __init__(
        self,
        content: str = None,
        format: str = None,
    ):
        # The configuration content or the Object Storage Service (OSS) path of the configuration file.
        self.content = content
        # The format of the configuration. Valid values: KV (key-value pair), JSON (JSON string), and FILE (configuration file).
        self.format = format

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.format is not None:
            result['Format'] = self.format
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('Format') is not None:
            self.format = m.get('Format')
        return self


class BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigList(TeaModel):
    def __init__(
        self,
        config: BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigListConfig = None,
        iot_id: str = None,
    ):
        # The configuration information of the device.
        self.config = config
        # The ID of the device.
        self.iot_id = iot_id

    def validate(self):
        if self.config:
            self.config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config.to_map()
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Config') is not None:
            temp_model = BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigListConfig()
            self.config = temp_model.from_map(m['Config'])
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        return self


class BatchGetEdgeInstanceDeviceConfigResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        device_config_list: List[BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigList] = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The return code of the operation. A value of Success indicates that the call was successful. Other values indicate that specific errors occurred. For more information, see [Error codes](~~135200~~).
        self.code = code
        # The device configuration information that is returned if the call was successful.
        self.device_config_list = device_config_list
        # The error message that is returned if the call failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful. A value of true indicates that the call was successful. A value of false indicates that the call failed.
        self.success = success

    def validate(self):
        if self.device_config_list:
            for k in self.device_config_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['DeviceConfigList'] = []
        if self.device_config_list is not None:
            for k in self.device_config_list:
                result['DeviceConfigList'].append(k.to_map() if k else None)
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.device_config_list = []
        if m.get('DeviceConfigList') is not None:
            for k in m.get('DeviceConfigList'):
                temp_model = BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigList()
                self.device_config_list.append(temp_model.from_map(k))
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class BatchGetEdgeInstanceDeviceConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BatchGetEdgeInstanceDeviceConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchGetEdgeInstanceDeviceConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchGetEdgeInstanceDeviceDriverRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        iot_ids: List[str] = None,
        iot_instance_id: str = None,
    ):
        self.instance_id = instance_id
        self.iot_ids = iot_ids
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.iot_ids is not None:
            result['IotIds'] = self.iot_ids
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IotIds') is not None:
            self.iot_ids = m.get('IotIds')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class BatchGetEdgeInstanceDeviceDriverResponseBodyDeviceDriverList(TeaModel):
    def __init__(
        self,
        driver_id: str = None,
        iot_id: str = None,
    ):
        self.driver_id = driver_id
        self.iot_id = iot_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.driver_id is not None:
            result['DriverId'] = self.driver_id
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DriverId') is not None:
            self.driver_id = m.get('DriverId')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        return self


class BatchGetEdgeInstanceDeviceDriverResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        device_driver_list: List[BatchGetEdgeInstanceDeviceDriverResponseBodyDeviceDriverList] = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.device_driver_list = device_driver_list
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.device_driver_list:
            for k in self.device_driver_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['DeviceDriverList'] = []
        if self.device_driver_list is not None:
            for k in self.device_driver_list:
                result['DeviceDriverList'].append(k.to_map() if k else None)
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.device_driver_list = []
        if m.get('DeviceDriverList') is not None:
            for k in m.get('DeviceDriverList'):
                temp_model = BatchGetEdgeInstanceDeviceDriverResponseBodyDeviceDriverList()
                self.device_driver_list.append(temp_model.from_map(k))
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class BatchGetEdgeInstanceDeviceDriverResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BatchGetEdgeInstanceDeviceDriverResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchGetEdgeInstanceDeviceDriverResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchGetEdgeInstanceDriverConfigsRequest(TeaModel):
    def __init__(
        self,
        driver_ids: List[str] = None,
        instance_id: str = None,
        iot_instance_id: str = None,
    ):
        self.driver_ids = driver_ids
        # The ID of the edge instance. To obtain the instance ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Edge Instances** page, move the pointer over the name of the edge instance that uses the drivers and obtain the instance ID.
        # 
        # You can also call the [QueryEdgeInstance](~~135214~~) operation to query the instance ID.
        self.instance_id = instance_id
        # The ID of the Internet of Things (IoT) service instance. This parameter is not required for the public instance but required for Enterprise Edition instances.
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.driver_ids is not None:
            result['DriverIds'] = self.driver_ids
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DriverIds') is not None:
            self.driver_ids = m.get('DriverIds')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigListConfigList(TeaModel):
    def __init__(
        self,
        config_id: str = None,
        content: str = None,
        format: str = None,
        key: str = None,
    ):
        # The ID of the configuration.
        self.config_id = config_id
        # The configuration content or the Object Storage Service (OSS) path of the configuration file.
        self.content = content
        # The format of the configuration. Valid values: KV (key-value pair), JSON (JSON string), and FILE (configuration file).
        self.format = format
        # The key of the configuration. If multiple configurations are available, keywords can be used to identify the configurations.
        self.key = key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config_id is not None:
            result['ConfigId'] = self.config_id
        if self.content is not None:
            result['Content'] = self.content
        if self.format is not None:
            result['Format'] = self.format
        if self.key is not None:
            result['Key'] = self.key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConfigId') is not None:
            self.config_id = m.get('ConfigId')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('Format') is not None:
            self.format = m.get('Format')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        return self


class BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigList(TeaModel):
    def __init__(
        self,
        config_list: List[BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigListConfigList] = None,
        driver_id: str = None,
    ):
        # The configuration information of the driver.
        self.config_list = config_list
        # The ID of the driver.
        self.driver_id = driver_id

    def validate(self):
        if self.config_list:
            for k in self.config_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ConfigList'] = []
        if self.config_list is not None:
            for k in self.config_list:
                result['ConfigList'].append(k.to_map() if k else None)
        if self.driver_id is not None:
            result['DriverId'] = self.driver_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.config_list = []
        if m.get('ConfigList') is not None:
            for k in m.get('ConfigList'):
                temp_model = BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigListConfigList()
                self.config_list.append(temp_model.from_map(k))
        if m.get('DriverId') is not None:
            self.driver_id = m.get('DriverId')
        return self


class BatchGetEdgeInstanceDriverConfigsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        driver_config_list: List[BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigList] = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The return code of the operation. A value of Success indicates that the call was successful. Other values indicate that specific errors occurred. For more information, see [Error codes](~~135200~~).
        self.code = code
        # The data that is returned if the call was successful.
        self.driver_config_list = driver_config_list
        # The error message that is returned if the call failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful. A value of true indicates that the call was successful. A value of false indicates that the call failed.
        self.success = success

    def validate(self):
        if self.driver_config_list:
            for k in self.driver_config_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['DriverConfigList'] = []
        if self.driver_config_list is not None:
            for k in self.driver_config_list:
                result['DriverConfigList'].append(k.to_map() if k else None)
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.driver_config_list = []
        if m.get('DriverConfigList') is not None:
            for k in m.get('DriverConfigList'):
                temp_model = BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigList()
                self.driver_config_list.append(temp_model.from_map(k))
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class BatchGetEdgeInstanceDriverConfigsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BatchGetEdgeInstanceDriverConfigsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchGetEdgeInstanceDriverConfigsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchGrayMigrationDeviceRequest(TeaModel):
    def __init__(
        self,
        device_names: List[str] = None,
        product_key: str = None,
    ):
        self.device_names = device_names
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_names is not None:
            result['DeviceNames'] = self.device_names
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceNames') is not None:
            self.device_names = m.get('DeviceNames')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class BatchGrayMigrationDeviceResponseBodyDataDetailsItem(TeaModel):
    def __init__(
        self,
        code: int = None,
        device_name: str = None,
        message: str = None,
        status: str = None,
    ):
        self.code = code
        self.device_name = device_name
        self.message = message
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.message is not None:
            result['Message'] = self.message
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class BatchGrayMigrationDeviceResponseBodyDataDetails(TeaModel):
    def __init__(
        self,
        item: List[BatchGrayMigrationDeviceResponseBodyDataDetailsItem] = None,
    ):
        self.item = item

    def validate(self):
        if self.item:
            for k in self.item:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['item'] = []
        if self.item is not None:
            for k in self.item:
                result['item'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.item = []
        if m.get('item') is not None:
            for k in m.get('item'):
                temp_model = BatchGrayMigrationDeviceResponseBodyDataDetailsItem()
                self.item.append(temp_model.from_map(k))
        return self


class BatchGrayMigrationDeviceResponseBodyData(TeaModel):
    def __init__(
        self,
        details: BatchGrayMigrationDeviceResponseBodyDataDetails = None,
    ):
        self.details = details

    def validate(self):
        if self.details:
            self.details.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.details is not None:
            result['Details'] = self.details.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Details') is not None:
            temp_model = BatchGrayMigrationDeviceResponseBodyDataDetails()
            self.details = temp_model.from_map(m['Details'])
        return self


class BatchGrayMigrationDeviceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: BatchGrayMigrationDeviceResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = BatchGrayMigrationDeviceResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class BatchGrayMigrationDeviceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BatchGrayMigrationDeviceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchGrayMigrationDeviceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchImportDeviceRequestDeviceList(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        device_secret: str = None,
        sn: str = None,
    ):
        self.device_name = device_name
        self.device_secret = device_secret
        self.sn = sn

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.device_secret is not None:
            result['DeviceSecret'] = self.device_secret
        if self.sn is not None:
            result['Sn'] = self.sn
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('DeviceSecret') is not None:
            self.device_secret = m.get('DeviceSecret')
        if m.get('Sn') is not None:
            self.sn = m.get('Sn')
        return self


class BatchImportDeviceRequest(TeaModel):
    def __init__(
        self,
        device_list: List[BatchImportDeviceRequestDeviceList] = None,
        iot_instance_id: str = None,
        product_key: str = None,
    ):
        self.device_list = device_list
        # The instance ID. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
        # 
        # >  If your instance has an ID, you must specify this parameter. Otherwise, the request fails. If no Overview page exists or no instance ID is displayed, you do not need to specify this parameter.
        # 
        # For more information, see the [Overview](~~356505~~) topic of IoT instances.
        self.iot_instance_id = iot_instance_id
        # The **ProductKey** of the gateway product to which the devices belong.
        self.product_key = product_key

    def validate(self):
        if self.device_list:
            for k in self.device_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DeviceList'] = []
        if self.device_list is not None:
            for k in self.device_list:
                result['DeviceList'].append(k.to_map() if k else None)
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.device_list = []
        if m.get('DeviceList') is not None:
            for k in m.get('DeviceList'):
                temp_model = BatchImportDeviceRequestDeviceList()
                self.device_list.append(temp_model.from_map(k))
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class BatchImportDeviceResponseBodyDataInvalidDetailListInvalidDetailList(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        device_secret: str = None,
        error_msg: str = None,
        sn: str = None,
    ):
        self.device_name = device_name
        self.device_secret = device_secret
        self.error_msg = error_msg
        self.sn = sn

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.device_secret is not None:
            result['DeviceSecret'] = self.device_secret
        if self.error_msg is not None:
            result['ErrorMsg'] = self.error_msg
        if self.sn is not None:
            result['Sn'] = self.sn
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('DeviceSecret') is not None:
            self.device_secret = m.get('DeviceSecret')
        if m.get('ErrorMsg') is not None:
            self.error_msg = m.get('ErrorMsg')
        if m.get('Sn') is not None:
            self.sn = m.get('Sn')
        return self


class BatchImportDeviceResponseBodyDataInvalidDetailList(TeaModel):
    def __init__(
        self,
        invalid_detail_list: List[BatchImportDeviceResponseBodyDataInvalidDetailListInvalidDetailList] = None,
    ):
        self.invalid_detail_list = invalid_detail_list

    def validate(self):
        if self.invalid_detail_list:
            for k in self.invalid_detail_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InvalidDetailList'] = []
        if self.invalid_detail_list is not None:
            for k in self.invalid_detail_list:
                result['InvalidDetailList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.invalid_detail_list = []
        if m.get('InvalidDetailList') is not None:
            for k in m.get('InvalidDetailList'):
                temp_model = BatchImportDeviceResponseBodyDataInvalidDetailListInvalidDetailList()
                self.invalid_detail_list.append(temp_model.from_map(k))
        return self


class BatchImportDeviceResponseBodyDataInvalidDeviceNameList(TeaModel):
    def __init__(
        self,
        invalid_device_name: List[str] = None,
    ):
        self.invalid_device_name = invalid_device_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.invalid_device_name is not None:
            result['invalidDeviceName'] = self.invalid_device_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('invalidDeviceName') is not None:
            self.invalid_device_name = m.get('invalidDeviceName')
        return self


class BatchImportDeviceResponseBodyDataInvalidDeviceSecretList(TeaModel):
    def __init__(
        self,
        invalid_device_secret: List[str] = None,
    ):
        self.invalid_device_secret = invalid_device_secret

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.invalid_device_secret is not None:
            result['invalidDeviceSecret'] = self.invalid_device_secret
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('invalidDeviceSecret') is not None:
            self.invalid_device_secret = m.get('invalidDeviceSecret')
        return self


class BatchImportDeviceResponseBodyDataInvalidSnList(TeaModel):
    def __init__(
        self,
        invalid_sn: List[str] = None,
    ):
        self.invalid_sn = invalid_sn

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.invalid_sn is not None:
            result['invalidSn'] = self.invalid_sn
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('invalidSn') is not None:
            self.invalid_sn = m.get('invalidSn')
        return self


class BatchImportDeviceResponseBodyDataRepeatedDeviceNameList(TeaModel):
    def __init__(
        self,
        repeated_device_name: List[str] = None,
    ):
        self.repeated_device_name = repeated_device_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.repeated_device_name is not None:
            result['repeatedDeviceName'] = self.repeated_device_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('repeatedDeviceName') is not None:
            self.repeated_device_name = m.get('repeatedDeviceName')
        return self


class BatchImportDeviceResponseBodyData(TeaModel):
    def __init__(
        self,
        apply_id: int = None,
        invalid_detail_list: BatchImportDeviceResponseBodyDataInvalidDetailList = None,
        invalid_device_name_list: BatchImportDeviceResponseBodyDataInvalidDeviceNameList = None,
        invalid_device_secret_list: BatchImportDeviceResponseBodyDataInvalidDeviceSecretList = None,
        invalid_sn_list: BatchImportDeviceResponseBodyDataInvalidSnList = None,
        repeated_device_name_list: BatchImportDeviceResponseBodyDataRepeatedDeviceNameList = None,
    ):
        # The application ID returned if the request is successful.
        self.apply_id = apply_id
        self.invalid_detail_list = invalid_detail_list
        self.invalid_device_name_list = invalid_device_name_list
        self.invalid_device_secret_list = invalid_device_secret_list
        self.invalid_sn_list = invalid_sn_list
        self.repeated_device_name_list = repeated_device_name_list

    def validate(self):
        if self.invalid_detail_list:
            self.invalid_detail_list.validate()
        if self.invalid_device_name_list:
            self.invalid_device_name_list.validate()
        if self.invalid_device_secret_list:
            self.invalid_device_secret_list.validate()
        if self.invalid_sn_list:
            self.invalid_sn_list.validate()
        if self.repeated_device_name_list:
            self.repeated_device_name_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.apply_id is not None:
            result['ApplyId'] = self.apply_id
        if self.invalid_detail_list is not None:
            result['InvalidDetailList'] = self.invalid_detail_list.to_map()
        if self.invalid_device_name_list is not None:
            result['InvalidDeviceNameList'] = self.invalid_device_name_list.to_map()
        if self.invalid_device_secret_list is not None:
            result['InvalidDeviceSecretList'] = self.invalid_device_secret_list.to_map()
        if self.invalid_sn_list is not None:
            result['InvalidSnList'] = self.invalid_sn_list.to_map()
        if self.repeated_device_name_list is not None:
            result['RepeatedDeviceNameList'] = self.repeated_device_name_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApplyId') is not None:
            self.apply_id = m.get('ApplyId')
        if m.get('InvalidDetailList') is not None:
            temp_model = BatchImportDeviceResponseBodyDataInvalidDetailList()
            self.invalid_detail_list = temp_model.from_map(m['InvalidDetailList'])
        if m.get('InvalidDeviceNameList') is not None:
            temp_model = BatchImportDeviceResponseBodyDataInvalidDeviceNameList()
            self.invalid_device_name_list = temp_model.from_map(m['InvalidDeviceNameList'])
        if m.get('InvalidDeviceSecretList') is not None:
            temp_model = BatchImportDeviceResponseBodyDataInvalidDeviceSecretList()
            self.invalid_device_secret_list = temp_model.from_map(m['InvalidDeviceSecretList'])
        if m.get('InvalidSnList') is not None:
            temp_model = BatchImportDeviceResponseBodyDataInvalidSnList()
            self.invalid_sn_list = temp_model.from_map(m['InvalidSnList'])
        if m.get('RepeatedDeviceNameList') is not None:
            temp_model = BatchImportDeviceResponseBodyDataRepeatedDeviceNameList()
            self.repeated_device_name_list = temp_model.from_map(m['RepeatedDeviceNameList'])
        return self


class BatchImportDeviceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: BatchImportDeviceResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The returned data.
        self.data = data
        # The error message returned if the request fails.
        self.error_message = error_message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = BatchImportDeviceResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class BatchImportDeviceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BatchImportDeviceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchImportDeviceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchImportVehicleDeviceRequestDeviceList(TeaModel):
    def __init__(
        self,
        device_id: str = None,
        device_model: str = None,
        device_name: str = None,
        device_secret: str = None,
        manufacturer: str = None,
    ):
        self.device_id = device_id
        self.device_model = device_model
        self.device_name = device_name
        self.device_secret = device_secret
        self.manufacturer = manufacturer

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.device_model is not None:
            result['DeviceModel'] = self.device_model
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.device_secret is not None:
            result['DeviceSecret'] = self.device_secret
        if self.manufacturer is not None:
            result['Manufacturer'] = self.manufacturer
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('DeviceModel') is not None:
            self.device_model = m.get('DeviceModel')
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('DeviceSecret') is not None:
            self.device_secret = m.get('DeviceSecret')
        if m.get('Manufacturer') is not None:
            self.manufacturer = m.get('Manufacturer')
        return self


class BatchImportVehicleDeviceRequest(TeaModel):
    def __init__(
        self,
        device_list: List[BatchImportVehicleDeviceRequestDeviceList] = None,
        iot_instance_id: str = None,
        product_key: str = None,
    ):
        self.device_list = device_list
        # BatchImportVehicleDevice
        self.iot_instance_id = iot_instance_id
        self.product_key = product_key

    def validate(self):
        if self.device_list:
            for k in self.device_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DeviceList'] = []
        if self.device_list is not None:
            for k in self.device_list:
                result['DeviceList'].append(k.to_map() if k else None)
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.device_list = []
        if m.get('DeviceList') is not None:
            for k in m.get('DeviceList'):
                temp_model = BatchImportVehicleDeviceRequestDeviceList()
                self.device_list.append(temp_model.from_map(k))
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class BatchImportVehicleDeviceResponseBodyDataInvalidDetailListInvalidDetailList(TeaModel):
    def __init__(
        self,
        device_id: str = None,
        device_model: str = None,
        device_name: str = None,
        error_msg: str = None,
        manufacturer: str = None,
    ):
        self.device_id = device_id
        self.device_model = device_model
        self.device_name = device_name
        self.error_msg = error_msg
        self.manufacturer = manufacturer

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.device_model is not None:
            result['DeviceModel'] = self.device_model
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.error_msg is not None:
            result['ErrorMsg'] = self.error_msg
        if self.manufacturer is not None:
            result['Manufacturer'] = self.manufacturer
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('DeviceModel') is not None:
            self.device_model = m.get('DeviceModel')
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('ErrorMsg') is not None:
            self.error_msg = m.get('ErrorMsg')
        if m.get('Manufacturer') is not None:
            self.manufacturer = m.get('Manufacturer')
        return self


class BatchImportVehicleDeviceResponseBodyDataInvalidDetailList(TeaModel):
    def __init__(
        self,
        invalid_detail_list: List[BatchImportVehicleDeviceResponseBodyDataInvalidDetailListInvalidDetailList] = None,
    ):
        self.invalid_detail_list = invalid_detail_list

    def validate(self):
        if self.invalid_detail_list:
            for k in self.invalid_detail_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InvalidDetailList'] = []
        if self.invalid_detail_list is not None:
            for k in self.invalid_detail_list:
                result['InvalidDetailList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.invalid_detail_list = []
        if m.get('InvalidDetailList') is not None:
            for k in m.get('InvalidDetailList'):
                temp_model = BatchImportVehicleDeviceResponseBodyDataInvalidDetailListInvalidDetailList()
                self.invalid_detail_list.append(temp_model.from_map(k))
        return self


class BatchImportVehicleDeviceResponseBodyDataInvalidDeviceIdList(TeaModel):
    def __init__(
        self,
        invalid_device_id_list: List[str] = None,
    ):
        self.invalid_device_id_list = invalid_device_id_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.invalid_device_id_list is not None:
            result['invalidDeviceIdList'] = self.invalid_device_id_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('invalidDeviceIdList') is not None:
            self.invalid_device_id_list = m.get('invalidDeviceIdList')
        return self


class BatchImportVehicleDeviceResponseBodyDataInvalidDeviceModelList(TeaModel):
    def __init__(
        self,
        invalid_device_model_list: List[str] = None,
    ):
        self.invalid_device_model_list = invalid_device_model_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.invalid_device_model_list is not None:
            result['invalidDeviceModelList'] = self.invalid_device_model_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('invalidDeviceModelList') is not None:
            self.invalid_device_model_list = m.get('invalidDeviceModelList')
        return self


class BatchImportVehicleDeviceResponseBodyDataInvalidDeviceNameList(TeaModel):
    def __init__(
        self,
        invalid_device_name_list: List[str] = None,
    ):
        self.invalid_device_name_list = invalid_device_name_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.invalid_device_name_list is not None:
            result['InvalidDeviceNameList'] = self.invalid_device_name_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InvalidDeviceNameList') is not None:
            self.invalid_device_name_list = m.get('InvalidDeviceNameList')
        return self


class BatchImportVehicleDeviceResponseBodyDataInvalidManufacturerList(TeaModel):
    def __init__(
        self,
        invalid_manufacturer_list: List[str] = None,
    ):
        self.invalid_manufacturer_list = invalid_manufacturer_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.invalid_manufacturer_list is not None:
            result['invalidManufacturerList'] = self.invalid_manufacturer_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('invalidManufacturerList') is not None:
            self.invalid_manufacturer_list = m.get('invalidManufacturerList')
        return self


class BatchImportVehicleDeviceResponseBodyDataRepeatedDeviceIdList(TeaModel):
    def __init__(
        self,
        repeated_device_id_list: List[str] = None,
    ):
        self.repeated_device_id_list = repeated_device_id_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.repeated_device_id_list is not None:
            result['repeatedDeviceIdList'] = self.repeated_device_id_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('repeatedDeviceIdList') is not None:
            self.repeated_device_id_list = m.get('repeatedDeviceIdList')
        return self


class BatchImportVehicleDeviceResponseBodyDataRepeatedDeviceNameList(TeaModel):
    def __init__(
        self,
        repeated_device_name_list: List[str] = None,
    ):
        self.repeated_device_name_list = repeated_device_name_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.repeated_device_name_list is not None:
            result['RepeatedDeviceNameList'] = self.repeated_device_name_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('RepeatedDeviceNameList') is not None:
            self.repeated_device_name_list = m.get('RepeatedDeviceNameList')
        return self


class BatchImportVehicleDeviceResponseBodyData(TeaModel):
    def __init__(
        self,
        apply_id: int = None,
        invalid_detail_list: BatchImportVehicleDeviceResponseBodyDataInvalidDetailList = None,
        invalid_device_id_list: BatchImportVehicleDeviceResponseBodyDataInvalidDeviceIdList = None,
        invalid_device_model_list: BatchImportVehicleDeviceResponseBodyDataInvalidDeviceModelList = None,
        invalid_device_name_list: BatchImportVehicleDeviceResponseBodyDataInvalidDeviceNameList = None,
        invalid_manufacturer_list: BatchImportVehicleDeviceResponseBodyDataInvalidManufacturerList = None,
        repeated_device_id_list: BatchImportVehicleDeviceResponseBodyDataRepeatedDeviceIdList = None,
        repeated_device_name_list: BatchImportVehicleDeviceResponseBodyDataRepeatedDeviceNameList = None,
    ):
        self.apply_id = apply_id
        self.invalid_detail_list = invalid_detail_list
        self.invalid_device_id_list = invalid_device_id_list
        self.invalid_device_model_list = invalid_device_model_list
        self.invalid_device_name_list = invalid_device_name_list
        self.invalid_manufacturer_list = invalid_manufacturer_list
        self.repeated_device_id_list = repeated_device_id_list
        self.repeated_device_name_list = repeated_device_name_list

    def validate(self):
        if self.invalid_detail_list:
            self.invalid_detail_list.validate()
        if self.invalid_device_id_list:
            self.invalid_device_id_list.validate()
        if self.invalid_device_model_list:
            self.invalid_device_model_list.validate()
        if self.invalid_device_name_list:
            self.invalid_device_name_list.validate()
        if self.invalid_manufacturer_list:
            self.invalid_manufacturer_list.validate()
        if self.repeated_device_id_list:
            self.repeated_device_id_list.validate()
        if self.repeated_device_name_list:
            self.repeated_device_name_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.apply_id is not None:
            result['ApplyId'] = self.apply_id
        if self.invalid_detail_list is not None:
            result['InvalidDetailList'] = self.invalid_detail_list.to_map()
        if self.invalid_device_id_list is not None:
            result['InvalidDeviceIdList'] = self.invalid_device_id_list.to_map()
        if self.invalid_device_model_list is not None:
            result['InvalidDeviceModelList'] = self.invalid_device_model_list.to_map()
        if self.invalid_device_name_list is not None:
            result['InvalidDeviceNameList'] = self.invalid_device_name_list.to_map()
        if self.invalid_manufacturer_list is not None:
            result['InvalidManufacturerList'] = self.invalid_manufacturer_list.to_map()
        if self.repeated_device_id_list is not None:
            result['RepeatedDeviceIdList'] = self.repeated_device_id_list.to_map()
        if self.repeated_device_name_list is not None:
            result['RepeatedDeviceNameList'] = self.repeated_device_name_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApplyId') is not None:
            self.apply_id = m.get('ApplyId')
        if m.get('InvalidDetailList') is not None:
            temp_model = BatchImportVehicleDeviceResponseBodyDataInvalidDetailList()
            self.invalid_detail_list = temp_model.from_map(m['InvalidDetailList'])
        if m.get('InvalidDeviceIdList') is not None:
            temp_model = BatchImportVehicleDeviceResponseBodyDataInvalidDeviceIdList()
            self.invalid_device_id_list = temp_model.from_map(m['InvalidDeviceIdList'])
        if m.get('InvalidDeviceModelList') is not None:
            temp_model = BatchImportVehicleDeviceResponseBodyDataInvalidDeviceModelList()
            self.invalid_device_model_list = temp_model.from_map(m['InvalidDeviceModelList'])
        if m.get('InvalidDeviceNameList') is not None:
            temp_model = BatchImportVehicleDeviceResponseBodyDataInvalidDeviceNameList()
            self.invalid_device_name_list = temp_model.from_map(m['InvalidDeviceNameList'])
        if m.get('InvalidManufacturerList') is not None:
            temp_model = BatchImportVehicleDeviceResponseBodyDataInvalidManufacturerList()
            self.invalid_manufacturer_list = temp_model.from_map(m['InvalidManufacturerList'])
        if m.get('RepeatedDeviceIdList') is not None:
            temp_model = BatchImportVehicleDeviceResponseBodyDataRepeatedDeviceIdList()
            self.repeated_device_id_list = temp_model.from_map(m['RepeatedDeviceIdList'])
        if m.get('RepeatedDeviceNameList') is not None:
            temp_model = BatchImportVehicleDeviceResponseBodyDataRepeatedDeviceNameList()
            self.repeated_device_name_list = temp_model.from_map(m['RepeatedDeviceNameList'])
        return self


class BatchImportVehicleDeviceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: BatchImportVehicleDeviceResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = BatchImportVehicleDeviceResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class BatchImportVehicleDeviceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BatchImportVehicleDeviceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchImportVehicleDeviceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchPubRequestUserProp(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        self.key = key
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class BatchPubRequest(TeaModel):
    def __init__(
        self,
        content_type: str = None,
        correlation_data: str = None,
        device_name: List[str] = None,
        iot_instance_id: str = None,
        message_content: str = None,
        message_expiry_interval: int = None,
        payload_format_indicator: int = None,
        product_key: str = None,
        qos: int = None,
        response_topic_template_name: str = None,
        retained: bool = None,
        topic_short_name: str = None,
        topic_template_name: str = None,
        user_prop: List[BatchPubRequestUserProp] = None,
    ):
        self.content_type = content_type
        self.correlation_data = correlation_data
        self.device_name = device_name
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The body of the message to be published. The maximum size of a message is 256 KB.
        # 
        # To generate a message body, you must convert the raw message into binary data and perform Base64 encoding.
        self.message_content = message_content
        self.message_expiry_interval = message_expiry_interval
        self.payload_format_indicator = payload_format_indicator
        # The **ProductKey** of the product to which the device belongs.
        self.product_key = product_key
        # The quality of service (QoS) level of the message. Valid values:
        # 
        # *   **0**: The message is published at most once.
        # *   **1**: The message is published at least once.
        # 
        # Default value: **0**.
        # 
        # >  IoT Platform stores QoS 1 messages for up to 7 days. IoT Platform does not store QoS 0 messages.
        self.qos = qos
        self.response_topic_template_name = response_topic_template_name
        self.retained = retained
        # The suffix of the custom topic.
        # 
        # A custom topic is in the following format: `/${productKey}/${deviceName}/user/${TopicShortName}`. ${TopicShortName} specifies the suffix.
        # 
        # >  You must specify the Subscribe permission, or Publish and Subscribe permissions for the topic. Make sure that all devices subscribe to the topic.
        # 
        # You can use the following methods to view custom topics:
        # 
        # *   On the **Topic Categories** tab of the Product Details page, view the custom topics of the product.
        # *   On the **Topic List** tab of the Device Details page, view the custom topics to which the device has subscribed.
        # *   Call the [QueryProductTopic](~~69647~~) operation to query the custom topics of the product.
        self.topic_short_name = topic_short_name
        self.topic_template_name = topic_template_name
        self.user_prop = user_prop

    def validate(self):
        if self.user_prop:
            for k in self.user_prop:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content_type is not None:
            result['ContentType'] = self.content_type
        if self.correlation_data is not None:
            result['CorrelationData'] = self.correlation_data
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.message_content is not None:
            result['MessageContent'] = self.message_content
        if self.message_expiry_interval is not None:
            result['MessageExpiryInterval'] = self.message_expiry_interval
        if self.payload_format_indicator is not None:
            result['PayloadFormatIndicator'] = self.payload_format_indicator
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.qos is not None:
            result['Qos'] = self.qos
        if self.response_topic_template_name is not None:
            result['ResponseTopicTemplateName'] = self.response_topic_template_name
        if self.retained is not None:
            result['Retained'] = self.retained
        if self.topic_short_name is not None:
            result['TopicShortName'] = self.topic_short_name
        if self.topic_template_name is not None:
            result['TopicTemplateName'] = self.topic_template_name
        result['UserProp'] = []
        if self.user_prop is not None:
            for k in self.user_prop:
                result['UserProp'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContentType') is not None:
            self.content_type = m.get('ContentType')
        if m.get('CorrelationData') is not None:
            self.correlation_data = m.get('CorrelationData')
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('MessageContent') is not None:
            self.message_content = m.get('MessageContent')
        if m.get('MessageExpiryInterval') is not None:
            self.message_expiry_interval = m.get('MessageExpiryInterval')
        if m.get('PayloadFormatIndicator') is not None:
            self.payload_format_indicator = m.get('PayloadFormatIndicator')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('Qos') is not None:
            self.qos = m.get('Qos')
        if m.get('ResponseTopicTemplateName') is not None:
            self.response_topic_template_name = m.get('ResponseTopicTemplateName')
        if m.get('Retained') is not None:
            self.retained = m.get('Retained')
        if m.get('TopicShortName') is not None:
            self.topic_short_name = m.get('TopicShortName')
        if m.get('TopicTemplateName') is not None:
            self.topic_template_name = m.get('TopicTemplateName')
        self.user_prop = []
        if m.get('UserProp') is not None:
            for k in m.get('UserProp'):
                temp_model = BatchPubRequestUserProp()
                self.user_prop.append(temp_model.from_map(k))
        return self


class BatchPubResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class BatchPubResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BatchPubResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchPubResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchQueryDeviceDetailRequest(TeaModel):
    def __init__(
        self,
        device_name: List[str] = None,
        iot_instance_id: str = None,
        product_key: str = None,
    ):
        self.device_name = device_name
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The **ProductKey** of the product to which the devices specified by the **DeviceName.N** parameter belong.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class BatchQueryDeviceDetailResponseBodyDataData(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        device_secret: str = None,
        firmware_version: str = None,
        gmt_active: str = None,
        gmt_create: str = None,
        iot_id: str = None,
        nickname: str = None,
        node_type: int = None,
        product_key: str = None,
        product_name: str = None,
        region: str = None,
        status: str = None,
        utc_active: str = None,
        utc_create: str = None,
    ):
        # The DeviceName of the device.
        self.device_name = device_name
        # The DeviceSecret of the device.
        self.device_secret = device_secret
        # The firmware version number of the device.
        self.firmware_version = firmware_version
        # The activation time of the device. The time is displayed in UTC.
        self.gmt_active = gmt_active
        # The creation time of the device. The time is displayed in UTC.
        self.gmt_create = gmt_create
        # The unique ID of the device. The device ID is issued by IoT Platform.
        self.iot_id = iot_id
        # The alias of the device.
        self.nickname = nickname
        # The type of the node. Valid values:
        # 
        # *   **0**: device. Sub-devices cannot be mounted on a gateway. A device can connect to IoT Platform directly or as a sub-device of a gateway.
        # *   **1**: gateway. Sub-devices can be attached to a gateway. A gateway can manage sub-devices, maintain the topological relationships with sub-devices, and synchronize the topological relationships to IoT Platform.
        self.node_type = node_type
        # The **ProductKey** of the product to which the device belongs.
        self.product_key = product_key
        # The name of the product to which the device belongs.
        self.product_name = product_name
        # The ID of the region where the device resides. The region is the same as the region where IoT Platform resides. You can view the region in the IoT Platform console.
        self.region = region
        # The status of the device. Valid values:
        # 
        # *   **ONLINE**: The device is online.
        # *   **OFFLINE**: The device is offline.
        # *   **UNACTIVE**: The device is not activated.
        # *   **DISABLE**: The device is disabled.
        self.status = status
        # The activation time of the device. The time is displayed in UTC.
        self.utc_active = utc_active
        # The creation time of the device. The time is displayed in UTC.
        self.utc_create = utc_create

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.device_secret is not None:
            result['DeviceSecret'] = self.device_secret
        if self.firmware_version is not None:
            result['FirmwareVersion'] = self.firmware_version
        if self.gmt_active is not None:
            result['GmtActive'] = self.gmt_active
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.nickname is not None:
            result['Nickname'] = self.nickname
        if self.node_type is not None:
            result['NodeType'] = self.node_type
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.product_name is not None:
            result['ProductName'] = self.product_name
        if self.region is not None:
            result['Region'] = self.region
        if self.status is not None:
            result['Status'] = self.status
        if self.utc_active is not None:
            result['UtcActive'] = self.utc_active
        if self.utc_create is not None:
            result['UtcCreate'] = self.utc_create
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('DeviceSecret') is not None:
            self.device_secret = m.get('DeviceSecret')
        if m.get('FirmwareVersion') is not None:
            self.firmware_version = m.get('FirmwareVersion')
        if m.get('GmtActive') is not None:
            self.gmt_active = m.get('GmtActive')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('Nickname') is not None:
            self.nickname = m.get('Nickname')
        if m.get('NodeType') is not None:
            self.node_type = m.get('NodeType')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('ProductName') is not None:
            self.product_name = m.get('ProductName')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UtcActive') is not None:
            self.utc_active = m.get('UtcActive')
        if m.get('UtcCreate') is not None:
            self.utc_create = m.get('UtcCreate')
        return self


class BatchQueryDeviceDetailResponseBodyData(TeaModel):
    def __init__(
        self,
        data: List[BatchQueryDeviceDetailResponseBodyDataData] = None,
    ):
        self.data = data

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = BatchQueryDeviceDetailResponseBodyDataData()
                self.data.append(temp_model.from_map(k))
        return self


class BatchQueryDeviceDetailResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: BatchQueryDeviceDetailResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The device details returned if the call is successful.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = BatchQueryDeviceDetailResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class BatchQueryDeviceDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BatchQueryDeviceDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchQueryDeviceDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchRegisterDeviceRequest(TeaModel):
    def __init__(
        self,
        count: int = None,
        iot_instance_id: str = None,
        product_key: str = None,
    ):
        # The number of devices to be registered.
        # 
        # >  You can register up to 10,000 devices in a single call.
        self.count = count
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The ProductKey of the product to which the devices belong.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class BatchRegisterDeviceResponseBodyData(TeaModel):
    def __init__(
        self,
        apply_id: int = None,
    ):
        # The application ID (ApplyId) returned for the request if the call is successful.
        self.apply_id = apply_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.apply_id is not None:
            result['ApplyId'] = self.apply_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApplyId') is not None:
            self.apply_id = m.get('ApplyId')
        return self


class BatchRegisterDeviceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: BatchRegisterDeviceResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The data returned if the call is successful.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = BatchRegisterDeviceResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class BatchRegisterDeviceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BatchRegisterDeviceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchRegisterDeviceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchRegisterDeviceWithApplyIdRequest(TeaModel):
    def __init__(
        self,
        apply_id: int = None,
        iot_instance_id: str = None,
        product_key: str = None,
    ):
        # The ID of the application. The application ID is returned by the [BatchCheckDeviceNames](~~69482~~) operation.
        self.apply_id = apply_id
        # The ID of the instance. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.
        # >*   If no **Overview** page or ID is generated for your instance, you do not need to configure this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The ProductKey of the product to which the device belongs.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.apply_id is not None:
            result['ApplyId'] = self.apply_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApplyId') is not None:
            self.apply_id = m.get('ApplyId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class BatchRegisterDeviceWithApplyIdResponseBodyData(TeaModel):
    def __init__(
        self,
        apply_id: int = None,
    ):
        # The application ID.
        self.apply_id = apply_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.apply_id is not None:
            result['ApplyId'] = self.apply_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApplyId') is not None:
            self.apply_id = m.get('ApplyId')
        return self


class BatchRegisterDeviceWithApplyIdResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: BatchRegisterDeviceWithApplyIdResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The data returned if the call succeeds. For more information, see the following parameters.
        self.data = data
        # The error message returned if the request fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = BatchRegisterDeviceWithApplyIdResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class BatchRegisterDeviceWithApplyIdResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BatchRegisterDeviceWithApplyIdResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchRegisterDeviceWithApplyIdResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchSetEdgeInstanceDeviceChannelRequest(TeaModel):
    def __init__(
        self,
        channel_id: str = None,
        driver_id: str = None,
        instance_id: str = None,
        iot_ids: List[str] = None,
        iot_instance_id: str = None,
    ):
        self.channel_id = channel_id
        self.driver_id = driver_id
        self.instance_id = instance_id
        self.iot_ids = iot_ids
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.driver_id is not None:
            result['DriverId'] = self.driver_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.iot_ids is not None:
            result['IotIds'] = self.iot_ids
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('DriverId') is not None:
            self.driver_id = m.get('DriverId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IotIds') is not None:
            self.iot_ids = m.get('IotIds')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class BatchSetEdgeInstanceDeviceChannelResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class BatchSetEdgeInstanceDeviceChannelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BatchSetEdgeInstanceDeviceChannelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchSetEdgeInstanceDeviceChannelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchSetEdgeInstanceDeviceConfigRequestDeviceConfigs(TeaModel):
    def __init__(
        self,
        content: str = None,
        iot_id: str = None,
    ):
        self.content = content
        self.iot_id = iot_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        return self


class BatchSetEdgeInstanceDeviceConfigRequest(TeaModel):
    def __init__(
        self,
        device_configs: List[BatchSetEdgeInstanceDeviceConfigRequestDeviceConfigs] = None,
        instance_id: str = None,
        iot_instance_id: str = None,
    ):
        self.device_configs = device_configs
        self.instance_id = instance_id
        self.iot_instance_id = iot_instance_id

    def validate(self):
        if self.device_configs:
            for k in self.device_configs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DeviceConfigs'] = []
        if self.device_configs is not None:
            for k in self.device_configs:
                result['DeviceConfigs'].append(k.to_map() if k else None)
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.device_configs = []
        if m.get('DeviceConfigs') is not None:
            for k in m.get('DeviceConfigs'):
                temp_model = BatchSetEdgeInstanceDeviceConfigRequestDeviceConfigs()
                self.device_configs.append(temp_model.from_map(k))
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class BatchSetEdgeInstanceDeviceConfigResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class BatchSetEdgeInstanceDeviceConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BatchSetEdgeInstanceDeviceConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchSetEdgeInstanceDeviceConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchUnbindDeviceFromEdgeInstanceRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        iot_ids: List[str] = None,
        iot_instance_id: str = None,
    ):
        # The ID of the edge instance. To obtain the instance ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Edge Instances** page, move the pointer over the name of the edge instance from which you want to unbind multiple devices and obtain the instance ID.
        # 
        # You can also call the [QueryEdgeInstance](~~135214~~) operation to query the instance ID.
        self.instance_id = instance_id
        self.iot_ids = iot_ids
        # The ID of the Internet of Things (IoT) service instance. This parameter is not required for the public instance but required for Enterprise Edition instances.
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.iot_ids is not None:
            result['IotIds'] = self.iot_ids
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IotIds') is not None:
            self.iot_ids = m.get('IotIds')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class BatchUnbindDeviceFromEdgeInstanceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The return code of the operation. A value of Success indicates that the call was successful. Other values indicate that specific errors occurred. For more information, see [Error codes](~~135200~~).
        self.code = code
        # The error message that is returned if the call failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful. A value of true indicates that the call was successful. A value of false indicates that the call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class BatchUnbindDeviceFromEdgeInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BatchUnbindDeviceFromEdgeInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchUnbindDeviceFromEdgeInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchUnbindProjectDevicesRequestDevices(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        product_key: str = None,
    ):
        self.device_name = device_name
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class BatchUnbindProjectDevicesRequest(TeaModel):
    def __init__(
        self,
        devices: List[BatchUnbindProjectDevicesRequestDevices] = None,
        iot_instance_id: str = None,
        project_id: str = None,
    ):
        self.devices = devices
        self.iot_instance_id = iot_instance_id
        self.project_id = project_id

    def validate(self):
        if self.devices:
            for k in self.devices:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Devices'] = []
        if self.devices is not None:
            for k in self.devices:
                result['Devices'].append(k.to_map() if k else None)
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.devices = []
        if m.get('Devices') is not None:
            for k in m.get('Devices'):
                temp_model = BatchUnbindProjectDevicesRequestDevices()
                self.devices.append(temp_model.from_map(k))
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class BatchUnbindProjectDevicesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: bool = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class BatchUnbindProjectDevicesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BatchUnbindProjectDevicesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchUnbindProjectDevicesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchUnbindProjectProductsRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        product_keys: List[str] = None,
        project_id: str = None,
    ):
        self.iot_instance_id = iot_instance_id
        self.product_keys = product_keys
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_keys is not None:
            result['ProductKeys'] = self.product_keys
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKeys') is not None:
            self.product_keys = m.get('ProductKeys')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class BatchUnbindProjectProductsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: bool = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class BatchUnbindProjectProductsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BatchUnbindProjectProductsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchUnbindProjectProductsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchUpdateDeviceNicknameRequestDeviceNicknameInfo(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        iot_id: str = None,
        nickname: str = None,
        product_key: str = None,
    ):
        # The DeviceName of the device.
        # 
        # >  If you specify this parameter, you must also specify the **ProductKey** parameter.
        self.device_name = device_name
        # The ID of the device.
        # 
        # >  If you specify this parameter, you do not need to specify **ProductKey** or **DeviceName**. The **IotId** parameter specifies a globally unique identifier (GUID) of the device, which corresponds to a combination of **ProductKey** and **DeviceName**. If you specify both **IotId** and the combination of **ProductKey** and **DeviceName**, **IotId** takes precedence.
        self.iot_id = iot_id
        # The new alias of the device. The alias must be 4 to 32 characters in length, and can contain letters, digits, and underscores (\_). Each Chinese character is counted as two characters.
        # 
        # >  If you do not specify this parameter, the original alias of the device will be deleted.
        self.nickname = nickname
        # The ProductKey of the product to which the device belongs.
        # 
        # >  If you specify this parameter, you must also specify the **DeviceName** parameter.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.nickname is not None:
            result['Nickname'] = self.nickname
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('Nickname') is not None:
            self.nickname = m.get('Nickname')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class BatchUpdateDeviceNicknameRequest(TeaModel):
    def __init__(
        self,
        device_nickname_info: List[BatchUpdateDeviceNicknameRequestDeviceNicknameInfo] = None,
        iot_instance_id: str = None,
    ):
        self.device_nickname_info = device_nickname_info
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id

    def validate(self):
        if self.device_nickname_info:
            for k in self.device_nickname_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DeviceNicknameInfo'] = []
        if self.device_nickname_info is not None:
            for k in self.device_nickname_info:
                result['DeviceNicknameInfo'].append(k.to_map() if k else None)
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.device_nickname_info = []
        if m.get('DeviceNicknameInfo') is not None:
            for k in m.get('DeviceNicknameInfo'):
                temp_model = BatchUpdateDeviceNicknameRequestDeviceNicknameInfo()
                self.device_nickname_info.append(temp_model.from_map(k))
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class BatchUpdateDeviceNicknameResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class BatchUpdateDeviceNicknameResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BatchUpdateDeviceNicknameResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchUpdateDeviceNicknameResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BindApplicationToEdgeInstanceRequest(TeaModel):
    def __init__(
        self,
        application_id: str = None,
        application_version: str = None,
        instance_id: str = None,
        iot_instance_id: str = None,
    ):
        self.application_id = application_id
        self.application_version = application_version
        self.instance_id = instance_id
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.application_id is not None:
            result['ApplicationId'] = self.application_id
        if self.application_version is not None:
            result['ApplicationVersion'] = self.application_version
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApplicationId') is not None:
            self.application_id = m.get('ApplicationId')
        if m.get('ApplicationVersion') is not None:
            self.application_version = m.get('ApplicationVersion')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class BindApplicationToEdgeInstanceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class BindApplicationToEdgeInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BindApplicationToEdgeInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BindApplicationToEdgeInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BindDriverToEdgeInstanceRequest(TeaModel):
    def __init__(
        self,
        driver_id: str = None,
        driver_version: str = None,
        instance_id: str = None,
        iot_instance_id: str = None,
        order_id: str = None,
    ):
        # The ID of the driver. To obtain the driver ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Drivers** page, move the pointer over the name of the driver that you want to bind and obtain the driver ID.
        # 
        # You can also call the [QueryEdgeDriver](~~155776~~) operation to query the driver ID.
        self.driver_id = driver_id
        # The version number of the driver. By default, if you do not specify this parameter, the latest version of the driver is used.
        self.driver_version = driver_version
        # The ID of the edge instance. To obtain the instance ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Edge Instances** page, move the pointer over the name of the edge instance to which you want to bind a driver and obtain the instance ID.
        # 
        # You can also call the [QueryEdgeInstance](~~135214~~) operation to query the instance ID.
        self.instance_id = instance_id
        # The ID of the Internet of Things (IoT) service instance. This parameter is not required for the public instance but required for Enterprise Edition instances.
        self.iot_instance_id = iot_instance_id
        # The ID of the order.
        # 
        # >  This parameter is required if you use a third-party driver that is purchased from the IoT marketplace. If an official or self-developed driver is used, you do not need to specify this parameter.
        self.order_id = order_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.driver_id is not None:
            result['DriverId'] = self.driver_id
        if self.driver_version is not None:
            result['DriverVersion'] = self.driver_version
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DriverId') is not None:
            self.driver_id = m.get('DriverId')
        if m.get('DriverVersion') is not None:
            self.driver_version = m.get('DriverVersion')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        return self


class BindDriverToEdgeInstanceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The return code of the operation. A value of Success indicates that the call was successful. Other values indicate that specific errors occurred. For more information, see [Error codes](~~135200~~).
        self.code = code
        # The error message that is returned if the call failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful. A value of true indicates that the call was successful. A value of false indicates that the call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class BindDriverToEdgeInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BindDriverToEdgeInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BindDriverToEdgeInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BindGatewayToEdgeInstanceRequest(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        instance_id: str = None,
        iot_id: str = None,
        iot_instance_id: str = None,
        product_key: str = None,
    ):
        # The name of the gateway.
        # 
        # >  If you specify this parameter, you must also specify the **ProductKey** parameter.
        self.device_name = device_name
        # The ID of the edge instance. To obtain the instance ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Edge Instances** page, move the pointer over the name of the edge instance to which you want to bind a gateway and obtain the instance ID.
        # 
        # You can also call the [QueryEdgeInstance](~~135214~~) operation to query the instance ID.
        self.instance_id = instance_id
        # The ID of the gateway in IoT Platform. This parameter corresponds to the combination of the **ProductKey** and **DeviceName** parameters.
        # 
        # >  If you specify this parameter, you do not need to specify the **ProductKey** or **DeviceName** parameter. If you use the **IotId** parameter and the combination of the **ProductKey** and **DeviceName** parameters, only the **IotId** parameter takes effect.
        self.iot_id = iot_id
        # The ID of the Internet of Things (IoT) service instance. This parameter is not required for the public instance but required for Enterprise Edition instances.
        self.iot_instance_id = iot_instance_id
        # The key that uniquely identifies the product to which the gateway belongs.
        # 
        # >  If you specify this parameter, you must also specify the **DeviceName** parameter.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class BindGatewayToEdgeInstanceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The return code of the operation. A value of Success indicates that the call was successful. Other values indicate that specific errors occurred. For more information, see [Error codes](~~135200~~).
        self.code = code
        # The error message that is returned if the call failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful. A value of true indicates that the call was successful. A value of false indicates that the call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class BindGatewayToEdgeInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BindGatewayToEdgeInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BindGatewayToEdgeInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BindLicenseDeviceRequest(TeaModel):
    def __init__(
        self,
        device_name_list: List[str] = None,
        iot_id_list: List[str] = None,
        iot_instance_id: str = None,
        license_code: str = None,
        product_key: str = None,
    ):
        self.device_name_list = device_name_list
        self.iot_id_list = iot_id_list
        # The ID of the Enterprise Edition instance. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
        self.iot_instance_id = iot_instance_id
        # The license type that specifies the audio and video specifications. Valid values: **480P** and **720P**.
        self.license_code = license_code
        # The **ProductKey** of the product to which the devices belong.
        # 
        # You can go to the IoT Platform console or call the [QueryProductList](~~69271~~) operation to view the information about all products of the instance.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name_list is not None:
            result['DeviceNameList'] = self.device_name_list
        if self.iot_id_list is not None:
            result['IotIdList'] = self.iot_id_list
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.license_code is not None:
            result['LicenseCode'] = self.license_code
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceNameList') is not None:
            self.device_name_list = m.get('DeviceNameList')
        if m.get('IotIdList') is not None:
            self.iot_id_list = m.get('IotIdList')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('LicenseCode') is not None:
            self.license_code = m.get('LicenseCode')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class BindLicenseDeviceResponseBodyData(TeaModel):
    def __init__(
        self,
        check_progress_id: str = None,
        fail_sum: int = None,
        progress: int = None,
        result_csv_file: str = None,
        success_sum: int = None,
    ):
        # The unique ID that can be used to query the progress of the batch binding operation.
        self.check_progress_id = check_progress_id
        # The number of devices that failed to be bound to the license.
        self.fail_sum = fail_sum
        # The progress of the batch binding operation. The progress is a percentage. Valid values: 1 to 100.
        self.progress = progress
        # The URL of the file that contains unbound devices. The devices failed to be bound to the license.
        self.result_csv_file = result_csv_file
        # The number of devices to which the license is successfully bound.
        self.success_sum = success_sum

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_progress_id is not None:
            result['CheckProgressId'] = self.check_progress_id
        if self.fail_sum is not None:
            result['FailSum'] = self.fail_sum
        if self.progress is not None:
            result['Progress'] = self.progress
        if self.result_csv_file is not None:
            result['ResultCsvFile'] = self.result_csv_file
        if self.success_sum is not None:
            result['SuccessSum'] = self.success_sum
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckProgressId') is not None:
            self.check_progress_id = m.get('CheckProgressId')
        if m.get('FailSum') is not None:
            self.fail_sum = m.get('FailSum')
        if m.get('Progress') is not None:
            self.progress = m.get('Progress')
        if m.get('ResultCsvFile') is not None:
            self.result_csv_file = m.get('ResultCsvFile')
        if m.get('SuccessSum') is not None:
            self.success_sum = m.get('SuccessSum')
        return self


class BindLicenseDeviceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: BindLicenseDeviceResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request fails. For more information, see the "Error codes" section in this topic.
        self.code = code
        # The result of the batch binding operation.
        self.data = data
        # The error message returned if the request fails.
        self.error_message = error_message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful.
        # 
        # *   **true**\
        # *   **false**\
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = BindLicenseDeviceResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class BindLicenseDeviceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BindLicenseDeviceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BindLicenseDeviceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BindLicenseProductRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        license_code: str = None,
        product_key: str = None,
    ):
        self.iot_instance_id = iot_instance_id
        self.license_code = license_code
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.license_code is not None:
            result['LicenseCode'] = self.license_code
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('LicenseCode') is not None:
            self.license_code = m.get('LicenseCode')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class BindLicenseProductResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: bool = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class BindLicenseProductResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BindLicenseProductResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BindLicenseProductResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BindRoleToEdgeInstanceRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        iot_instance_id: str = None,
        role_arn: str = None,
        role_name: str = None,
    ):
        self.instance_id = instance_id
        self.iot_instance_id = iot_instance_id
        self.role_arn = role_arn
        self.role_name = role_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.role_arn is not None:
            result['RoleArn'] = self.role_arn
        if self.role_name is not None:
            result['RoleName'] = self.role_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('RoleArn') is not None:
            self.role_arn = m.get('RoleArn')
        if m.get('RoleName') is not None:
            self.role_name = m.get('RoleName')
        return self


class BindRoleToEdgeInstanceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class BindRoleToEdgeInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BindRoleToEdgeInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BindRoleToEdgeInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BindSceneRuleToEdgeInstanceRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        iot_instance_id: str = None,
        rule_id: str = None,
    ):
        self.instance_id = instance_id
        self.iot_instance_id = iot_instance_id
        self.rule_id = rule_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        return self


class BindSceneRuleToEdgeInstanceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class BindSceneRuleToEdgeInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: BindSceneRuleToEdgeInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BindSceneRuleToEdgeInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CancelJobRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        job_id: str = None,
    ):
        self.iot_instance_id = iot_instance_id
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class CancelJobResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CancelJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CancelJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CancelJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CancelOTAStrategyByJobRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        job_id: str = None,
    ):
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The ID of the update batch.
        # 
        # After you call the [CreateOTADynamicUpgradeJob](~~147887~~) operation to create an update batch, the **JobId** parameter is returned. You can also view the batch ID on the **Firmware Details** page of the IoT Platform console.
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class CancelOTAStrategyByJobResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CancelOTAStrategyByJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CancelOTAStrategyByJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CancelOTAStrategyByJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CancelOTATaskByDeviceRequest(TeaModel):
    def __init__(
        self,
        device_name: List[str] = None,
        firmware_id: str = None,
        iot_instance_id: str = None,
        job_id: str = None,
        product_key: str = None,
    ):
        self.device_name = device_name
        # The unique ID of the OTA update package.
        # 
        # An update package ID is returned after you call the [CreateOTAFirmware](~~147311~~) operation to create the update package.
        # 
        # You can call the [ListOTAFirmware](~~147450~~) operation and view the update package ID in the response.
        self.firmware_id = firmware_id
        # The ID of the instance. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.
        # >*   If no **Overview** page or ID is generated for your instance, you do not need to configure this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The ID of the update batch. If you configure this parameter, only the device update tasks in the specified update batch are deleted.
        # 
        # After you call the [CreateOTAVerifyJob](~~147480~~), [CreateOTAStaticUpgradeJob](~~147496~~), or [CreateOTADynamicUpgradeJob](~~147887~~) operation to create a device update task, you can obtain the value of the **JobId** parameter. You can also view the batch ID on the **Firmware Details** page in the IoT Platform console.
        self.job_id = job_id
        # The ProductKey of the product to which the device belongs.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.firmware_id is not None:
            result['FirmwareId'] = self.firmware_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('FirmwareId') is not None:
            self.firmware_id = m.get('FirmwareId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class CancelOTATaskByDeviceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful. Valid values:
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CancelOTATaskByDeviceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CancelOTATaskByDeviceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CancelOTATaskByDeviceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CancelOTATaskByJobRequest(TeaModel):
    def __init__(
        self,
        cancel_in_progress_task: bool = None,
        cancel_notified_task: bool = None,
        cancel_queued_task: bool = None,
        cancel_scheduled_task: bool = None,
        cancel_unconfirmed_task: bool = None,
        iot_instance_id: str = None,
        job_id: str = None,
    ):
        # Specifies whether to cancel the update tasks that are in the **IN_PROGRESS** state in an update batch. Default value: false. Valid values:
        # 
        # *   **true**: cancel the update tasks that are in the IN_PROGRESS state.
        # *   **false**: do not cancel the update tasks that are in the IN_PROGRESS state.
        self.cancel_in_progress_task = cancel_in_progress_task
        # Specifies whether to cancel the update tasks that are in the **NOTIFIED** state in an update batch. Default value: false. Valid values:
        # 
        # *   **true**: cancel the update tasks that are in the NOTIFIED state.
        # *   **false**: do not cancel the update tasks that are in the NOTIFIED state.
        self.cancel_notified_task = cancel_notified_task
        # Specifies whether to cancel the update tasks that are in the **QUEUED** state in an update batch. Default value: false. Valid values:
        # 
        # *   **true**: cancel the update tasks that are in the NOTIFIED state.
        # *   **false**: do not cancel the update tasks that are in the NOTIFIED state.
        # 
        # > If you set this parameter to **true** and specify the **CancelUnconfirmedTask** parameter, only the update tasks that are in the QUEUED state are canceled. If you do not specify the **CancelUnconfirmedTask** parameter, the update tasks that are in the QUEUED or CONFIRM state are canceled.
        self.cancel_queued_task = cancel_queued_task
        # Specifies whether to cancel update tasks of a scheduled update batch. If you specify the **ScheduleTime** parameter when you call the [CreateOTAStaticUpgradeJob](~~147496~~) operation, a scheduled update batch is created. Default value: false. Valid values:
        # 
        # *   **true**: cancel update tasks of a scheduled update batch.
        # *   **false**: do not cancel update tasks of a scheduled update batch.
        self.cancel_scheduled_task = cancel_scheduled_task
        # Specifies whether to cancel the update tasks that are in the **CONFIRM** state in an update batch. Default value: false. Valid values:
        # 
        # *   **true**: cancel the update tasks that are in the CONFIRM state.
        # *   **false**: do not cancel the update tasks that are in the CONFIRM state.
        # 
        # This parameter is empty by default.
        # 
        # > If you do not specify this parameter and set the **CancelQueuedTask** parameter to **true**, the update tasks that are in the CONFIRM state are canceled. If you set the **CancelQueuedTask** parameter to **false**, the update tasks that are in the CONFIRM state are not canceled.
        self.cancel_unconfirmed_task = cancel_unconfirmed_task
        # The ID of the instance. You can obtain the **ID** of the instance on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must specify this parameter. Otherwise, the call fails.
        # >*   If the **Overview** page or an instance ID is not displayed in the IoT Platform console, ignore this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The ID of the update batch.
        # 
        # Use the value that is returned for the **JobId** parameter contained in the response of the [CreateOTAStaticUpgradeJob](~~147496~~) or [CreateOTADynamicUpgradeJob](~~147887~~) operation. You can also obtain the batch ID on the **Firmware Details** page of the IoT Platform console.
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cancel_in_progress_task is not None:
            result['CancelInProgressTask'] = self.cancel_in_progress_task
        if self.cancel_notified_task is not None:
            result['CancelNotifiedTask'] = self.cancel_notified_task
        if self.cancel_queued_task is not None:
            result['CancelQueuedTask'] = self.cancel_queued_task
        if self.cancel_scheduled_task is not None:
            result['CancelScheduledTask'] = self.cancel_scheduled_task
        if self.cancel_unconfirmed_task is not None:
            result['CancelUnconfirmedTask'] = self.cancel_unconfirmed_task
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CancelInProgressTask') is not None:
            self.cancel_in_progress_task = m.get('CancelInProgressTask')
        if m.get('CancelNotifiedTask') is not None:
            self.cancel_notified_task = m.get('CancelNotifiedTask')
        if m.get('CancelQueuedTask') is not None:
            self.cancel_queued_task = m.get('CancelQueuedTask')
        if m.get('CancelScheduledTask') is not None:
            self.cancel_scheduled_task = m.get('CancelScheduledTask')
        if m.get('CancelUnconfirmedTask') is not None:
            self.cancel_unconfirmed_task = m.get('CancelUnconfirmedTask')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class CancelOTATaskByJobResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**\
        # *   **false**\
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CancelOTATaskByJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CancelOTATaskByJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CancelOTATaskByJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CancelReleaseProductRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        product_key: str = None,
    ):
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The ProductKey of the product to be unpublished.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class CancelReleaseProductResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CancelReleaseProductResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CancelReleaseProductResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CancelReleaseProductResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CheckBindLicenseDeviceProgressRequest(TeaModel):
    def __init__(
        self,
        check_progress_id: str = None,
        iot_instance_id: str = None,
        license_code: str = None,
        product_key: str = None,
    ):
        self.check_progress_id = check_progress_id
        self.iot_instance_id = iot_instance_id
        self.license_code = license_code
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_progress_id is not None:
            result['CheckProgressId'] = self.check_progress_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.license_code is not None:
            result['LicenseCode'] = self.license_code
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckProgressId') is not None:
            self.check_progress_id = m.get('CheckProgressId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('LicenseCode') is not None:
            self.license_code = m.get('LicenseCode')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class CheckBindLicenseDeviceProgressResponseBodyData(TeaModel):
    def __init__(
        self,
        fail_sum: int = None,
        progress: int = None,
        result_csv_file: str = None,
        success_sum: int = None,
    ):
        self.fail_sum = fail_sum
        self.progress = progress
        self.result_csv_file = result_csv_file
        self.success_sum = success_sum

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fail_sum is not None:
            result['FailSum'] = self.fail_sum
        if self.progress is not None:
            result['Progress'] = self.progress
        if self.result_csv_file is not None:
            result['ResultCsvFile'] = self.result_csv_file
        if self.success_sum is not None:
            result['SuccessSum'] = self.success_sum
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FailSum') is not None:
            self.fail_sum = m.get('FailSum')
        if m.get('Progress') is not None:
            self.progress = m.get('Progress')
        if m.get('ResultCsvFile') is not None:
            self.result_csv_file = m.get('ResultCsvFile')
        if m.get('SuccessSum') is not None:
            self.success_sum = m.get('SuccessSum')
        return self


class CheckBindLicenseDeviceProgressResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: CheckBindLicenseDeviceProgressResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = CheckBindLicenseDeviceProgressResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CheckBindLicenseDeviceProgressResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CheckBindLicenseDeviceProgressResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CheckBindLicenseDeviceProgressResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ClearDeviceDesiredPropertyRequest(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        identifies: List[str] = None,
        iot_id: str = None,
        iot_instance_id: str = None,
        product_key: str = None,
    ):
        # The DeviceName of the device.
        # 
        # >  If you specify a value for this parameter, you must configure the **ProductKey** parameter.
        self.device_name = device_name
        self.identifies = identifies
        # The ID of the device. The ID is a unique identifier that is issued by IoT Platform to the device.
        # 
        # >  The IotId parameter specifies a globally unique identifier (GUID) for the device. The value of the **IotId** parameter is equivalent to a combination of the values of the **ProductKey** and **DeviceName** parameters. If you specify a value for the IotId parameter, you do not need to configure the **ProductKey** or **DeviceName** parameter. If you specify values for the **IotId**, **ProductKey**, and **DeviceName** parameters, the value of the **IotId** parameter takes precedence.
        self.iot_id = iot_id
        # The ID of the instance. You can view the ID of the instance on the **Overview** page in the IoT Platform console.****\
        # 
        # >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.****\
        # >*   If no **Overview** page or **ID** is generated for your instance, you do not need to configure this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The **ProductKey** of the product to which the device belongs.
        # 
        # >  If you specify a value for this parameter, you must configure the **DeviceName** parameter.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.identifies is not None:
            result['Identifies'] = self.identifies
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('Identifies') is not None:
            self.identifies = m.get('Identifies')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class ClearDeviceDesiredPropertyResponseBodyData(TeaModel):
    def __init__(
        self,
        versions: str = None,
    ):
        # The latest version of the desired values of the properties after you call this operation to delete the specified desired property values.
        self.versions = versions

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.versions is not None:
            result['Versions'] = self.versions
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Versions') is not None:
            self.versions = m.get('Versions')
        return self


class ClearDeviceDesiredPropertyResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ClearDeviceDesiredPropertyResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see the "**Error codes**" section of this topic.
        self.code = code
        # The data returned if the call is successful.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful. Valid values:
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ClearDeviceDesiredPropertyResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ClearDeviceDesiredPropertyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ClearDeviceDesiredPropertyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ClearDeviceDesiredPropertyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ClearEdgeInstanceDriverConfigsRequest(TeaModel):
    def __init__(
        self,
        driver_id: str = None,
        instance_id: str = None,
        iot_instance_id: str = None,
    ):
        # The ID of the driver. To obtain the driver ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Drivers** page, move the pointer over the name of the driver whose configurations you want to delete and obtain the driver ID.
        # 
        # You can also call the [QueryEdgeDriver](~~155776~~) operation to query the driver ID.
        self.driver_id = driver_id
        # The ID of the edge instance. To obtain the instance ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Edge Instances** page, move the pointer over the name of the edge instance that uses the driver and obtain the instance ID.
        # 
        # You can also call the [QueryEdgeInstance](~~135214~~) operation to query the instance ID.
        self.instance_id = instance_id
        # This parameter is not required for the public instance but required for your purchased instances.
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.driver_id is not None:
            result['DriverId'] = self.driver_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DriverId') is not None:
            self.driver_id = m.get('DriverId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class ClearEdgeInstanceDriverConfigsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The return code of the operation. A value of Success indicates that the call was successful. Other values indicate that specific errors occurred. For more information, see [Error codes](~~135200~~).
        self.code = code
        # The error message that is returned if the call failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful. A value of true indicates that the call was successful. A value of false indicates that the call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ClearEdgeInstanceDriverConfigsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ClearEdgeInstanceDriverConfigsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ClearEdgeInstanceDriverConfigsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CloseDeviceTunnelRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        tunnel_id: str = None,
    ):
        self.iot_instance_id = iot_instance_id
        self.tunnel_id = tunnel_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.tunnel_id is not None:
            result['TunnelId'] = self.tunnel_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('TunnelId') is not None:
            self.tunnel_id = m.get('TunnelId')
        return self


class CloseDeviceTunnelResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CloseDeviceTunnelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CloseDeviceTunnelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CloseDeviceTunnelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CloseEdgeInstanceDeploymentRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        iot_instance_id: str = None,
    ):
        # The ID of the edge instance. To obtain the instance ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Edge Instances** page, move the pointer over the name of the edge instance for which you want to stop deployment tasks and obtain the instance ID.
        # 
        # You can also call the [QueryEdgeInstance](~~135214~~) operation to query the instance ID.
        self.instance_id = instance_id
        # The ID of the Internet of Things (IoT) service instance. This parameter is not required for the public instance but required for Enterprise Edition instances.
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class CloseEdgeInstanceDeploymentResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The return code of the operation. A value of Success indicates that the call was successful. Other values indicate that specific errors occurred. For more information, see [Error codes](~~135200~~).
        self.code = code
        # The error message that is returned if the call failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful. A value of true indicates that the call was successful. A value of false indicates that the call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CloseEdgeInstanceDeploymentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CloseEdgeInstanceDeploymentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CloseEdgeInstanceDeploymentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ConfirmOTATaskRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        task_id: List[str] = None,
    ):
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class ConfirmOTATaskResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ConfirmOTATaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ConfirmOTATaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ConfirmOTATaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CopyThingModelRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        resource_group_id: str = None,
        source_model_version: str = None,
        source_product_key: str = None,
        target_product_key: str = None,
    ):
        # The ID of the instance. On the **Overview** page in the IoT Platform console, you can view the ID of the instance.
        # 
        # >*   If your instance has an ID, you must specify this parameter. Otherwise, the call fails.
        # >*   If the **Overview** page or instance ID is not displayed in the IoT Platform console, ignore this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The ID of the resource group.
        # 
        # >  You do not need to configure this parameter.
        self.resource_group_id = resource_group_id
        # The version of the TSL model that you want to copy.
        # 
        # You can call the [ListThingModelVersion](~~150318~~) operation to view the TSL model versions of a product.
        self.source_model_version = source_model_version
        # The ProductKey of the source product.
        # 
        # You can view the ProductKey on the Product Details page of the IoT Platform console. You can also obtain the ProductKey by calling the [QueryProductList](~~69271~~) operation.
        self.source_product_key = source_product_key
        # The ProductKey of the destination product.
        # 
        # You can view the ProductKey on the Product Details page of the IoT Platform console. You can also obtain the ProductKey by calling the [QueryProductList](~~69271~~) operation.
        self.target_product_key = target_product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.source_model_version is not None:
            result['SourceModelVersion'] = self.source_model_version
        if self.source_product_key is not None:
            result['SourceProductKey'] = self.source_product_key
        if self.target_product_key is not None:
            result['TargetProductKey'] = self.target_product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('SourceModelVersion') is not None:
            self.source_model_version = m.get('SourceModelVersion')
        if m.get('SourceProductKey') is not None:
            self.source_product_key = m.get('SourceProductKey')
        if m.get('TargetProductKey') is not None:
            self.target_product_key = m.get('TargetProductKey')
        return self


class CopyThingModelResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CopyThingModelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CopyThingModelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CopyThingModelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CopyThingModelAsyncRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        source_model_version: str = None,
        source_product_key: str = None,
        target_product_key: str = None,
    ):
        self.iot_instance_id = iot_instance_id
        self.source_model_version = source_model_version
        self.source_product_key = source_product_key
        self.target_product_key = target_product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.source_model_version is not None:
            result['SourceModelVersion'] = self.source_model_version
        if self.source_product_key is not None:
            result['SourceProductKey'] = self.source_product_key
        if self.target_product_key is not None:
            result['TargetProductKey'] = self.target_product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('SourceModelVersion') is not None:
            self.source_model_version = m.get('SourceModelVersion')
        if m.get('SourceProductKey') is not None:
            self.source_product_key = m.get('SourceProductKey')
        if m.get('TargetProductKey') is not None:
            self.target_product_key = m.get('TargetProductKey')
        return self


class CopyThingModelAsyncResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CopyThingModelAsyncResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CopyThingModelAsyncResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CopyThingModelAsyncResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CountSpeechBroadcastHourRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        query_date_time_hour: str = None,
        share_task_code: str = None,
    ):
        # The instance ID. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
        # 
        # >  If your instance has an ID, you must specify this parameter. Otherwise, the request fails. If no Overview page exists or no instance ID is displayed, you do not need to specify this parameter.
        # 
        # For more information, see the [Overview](~~356505~~) topic of IoT instances.
        self.iot_instance_id = iot_instance_id
        # The end time of the hour in which you want to query the number of broadcasted speeches. Example: 2020090919, which indicates 19:00 on September 9, 2020.
        self.query_date_time_hour = query_date_time_hour
        # The code that is used to share the speeches.
        # 
        # You can obtain the **code** on the **Shared Corpus Management** page of **Speech Sending Voice Broadcasting Service**.
        self.share_task_code = share_task_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.query_date_time_hour is not None:
            result['QueryDateTimeHour'] = self.query_date_time_hour
        if self.share_task_code is not None:
            result['ShareTaskCode'] = self.share_task_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('QueryDateTimeHour') is not None:
            self.query_date_time_hour = m.get('QueryDateTimeHour')
        if m.get('ShareTaskCode') is not None:
            self.share_task_code = m.get('ShareTaskCode')
        return self


class CountSpeechBroadcastHourResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: int = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The number of shared speeches that were broadcasted in the specific hour.
        self.data = data
        # The error message returned if the request fails.
        self.error_message = error_message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CountSpeechBroadcastHourResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CountSpeechBroadcastHourResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CountSpeechBroadcastHourResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateConsumerGroupRequest(TeaModel):
    def __init__(
        self,
        group_name: str = None,
        iot_instance_id: str = None,
    ):
        # The name of the consumer group. The name must be 4 to 30 characters in length and can contain letters, digits, and underscores (\_).
        self.group_name = group_name
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class CreateConsumerGroupResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        group_id: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the consumer group.
        self.group_id = group_id
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateConsumerGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateConsumerGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateConsumerGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateConsumerGroupSubscribeRelationRequest(TeaModel):
    def __init__(
        self,
        consumer_group_id: str = None,
        iot_instance_id: str = None,
        product_key: str = None,
    ):
        # The ID of the consumer group. After you call the [CreateConsumerGroup](~~170388~~) operation to create a consumer group, the consumer group ID is returned. You can call the [QueryConsumerGroupList](~~170419~~) operation to query the consumer group ID by group name. You can also go to the IoT Platform console,and choose **Rules** > **Server-side Subscription** > **Consumer Groups** to view the consumer group ID.
        self.consumer_group_id = consumer_group_id
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The **ProductKey** of the product that is specified for the subscription.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.consumer_group_id is not None:
            result['ConsumerGroupId'] = self.consumer_group_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConsumerGroupId') is not None:
            self.consumer_group_id = m.get('ConsumerGroupId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class CreateConsumerGroupSubscribeRelationResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateConsumerGroupSubscribeRelationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateConsumerGroupSubscribeRelationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateConsumerGroupSubscribeRelationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDataAPIServiceRequestRequestParam(TeaModel):
    def __init__(
        self,
        desc: str = None,
        example: str = None,
        name: str = None,
        required: bool = None,
        type: str = None,
    ):
        self.desc = desc
        self.example = example
        self.name = name
        self.required = required
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desc is not None:
            result['Desc'] = self.desc
        if self.example is not None:
            result['Example'] = self.example
        if self.name is not None:
            result['Name'] = self.name
        if self.required is not None:
            result['Required'] = self.required
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Desc') is not None:
            self.desc = m.get('Desc')
        if m.get('Example') is not None:
            self.example = m.get('Example')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Required') is not None:
            self.required = m.get('Required')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateDataAPIServiceRequestResponseParam(TeaModel):
    def __init__(
        self,
        desc: str = None,
        example: str = None,
        name: str = None,
        required: bool = None,
        type: str = None,
    ):
        self.desc = desc
        self.example = example
        self.name = name
        self.required = required
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desc is not None:
            result['Desc'] = self.desc
        if self.example is not None:
            result['Example'] = self.example
        if self.name is not None:
            result['Name'] = self.name
        if self.required is not None:
            result['Required'] = self.required
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Desc') is not None:
            self.desc = m.get('Desc')
        if m.get('Example') is not None:
            self.example = m.get('Example')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Required') is not None:
            self.required = m.get('Required')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateDataAPIServiceRequest(TeaModel):
    def __init__(
        self,
        api_path: str = None,
        desc: str = None,
        display_name: str = None,
        iot_instance_id: str = None,
        origin_sql: str = None,
        request_param: List[CreateDataAPIServiceRequestRequestParam] = None,
        response_param: List[CreateDataAPIServiceRequestResponseParam] = None,
        template_sql: str = None,
    ):
        self.api_path = api_path
        self.desc = desc
        self.display_name = display_name
        self.iot_instance_id = iot_instance_id
        self.origin_sql = origin_sql
        self.request_param = request_param
        self.response_param = response_param
        self.template_sql = template_sql

    def validate(self):
        if self.request_param:
            for k in self.request_param:
                if k:
                    k.validate()
        if self.response_param:
            for k in self.response_param:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.api_path is not None:
            result['ApiPath'] = self.api_path
        if self.desc is not None:
            result['Desc'] = self.desc
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.origin_sql is not None:
            result['OriginSql'] = self.origin_sql
        result['RequestParam'] = []
        if self.request_param is not None:
            for k in self.request_param:
                result['RequestParam'].append(k.to_map() if k else None)
        result['ResponseParam'] = []
        if self.response_param is not None:
            for k in self.response_param:
                result['ResponseParam'].append(k.to_map() if k else None)
        if self.template_sql is not None:
            result['TemplateSql'] = self.template_sql
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApiPath') is not None:
            self.api_path = m.get('ApiPath')
        if m.get('Desc') is not None:
            self.desc = m.get('Desc')
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('OriginSql') is not None:
            self.origin_sql = m.get('OriginSql')
        self.request_param = []
        if m.get('RequestParam') is not None:
            for k in m.get('RequestParam'):
                temp_model = CreateDataAPIServiceRequestRequestParam()
                self.request_param.append(temp_model.from_map(k))
        self.response_param = []
        if m.get('ResponseParam') is not None:
            for k in m.get('ResponseParam'):
                temp_model = CreateDataAPIServiceRequestResponseParam()
                self.response_param.append(temp_model.from_map(k))
        if m.get('TemplateSql') is not None:
            self.template_sql = m.get('TemplateSql')
        return self


class CreateDataAPIServiceResponseBodyData(TeaModel):
    def __init__(
        self,
        api_srn: str = None,
        create_time: int = None,
        last_update_time: int = None,
    ):
        self.api_srn = api_srn
        self.create_time = create_time
        self.last_update_time = last_update_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.api_srn is not None:
            result['ApiSrn'] = self.api_srn
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.last_update_time is not None:
            result['LastUpdateTime'] = self.last_update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApiSrn') is not None:
            self.api_srn = m.get('ApiSrn')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('LastUpdateTime') is not None:
            self.last_update_time = m.get('LastUpdateTime')
        return self


class CreateDataAPIServiceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: CreateDataAPIServiceResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = CreateDataAPIServiceResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateDataAPIServiceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateDataAPIServiceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDataAPIServiceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDataSourceItemRequest(TeaModel):
    def __init__(
        self,
        data_source_id: int = None,
        device_name: str = None,
        iot_instance_id: str = None,
        product_key: str = None,
        scope_type: str = None,
        topic: str = None,
    ):
        self.data_source_id = data_source_id
        self.device_name = device_name
        # The instance ID. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >  If your instance has an ID, you must specify this parameter. Otherwise, the request fails. If no Overview page exists or no instance ID is displayed, you do not need to specify this parameter.
        # 
        # For more information, see the [Overview](~~356505~~) topic of IoT instances.
        self.iot_instance_id = iot_instance_id
        self.product_key = product_key
        self.scope_type = scope_type
        # The topic that you want to add to the data source in the rules engine. Format: `/${productKey}/${deviceName}/topicShortName`. `${productKey}` specifies the **ProductKey** of the product to which a device belongs. `${deviceName}` specifies the name of the device. `topicShortName` specifies the custom name of the topic.
        # 
        # *   Basic communication topics or Thing Specification Language (TSL) communication topics are in the `/${productKey}/${deviceName}/topicShortName` format. You can replace `${deviceName}` with the plus sign (`+`) wildcard character. The wildcard character specifies that the topic applies to all devices in the product. Valid values of `topicShortName`:
        # 
        #     *   `/thing/event/property/post`: submits the property data of a device.
        #     *   `/thing/event/${tsl.event.identifier}/post`: submits the event data of a device. `${tsl.event.identifier}` specifies the identifier of an event in the TSL model.
        #     *   `/thing/lifecycle`: submits device lifecycle changes.
        #     *   `/thing/downlink/reply/message`: sends a response to a request from IoT Platform.
        #     *   `/thing/list/found`: submits data when a gateway detects a new sub-device.
        #     *   `/thing/topo/lifecycle`: submits device topology changes.
        #     *   `/thing/event/property/history/post`: submits the historical property data of a device.
        #     *   `/thing/event/${tsl.event.identifier}/post`: submits the historical event data of a device. `${tsl.event.identifier}` specifies the identifier of an event in the TSL model.
        #     *   `/ota/upgrade`: submits the over-the-air (OTA) update status.
        #     *   `/ota/version/post`: submits OTA module versions.
        #     *   `/thing/deviceinfo/update`: submits device tag changes.
        # 
        #     `/${productKey}/${packageId}/${jobId}/ota/job/status`: submits the status of each OTA update batch. This topic is a basic communication topic. `${packageId}` specifies the ID of the update package. `${jobId}` specifies the ID of the update batch.
        # 
        # *   Custom topics are in the `/${productKey}/${deviceName}/user/#` format. Example: `/${productKey}/${deviceName}/user/get`.
        # 
        #     You can call the [QueryProductTopic](~~69647~~) operation to view all custom topics of a product.
        # 
        #     When you specify a custom topic, you can use the plus sign (`+`) and number sign (`#`) wildcard characters.
        # 
        #     *   You can replace `${deviceName}` with the plus sign (`+`) wildcard character. The wildcard character specifies that the topic applies to all devices in the product.
        #     *   You can replace the fields that follow ${deviceName} with `/user/#`. The number sign (`#`) wildcard character specifies that the topic applies to all fields that follow `/user`.
        # 
        # *   Topics that are used to submit device status changes are in the `/as/mqtt/status/${productKey}/${deviceName}` format.
        # 
        # You can use the plus sign (`+`) wildcard character to specify that the status changes of all devices in the product are submitted.
        # 
        # For more information about how to use wildcard characters, see the "Custom topics with wildcard characters" section in [Use custom topics](~~85539~~).
        # 
        # For more information about the data formats of topics, see [Data formats](~~73736~~).
        # 
        # > You can add only the following topics to the data source in the rules engine for MQTT gateways, devices of MQTT gateways, and products and devices that use the open source MQTT protocol: custom topics, topics that are used to submit device status changes, and topics that are used to submit device lifecycle changes. For more information about custom topics, see the "Messaging" topic. If you set this parameter to a custom topic, you must specify ScopeType and ProductKey. If you set ScopeType to DEVICE, you must specify DeviceName.
        self.topic = topic

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_source_id is not None:
            result['DataSourceId'] = self.data_source_id
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.scope_type is not None:
            result['ScopeType'] = self.scope_type
        if self.topic is not None:
            result['Topic'] = self.topic
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataSourceId') is not None:
            self.data_source_id = m.get('DataSourceId')
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('ScopeType') is not None:
            self.scope_type = m.get('ScopeType')
        if m.get('Topic') is not None:
            self.topic = m.get('Topic')
        return self


class CreateDataSourceItemResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateDataSourceItemResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateDataSourceItemResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDataSourceItemResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDestinationRequest(TeaModel):
    def __init__(
        self,
        configuration: str = None,
        description: str = None,
        iot_instance_id: str = None,
        name: str = None,
        type: str = None,
    ):
        self.configuration = configuration
        self.description = description
        self.iot_instance_id = iot_instance_id
        self.name = name
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.configuration is not None:
            result['Configuration'] = self.configuration
        if self.description is not None:
            result['Description'] = self.description
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Configuration') is not None:
            self.configuration = m.get('Configuration')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateDestinationResponseBodyDestination(TeaModel):
    def __init__(
        self,
        configuration: str = None,
        destination_id: int = None,
        is_failover: bool = None,
        name: str = None,
        type: str = None,
        utc_created: str = None,
    ):
        self.configuration = configuration
        self.destination_id = destination_id
        self.is_failover = is_failover
        self.name = name
        self.type = type
        self.utc_created = utc_created

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.configuration is not None:
            result['Configuration'] = self.configuration
        if self.destination_id is not None:
            result['DestinationId'] = self.destination_id
        if self.is_failover is not None:
            result['IsFailover'] = self.is_failover
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        if self.utc_created is not None:
            result['UtcCreated'] = self.utc_created
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Configuration') is not None:
            self.configuration = m.get('Configuration')
        if m.get('DestinationId') is not None:
            self.destination_id = m.get('DestinationId')
        if m.get('IsFailover') is not None:
            self.is_failover = m.get('IsFailover')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UtcCreated') is not None:
            self.utc_created = m.get('UtcCreated')
        return self


class CreateDestinationResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        destination: CreateDestinationResponseBodyDestination = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.destination = destination
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.destination:
            self.destination.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.destination is not None:
            result['Destination'] = self.destination.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Destination') is not None:
            temp_model = CreateDestinationResponseBodyDestination()
            self.destination = temp_model.from_map(m['Destination'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateDestinationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateDestinationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDestinationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDeviceDistributeJobRequestTargetInstanceConfig(TeaModel):
    def __init__(
        self,
        target_instance_id: str = None,
    ):
        # The configurations of the destination instance to which the device is distributed. For more information about instance IDs, see the description of the **SourceInstanceId** parameter.
        # 
        # *   If the value of the **Strategy** parameter is **1**, you can specify multiple instance IDs.
        # *   If the value of the **Strategy** parameter is **0**, you can specify only one instance ID.
        self.target_instance_id = target_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.target_instance_id is not None:
            result['TargetInstanceId'] = self.target_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TargetInstanceId') is not None:
            self.target_instance_id = m.get('TargetInstanceId')
        return self


class CreateDeviceDistributeJobRequest(TeaModel):
    def __init__(
        self,
        device_name: List[str] = None,
        product_key: str = None,
        source_instance_id: str = None,
        strategy: int = None,
        target_aliyun_id: str = None,
        target_instance_config: List[CreateDeviceDistributeJobRequestTargetInstanceConfig] = None,
        target_uid: str = None,
    ):
        # The names of the devices to be distributed. You can specify a maximum of 10,000 device names.
        self.device_name = device_name
        # The **ProductKey** of the product to which the device belongs.
        self.product_key = product_key
        # The ID of the source instance to which the device belongs.
        # 
        # *   The IDs of public instances in different regions:
        # 
        #     *   China (Shanghai): iotx-oxssharez200.
        #     *   Japan (Tokyo): iotx-oxssharez300.
        #     *   Singapore (Singapore): iotx-oxssharez400.
        #     *   US (Silicon Valley): iotx-oxssharez500.
        #     *   US (Virginia): iotx-oxssharez600.
        #     *   Germany (Frankfurt): iotx-oxssharez700.
        # 
        # *   The IDs of Enterprise Edition instances:
        # 
        #     1\. Log on to the IoT Platform console. Select a region from the drop-down list in the upper-left corner of the top navigation bar.
        # 
        #     2\. On the **Overview** page, click the instance name. On the **Instance Details** page, view the instance ID in the **Basic Information** section.
        self.source_instance_id = source_instance_id
        # The distribution policy. Default value: 0.
        # 
        # *   **0**: distributes devices to instances in a specified region.
        # *   **1**: configures instance IDs in multiple regions and distributes devices to the nearest regions based on the IP addresses of the devices.
        self.strategy = strategy
        # The Alibaba Cloud account to which the device belongs. You can log on to the IoT Platform console, click the profile picture, and then view the account ID on the **Security Settings** page.
        # 
        # The **TargetUid** and **TargetAliyunId** parameters cannot be left empty at the same time.
        self.target_aliyun_id = target_aliyun_id
        self.target_instance_config = target_instance_config
        # The ID of the Alibaba Cloud account to which the device belongs. You can log on to the IoT Platform console, click the profile picture, and then view the account ID on the **Security Settings** page.
        # 
        # The **TargetUid** and **TargetAliyunId** parameters cannot be left empty at the same time.
        self.target_uid = target_uid

    def validate(self):
        if self.target_instance_config:
            for k in self.target_instance_config:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.source_instance_id is not None:
            result['SourceInstanceId'] = self.source_instance_id
        if self.strategy is not None:
            result['Strategy'] = self.strategy
        if self.target_aliyun_id is not None:
            result['TargetAliyunId'] = self.target_aliyun_id
        result['TargetInstanceConfig'] = []
        if self.target_instance_config is not None:
            for k in self.target_instance_config:
                result['TargetInstanceConfig'].append(k.to_map() if k else None)
        if self.target_uid is not None:
            result['TargetUid'] = self.target_uid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('SourceInstanceId') is not None:
            self.source_instance_id = m.get('SourceInstanceId')
        if m.get('Strategy') is not None:
            self.strategy = m.get('Strategy')
        if m.get('TargetAliyunId') is not None:
            self.target_aliyun_id = m.get('TargetAliyunId')
        self.target_instance_config = []
        if m.get('TargetInstanceConfig') is not None:
            for k in m.get('TargetInstanceConfig'):
                temp_model = CreateDeviceDistributeJobRequestTargetInstanceConfig()
                self.target_instance_config.append(temp_model.from_map(k))
        if m.get('TargetUid') is not None:
            self.target_uid = m.get('TargetUid')
        return self


class CreateDeviceDistributeJobResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        job_id: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The task ID returned if the call is successful. The ID globally identifies the task.
        self.job_id = job_id
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateDeviceDistributeJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateDeviceDistributeJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDeviceDistributeJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDeviceDynamicGroupRequest(TeaModel):
    def __init__(
        self,
        dynamic_group_expression: str = None,
        group_desc: str = None,
        group_name: str = None,
        iot_instance_id: str = None,
    ):
        self.dynamic_group_expression = dynamic_group_expression
        self.group_desc = group_desc
        self.group_name = group_name
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dynamic_group_expression is not None:
            result['DynamicGroupExpression'] = self.dynamic_group_expression
        if self.group_desc is not None:
            result['GroupDesc'] = self.group_desc
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DynamicGroupExpression') is not None:
            self.dynamic_group_expression = m.get('DynamicGroupExpression')
        if m.get('GroupDesc') is not None:
            self.group_desc = m.get('GroupDesc')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class CreateDeviceDynamicGroupResponseBodyData(TeaModel):
    def __init__(
        self,
        dynamic_group_expression: str = None,
        group_desc: str = None,
        group_id: str = None,
        group_name: str = None,
        utc_create: str = None,
    ):
        self.dynamic_group_expression = dynamic_group_expression
        self.group_desc = group_desc
        self.group_id = group_id
        self.group_name = group_name
        self.utc_create = utc_create

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dynamic_group_expression is not None:
            result['DynamicGroupExpression'] = self.dynamic_group_expression
        if self.group_desc is not None:
            result['GroupDesc'] = self.group_desc
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.utc_create is not None:
            result['UtcCreate'] = self.utc_create
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DynamicGroupExpression') is not None:
            self.dynamic_group_expression = m.get('DynamicGroupExpression')
        if m.get('GroupDesc') is not None:
            self.group_desc = m.get('GroupDesc')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('UtcCreate') is not None:
            self.utc_create = m.get('UtcCreate')
        return self


class CreateDeviceDynamicGroupResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: CreateDeviceDynamicGroupResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = CreateDeviceDynamicGroupResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateDeviceDynamicGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateDeviceDynamicGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDeviceDynamicGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDeviceGroupRequest(TeaModel):
    def __init__(
        self,
        group_desc: str = None,
        group_name: str = None,
        iot_instance_id: str = None,
        super_group_id: str = None,
    ):
        # The description of the group. The description must be 1 to 100 characters in length.
        self.group_desc = group_desc
        # The name of the group. The alias must be 4 to 30 characters in length, and can contain letters, digits, and underscores (\_).
        self.group_name = group_name
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # 
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The ID of the parent group.
        # 
        # If you need to create a first-level group, do not specify this parameter.
        self.super_group_id = super_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_desc is not None:
            result['GroupDesc'] = self.group_desc
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.super_group_id is not None:
            result['SuperGroupId'] = self.super_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupDesc') is not None:
            self.group_desc = m.get('GroupDesc')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('SuperGroupId') is not None:
            self.super_group_id = m.get('SuperGroupId')
        return self


class CreateDeviceGroupResponseBodyData(TeaModel):
    def __init__(
        self,
        group_desc: str = None,
        group_id: str = None,
        group_name: str = None,
        utc_create: str = None,
    ):
        # The description of each group.
        self.group_desc = group_desc
        # The ID of the group. The ID is the globally unique identifier (GUID) that the system generates for the group.
        self.group_id = group_id
        # The name of the group.
        self.group_name = group_name
        # The time when the group was created.
        self.utc_create = utc_create

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_desc is not None:
            result['GroupDesc'] = self.group_desc
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.utc_create is not None:
            result['UtcCreate'] = self.utc_create
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupDesc') is not None:
            self.group_desc = m.get('GroupDesc')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('UtcCreate') is not None:
            self.utc_create = m.get('UtcCreate')
        return self


class CreateDeviceGroupResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: CreateDeviceGroupResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The group information returned if the call succeeds.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = CreateDeviceGroupResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateDeviceGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateDeviceGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDeviceGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDeviceTunnelRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        device_name: str = None,
        iot_id: str = None,
        iot_instance_id: str = None,
        product_key: str = None,
        udi: str = None,
    ):
        self.description = description
        self.device_name = device_name
        self.iot_id = iot_id
        self.iot_instance_id = iot_instance_id
        self.product_key = product_key
        self.udi = udi

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.udi is not None:
            result['Udi'] = self.udi
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('Udi') is not None:
            self.udi = m.get('Udi')
        return self


class CreateDeviceTunnelResponseBodyData(TeaModel):
    def __init__(
        self,
        source_access_token: str = None,
        source_uri: str = None,
        tunnel_id: str = None,
    ):
        self.source_access_token = source_access_token
        self.source_uri = source_uri
        self.tunnel_id = tunnel_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.source_access_token is not None:
            result['SourceAccessToken'] = self.source_access_token
        if self.source_uri is not None:
            result['SourceURI'] = self.source_uri
        if self.tunnel_id is not None:
            result['TunnelId'] = self.tunnel_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SourceAccessToken') is not None:
            self.source_access_token = m.get('SourceAccessToken')
        if m.get('SourceURI') is not None:
            self.source_uri = m.get('SourceURI')
        if m.get('TunnelId') is not None:
            self.tunnel_id = m.get('TunnelId')
        return self


class CreateDeviceTunnelResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: CreateDeviceTunnelResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = CreateDeviceTunnelResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateDeviceTunnelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateDeviceTunnelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDeviceTunnelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDownloadDataJobRequest(TeaModel):
    def __init__(
        self,
        download_data_type: str = None,
        end_time: int = None,
        file_config: Dict[str, Any] = None,
        iot_instance_id: str = None,
        start_time: int = None,
        table_name: str = None,
    ):
        self.download_data_type = download_data_type
        self.end_time = end_time
        self.file_config = file_config
        self.iot_instance_id = iot_instance_id
        self.start_time = start_time
        self.table_name = table_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.download_data_type is not None:
            result['DownloadDataType'] = self.download_data_type
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.file_config is not None:
            result['FileConfig'] = self.file_config
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.table_name is not None:
            result['TableName'] = self.table_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DownloadDataType') is not None:
            self.download_data_type = m.get('DownloadDataType')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('FileConfig') is not None:
            self.file_config = m.get('FileConfig')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        return self


class CreateDownloadDataJobShrinkRequest(TeaModel):
    def __init__(
        self,
        download_data_type: str = None,
        end_time: int = None,
        file_config_shrink: str = None,
        iot_instance_id: str = None,
        start_time: int = None,
        table_name: str = None,
    ):
        self.download_data_type = download_data_type
        self.end_time = end_time
        self.file_config_shrink = file_config_shrink
        self.iot_instance_id = iot_instance_id
        self.start_time = start_time
        self.table_name = table_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.download_data_type is not None:
            result['DownloadDataType'] = self.download_data_type
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.file_config_shrink is not None:
            result['FileConfig'] = self.file_config_shrink
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.table_name is not None:
            result['TableName'] = self.table_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DownloadDataType') is not None:
            self.download_data_type = m.get('DownloadDataType')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('FileConfig') is not None:
            self.file_config_shrink = m.get('FileConfig')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        return self


class CreateDownloadDataJobResponseBodyData(TeaModel):
    def __init__(
        self,
        async_execute: bool = None,
        csv_file_name: str = None,
        csv_url: str = None,
        long_job_id: str = None,
        status: int = None,
    ):
        self.async_execute = async_execute
        self.csv_file_name = csv_file_name
        self.csv_url = csv_url
        self.long_job_id = long_job_id
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.async_execute is not None:
            result['AsyncExecute'] = self.async_execute
        if self.csv_file_name is not None:
            result['CsvFileName'] = self.csv_file_name
        if self.csv_url is not None:
            result['CsvUrl'] = self.csv_url
        if self.long_job_id is not None:
            result['LongJobId'] = self.long_job_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AsyncExecute') is not None:
            self.async_execute = m.get('AsyncExecute')
        if m.get('CsvFileName') is not None:
            self.csv_file_name = m.get('CsvFileName')
        if m.get('CsvUrl') is not None:
            self.csv_url = m.get('CsvUrl')
        if m.get('LongJobId') is not None:
            self.long_job_id = m.get('LongJobId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class CreateDownloadDataJobResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: CreateDownloadDataJobResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = CreateDownloadDataJobResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateDownloadDataJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateDownloadDataJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDownloadDataJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateEdgeDriverRequest(TeaModel):
    def __init__(
        self,
        cpu_arch: str = None,
        driver_name: str = None,
        driver_protocol: str = None,
        iot_instance_id: str = None,
        is_built_in: bool = None,
        runtime: str = None,
    ):
        # The CPU architecture that the driver supports. Valid values:
        # 
        # *   ARMv7
        # *   ARMv7-HF
        # *   AArch64
        # *   x86-64
        # *   x86
        self.cpu_arch = cpu_arch
        # The name of the driver to create. The name cannot exceed 20 characters in length and can contain only uppercase letters, lowercase letters, digits, and underscores (\_). It must start with a letter.
        self.driver_name = driver_name
        # The communications protocol that the driver uses. Valid values:
        # 
        # *   modbus: Modbus protocol
        # *   opc-ua: OPC UA protocol
        # *   customize: custom protocol
        self.driver_protocol = driver_protocol
        # The ID of the Internet of Things (IoT) service instance. This parameter is not required for public instances. However, this parameter is required for the instances that you have purchased.
        self.iot_instance_id = iot_instance_id
        # Specifies whether the driver is a built-in driver.
        # 
        # *   true: indicates that the driver is a built-in driver, that is, the driver code is pre-configured on the gateway device.
        # 
        # *   false: indicates that the driver is not a built-in driver and you must upload the driver code. Default value: false.
        # 
        # > If the driver is not a built-in driver, you must upload the driver code.
        self.is_built_in = is_built_in
        # The language in which the driver is programmed. Valid values:
        # 
        # *   nodejs8: Node.js v8
        # *   python3: Python v3.5
        # *   c: C
        self.runtime = runtime

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cpu_arch is not None:
            result['CpuArch'] = self.cpu_arch
        if self.driver_name is not None:
            result['DriverName'] = self.driver_name
        if self.driver_protocol is not None:
            result['DriverProtocol'] = self.driver_protocol
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.is_built_in is not None:
            result['IsBuiltIn'] = self.is_built_in
        if self.runtime is not None:
            result['Runtime'] = self.runtime
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CpuArch') is not None:
            self.cpu_arch = m.get('CpuArch')
        if m.get('DriverName') is not None:
            self.driver_name = m.get('DriverName')
        if m.get('DriverProtocol') is not None:
            self.driver_protocol = m.get('DriverProtocol')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('IsBuiltIn') is not None:
            self.is_built_in = m.get('IsBuiltIn')
        if m.get('Runtime') is not None:
            self.runtime = m.get('Runtime')
        return self


class CreateEdgeDriverResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        driver_id: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code. Success indicates that the call was successful. Other values indicate that specific errors occurred. For more information, see [Error codes](~~135200~~).
        self.code = code
        # The ID of the driver created.
        self.driver_id = driver_id
        # The error message returned if the call failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful. true indicates that the call was successful. false indicates that the call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.driver_id is not None:
            result['DriverId'] = self.driver_id
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('DriverId') is not None:
            self.driver_id = m.get('DriverId')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateEdgeDriverResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateEdgeDriverResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateEdgeDriverResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateEdgeDriverVersionRequest(TeaModel):
    def __init__(
        self,
        argument: str = None,
        config_check_rule: str = None,
        container_config: str = None,
        description: str = None,
        driver_config: str = None,
        driver_id: str = None,
        driver_version: str = None,
        edge_version: str = None,
        iot_instance_id: str = None,
        source_config: str = None,
    ):
        # The Java Virtual Machine (JVM) startup parameter.
        self.argument = argument
        # The rule for verifying configurations. Set this parameter to a JSON string in the following format:
        # 
        # `{"deviceConfig":{"required":false},"driverConfig":{"required":false}`
        # 
        # The JSON string contains the following parameters:
        # 
        # *   driverConfig: the rule for verifying the configuration of the driver when the driver is to be deployed in an edge instance.
        # *   deviceConfig: the rule for verifying the configurations of devices that use the driver when the driver is to be deployed in an edge instance.
        # 
        # `required`: A value of true indicates that the corresponding parameter is required. A value of false indicates that the corresponding parameter is optional.
        self.config_check_rule = config_check_rule
        # The configuration of the container where the driver runs. Set this parameter to a JSON string. For more information about parameters in the JSON string, see the following parameter description of **ContainerConfig**.
        self.container_config = container_config
        # The description of the driver. The description can be a maximum of 256 bytes in length.
        self.description = description
        # The configuration of the driver. Set this parameter to a JSON string in the following format:
        # 
        # `{"format":"JSON","content":"{}"}`
        # 
        # The JSON string contains the following parameters:
        # 
        # *   format: the format of the driver configuration. Valid values: KV (key-value pair), JSON (JSON string), and FILE (configuration file).
        # 
        # *   content: the content of the driver configuration. If you set the format parameter to KV or JSON, set this parameter to the configuration content of the driver. If you set the format parameter to FILE, set this parameter to the URL of the driver configuration file stored in OSS.
        # 
        # > To obtain the URL of the driver configuration file stored in OSS, call the [CreateOssPreSignedAddress](~~155858~~) operation.
        self.driver_config = driver_config
        # The ID of the driver. To obtain the driver ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Drivers** page, move the pointer over the name of the driver for which you want to create a driver version and obtain the driver ID.
        # 
        # You can also call the [QueryEdgeDriver](~~155776~~) operation to query the driver ID.
        self.driver_id = driver_id
        # The version number of the driver. The version number must be unique for the driver. The version number can be up to 64 characters in length and can contain letters, digits, underscores (\_), hyphens (-), and periods (.).
        self.driver_version = driver_version
        # The earliest version of Link IoT Edge that is supported by the driver. The driver can run on gateways of only this version and later. For example, if you set this parameter to 2.4.0, the driver can run on gateways of only version 2.4.0 and later.
        self.edge_version = edge_version
        # The ID of the Internet of Things (IoT) service instance. This parameter is not required for the public instance but required for Enterprise Edition instances.
        self.iot_instance_id = iot_instance_id
        self.source_config = source_config

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.argument is not None:
            result['Argument'] = self.argument
        if self.config_check_rule is not None:
            result['ConfigCheckRule'] = self.config_check_rule
        if self.container_config is not None:
            result['ContainerConfig'] = self.container_config
        if self.description is not None:
            result['Description'] = self.description
        if self.driver_config is not None:
            result['DriverConfig'] = self.driver_config
        if self.driver_id is not None:
            result['DriverId'] = self.driver_id
        if self.driver_version is not None:
            result['DriverVersion'] = self.driver_version
        if self.edge_version is not None:
            result['EdgeVersion'] = self.edge_version
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.source_config is not None:
            result['SourceConfig'] = self.source_config
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Argument') is not None:
            self.argument = m.get('Argument')
        if m.get('ConfigCheckRule') is not None:
            self.config_check_rule = m.get('ConfigCheckRule')
        if m.get('ContainerConfig') is not None:
            self.container_config = m.get('ContainerConfig')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DriverConfig') is not None:
            self.driver_config = m.get('DriverConfig')
        if m.get('DriverId') is not None:
            self.driver_id = m.get('DriverId')
        if m.get('DriverVersion') is not None:
            self.driver_version = m.get('DriverVersion')
        if m.get('EdgeVersion') is not None:
            self.edge_version = m.get('EdgeVersion')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('SourceConfig') is not None:
            self.source_config = m.get('SourceConfig')
        return self


class CreateEdgeDriverVersionResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The return code of the operation. A value of Success indicates that the call was successful. Other values indicate that specific errors occurred. For more information, see [Error codes](~~135200~~).
        self.code = code
        # The error message that is returned if the call failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful. A value of true indicates that the call was successful. A value of false indicates that the call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateEdgeDriverVersionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateEdgeDriverVersionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateEdgeDriverVersionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateEdgeInstanceRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        name: str = None,
        spec: int = None,
        tags: str = None,
    ):
        # The ID of the Internet of Things (IoT) service instance. This parameter is not required for public instances. However, this parameter is required for the instances that you have purchased.
        self.iot_instance_id = iot_instance_id
        # The name of the edge instance.
        # 
        # An instance name cannot exceed 20 characters in length and can contain uppercase letters, lowercase letters, digits, underscores (\_), and hyphens (-).
        self.name = name
        # The specification of the edge instance.
        # 
        # *   10: Lite Edition.
        # *   20: Standard Edition.
        # *   30: Pro Edition.
        # 
        # Default value: 20.
        self.spec = spec
        # The tags of the edge instance. Syntax of a tag: `key:value`. Multiple tags are separated with commas (,), for example, `k1:v1,k2:v2`.
        # 
        # *   Note the following limits on tag keys:
        # 
        #     *   Tag values cannot be left empty.
        #     *   Tag keys must be unique in the edge instance.
        #     *   Tag keys only support letters.
        #     *   Each tag key cannot exceed 20 characters in length.
        # 
        # *   Note the following limits on tag values:
        # 
        #     *   Tag values cannot be left empty.
        #     *   A tag value can contain uppercase letters, lowercase letters, digits, underscores (\_), and hyphens (-).
        #     *   Each tag value cannot exceed 20 characters in length.
        self.tags = tags

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.name is not None:
            result['Name'] = self.name
        if self.spec is not None:
            result['Spec'] = self.spec
        if self.tags is not None:
            result['Tags'] = self.tags
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Spec') is not None:
            self.spec = m.get('Spec')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        return self


class CreateEdgeInstanceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        instance_id: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code. Success indicates that the call was successful. Other values indicate that specific errors occurred. For more information, see [Error codes](~~135200~~).
        self.code = code
        # The error message returned if the call failed.
        self.error_message = error_message
        # The ID of the edge instance.
        self.instance_id = instance_id
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful. true: indicates that the call was successful. false: indicates that the call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateEdgeInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateEdgeInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateEdgeInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateEdgeInstanceChannelRequestConfigs(TeaModel):
    def __init__(
        self,
        content: str = None,
        format: str = None,
        key: str = None,
    ):
        self.content = content
        self.format = format
        self.key = key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.format is not None:
            result['Format'] = self.format
        if self.key is not None:
            result['Key'] = self.key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('Format') is not None:
            self.format = m.get('Format')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        return self


class CreateEdgeInstanceChannelRequest(TeaModel):
    def __init__(
        self,
        channel_name: str = None,
        configs: List[CreateEdgeInstanceChannelRequestConfigs] = None,
        driver_id: str = None,
        instance_id: str = None,
        iot_instance_id: str = None,
    ):
        self.channel_name = channel_name
        self.configs = configs
        self.driver_id = driver_id
        self.instance_id = instance_id
        self.iot_instance_id = iot_instance_id

    def validate(self):
        if self.configs:
            for k in self.configs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_name is not None:
            result['ChannelName'] = self.channel_name
        result['Configs'] = []
        if self.configs is not None:
            for k in self.configs:
                result['Configs'].append(k.to_map() if k else None)
        if self.driver_id is not None:
            result['DriverId'] = self.driver_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelName') is not None:
            self.channel_name = m.get('ChannelName')
        self.configs = []
        if m.get('Configs') is not None:
            for k in m.get('Configs'):
                temp_model = CreateEdgeInstanceChannelRequestConfigs()
                self.configs.append(temp_model.from_map(k))
        if m.get('DriverId') is not None:
            self.driver_id = m.get('DriverId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class CreateEdgeInstanceChannelResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateEdgeInstanceChannelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateEdgeInstanceChannelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateEdgeInstanceChannelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateEdgeInstanceDeploymentRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        iot_instance_id: str = None,
        type: str = None,
    ):
        # The ID of the edge instance. To obtain the instance ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Edge Instances** page, move the pointer over the name of the edge instance for which you want to create a deployment task and obtain the instance ID.
        # 
        # You can also call the [QueryEdgeInstance](~~135214~~) operation to query the instance ID.
        self.instance_id = instance_id
        # The ID of the Internet of Things (IoT) service instance. This parameter is not required for the public instance but required for Enterprise Edition instances.
        self.iot_instance_id = iot_instance_id
        # The type of the deployment task.
        # 
        # *   deploy: deploys the edge instance.
        # *   reset: resets the edge instance.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateEdgeInstanceDeploymentResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        deployment_id: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The return code of the operation. A value of Success indicates that the call was successful. Other values indicate that specific errors occurred. For more information, see [Error codes](~~135200~~).
        self.code = code
        # The deployment task ID that is returned if the call was successful.
        self.deployment_id = deployment_id
        # The error message that is returned if the call failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful. A value of true indicates that the call was successful. A value of false indicates that the call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.deployment_id is not None:
            result['DeploymentId'] = self.deployment_id
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('DeploymentId') is not None:
            self.deployment_id = m.get('DeploymentId')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateEdgeInstanceDeploymentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateEdgeInstanceDeploymentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateEdgeInstanceDeploymentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateEdgeInstanceMessageRoutingRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        iot_instance_id: str = None,
        name: str = None,
        source_data: str = None,
        source_type: str = None,
        target_data: str = None,
        target_iot_hub_qos: int = None,
        target_type: str = None,
        topic_filter: str = None,
    ):
        self.instance_id = instance_id
        self.iot_instance_id = iot_instance_id
        self.name = name
        self.source_data = source_data
        self.source_type = source_type
        self.target_data = target_data
        self.target_iot_hub_qos = target_iot_hub_qos
        self.target_type = target_type
        self.topic_filter = topic_filter

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.name is not None:
            result['Name'] = self.name
        if self.source_data is not None:
            result['SourceData'] = self.source_data
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        if self.target_data is not None:
            result['TargetData'] = self.target_data
        if self.target_iot_hub_qos is not None:
            result['TargetIotHubQos'] = self.target_iot_hub_qos
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        if self.topic_filter is not None:
            result['TopicFilter'] = self.topic_filter
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('SourceData') is not None:
            self.source_data = m.get('SourceData')
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        if m.get('TargetData') is not None:
            self.target_data = m.get('TargetData')
        if m.get('TargetIotHubQos') is not None:
            self.target_iot_hub_qos = m.get('TargetIotHubQos')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        if m.get('TopicFilter') is not None:
            self.topic_filter = m.get('TopicFilter')
        return self


class CreateEdgeInstanceMessageRoutingResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        route_id: int = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.route_id = route_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.route_id is not None:
            result['RouteId'] = self.route_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RouteId') is not None:
            self.route_id = m.get('RouteId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateEdgeInstanceMessageRoutingResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateEdgeInstanceMessageRoutingResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateEdgeInstanceMessageRoutingResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateEdgeOssPreSignedAddressRequest(TeaModel):
    def __init__(
        self,
        file_name: str = None,
        instance_id: str = None,
        iot_instance_id: str = None,
        resource_id: str = None,
        resource_version: str = None,
        type: str = None,
    ):
        # The name of the object whose URL is to be obtained. The format is `<File name>.<File name extension>`.
        self.file_name = file_name
        # The ID of the edge instance. To obtain the instance ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Edge Instances** page, move the pointer over the name of the edge instance that uses the driver and obtain the instance ID.
        # 
        # You can also call the [QueryEdgeInstance](~~135214~~) operation to query the instance ID.
        # 
        # >  When the **Type** parameter is set to **INSTANCE_DRIVER_VERSION_CONFIG**, this parameter is required.
        self.instance_id = instance_id
        # The ID of the Internet of Things (IoT) service instance. This parameter is not required for the public instance but required for Enterprise Edition instances.
        self.iot_instance_id = iot_instance_id
        # The ID of the resource for which the object URL is to be obtained. Only driver resources are supported. Set this parameter to the ID of the corresponding driver.
        # 
        # To obtain the driver ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Drivers** page, move the pointer over the name of the driver for which the object URL you want to obtain and obtain the driver ID. You can also call the [QueryEdgeDriver](~~155776~~) operation to query the driver ID.
        self.resource_id = resource_id
        # The version number of the resource. Only driver resources are supported. Set this parameter to the version number of the corresponding driver.
        self.resource_version = resource_version
        # The content type of the object. Valid values:
        # 
        # *   DRIVER_VERSION_CONTENT: the code of a specific driver version.
        # *   DRIVER_VERSION_DEFAULT_CONFIG: the default configuration of a specific driver version.
        # *   INSTANCE_DRIVER_VERSION_CONFIG: the configuration of a specific driver version that is used in an edge instance.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.resource_version is not None:
            result['ResourceVersion'] = self.resource_version
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('ResourceVersion') is not None:
            self.resource_version = m.get('ResourceVersion')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateEdgeOssPreSignedAddressResponseBodyData(TeaModel):
    def __init__(
        self,
        oss_address: str = None,
        oss_pre_signed_address: str = None,
    ):
        # The URL of the OSS object.
        self.oss_address = oss_address
        # The pre-signed URL of the OSS object. For more information, see [OSS documentation](~~32016~~).
        self.oss_pre_signed_address = oss_pre_signed_address

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.oss_address is not None:
            result['OssAddress'] = self.oss_address
        if self.oss_pre_signed_address is not None:
            result['OssPreSignedAddress'] = self.oss_pre_signed_address
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OssAddress') is not None:
            self.oss_address = m.get('OssAddress')
        if m.get('OssPreSignedAddress') is not None:
            self.oss_pre_signed_address = m.get('OssPreSignedAddress')
        return self


class CreateEdgeOssPreSignedAddressResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: CreateEdgeOssPreSignedAddressResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The return code of the operation. A value of Success indicates that the call was successful. Other values indicate that specific errors occurred. For more information, see [Error codes](~~135200~~).
        self.code = code
        # The data that is returned if the call was successful.
        self.data = data
        # The error message that is returned if the call failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful. A value of true indicates that the call was successful. A value of false indicates that the call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = CreateEdgeOssPreSignedAddressResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateEdgeOssPreSignedAddressResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateEdgeOssPreSignedAddressResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateEdgeOssPreSignedAddressResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateJobRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        iot_instance_id: str = None,
        job_document: str = None,
        job_file: Dict[str, Any] = None,
        job_name: str = None,
        rollout_config: Dict[str, Any] = None,
        scheduled_time: int = None,
        target_config: Dict[str, Any] = None,
        timeout_config: Dict[str, Any] = None,
        type: str = None,
    ):
        self.description = description
        self.iot_instance_id = iot_instance_id
        self.job_document = job_document
        self.job_file = job_file
        self.job_name = job_name
        self.rollout_config = rollout_config
        self.scheduled_time = scheduled_time
        self.target_config = target_config
        self.timeout_config = timeout_config
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.job_document is not None:
            result['JobDocument'] = self.job_document
        if self.job_file is not None:
            result['JobFile'] = self.job_file
        if self.job_name is not None:
            result['JobName'] = self.job_name
        if self.rollout_config is not None:
            result['RolloutConfig'] = self.rollout_config
        if self.scheduled_time is not None:
            result['ScheduledTime'] = self.scheduled_time
        if self.target_config is not None:
            result['TargetConfig'] = self.target_config
        if self.timeout_config is not None:
            result['TimeoutConfig'] = self.timeout_config
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('JobDocument') is not None:
            self.job_document = m.get('JobDocument')
        if m.get('JobFile') is not None:
            self.job_file = m.get('JobFile')
        if m.get('JobName') is not None:
            self.job_name = m.get('JobName')
        if m.get('RolloutConfig') is not None:
            self.rollout_config = m.get('RolloutConfig')
        if m.get('ScheduledTime') is not None:
            self.scheduled_time = m.get('ScheduledTime')
        if m.get('TargetConfig') is not None:
            self.target_config = m.get('TargetConfig')
        if m.get('TimeoutConfig') is not None:
            self.timeout_config = m.get('TimeoutConfig')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateJobShrinkRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        iot_instance_id: str = None,
        job_document: str = None,
        job_file_shrink: str = None,
        job_name: str = None,
        rollout_config_shrink: str = None,
        scheduled_time: int = None,
        target_config_shrink: str = None,
        timeout_config_shrink: str = None,
        type: str = None,
    ):
        self.description = description
        self.iot_instance_id = iot_instance_id
        self.job_document = job_document
        self.job_file_shrink = job_file_shrink
        self.job_name = job_name
        self.rollout_config_shrink = rollout_config_shrink
        self.scheduled_time = scheduled_time
        self.target_config_shrink = target_config_shrink
        self.timeout_config_shrink = timeout_config_shrink
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.job_document is not None:
            result['JobDocument'] = self.job_document
        if self.job_file_shrink is not None:
            result['JobFile'] = self.job_file_shrink
        if self.job_name is not None:
            result['JobName'] = self.job_name
        if self.rollout_config_shrink is not None:
            result['RolloutConfig'] = self.rollout_config_shrink
        if self.scheduled_time is not None:
            result['ScheduledTime'] = self.scheduled_time
        if self.target_config_shrink is not None:
            result['TargetConfig'] = self.target_config_shrink
        if self.timeout_config_shrink is not None:
            result['TimeoutConfig'] = self.timeout_config_shrink
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('JobDocument') is not None:
            self.job_document = m.get('JobDocument')
        if m.get('JobFile') is not None:
            self.job_file_shrink = m.get('JobFile')
        if m.get('JobName') is not None:
            self.job_name = m.get('JobName')
        if m.get('RolloutConfig') is not None:
            self.rollout_config_shrink = m.get('RolloutConfig')
        if m.get('ScheduledTime') is not None:
            self.scheduled_time = m.get('ScheduledTime')
        if m.get('TargetConfig') is not None:
            self.target_config_shrink = m.get('TargetConfig')
        if m.get('TimeoutConfig') is not None:
            self.timeout_config_shrink = m.get('TimeoutConfig')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateJobResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        job_id: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.job_id = job_id
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateLoRaNodesTaskRequestDeviceInfo(TeaModel):
    def __init__(
        self,
        dev_eui: str = None,
        pin_code: str = None,
    ):
        # The DevEUI of the LoRaWAN device.
        self.dev_eui = dev_eui
        # The PIN code of the LoRaWAN device. The value of the parameter is used to verify the DevEUI.
        self.pin_code = pin_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dev_eui is not None:
            result['DevEui'] = self.dev_eui
        if self.pin_code is not None:
            result['PinCode'] = self.pin_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DevEui') is not None:
            self.dev_eui = m.get('DevEui')
        if m.get('PinCode') is not None:
            self.pin_code = m.get('PinCode')
        return self


class CreateLoRaNodesTaskRequest(TeaModel):
    def __init__(
        self,
        device_info: List[CreateLoRaNodesTaskRequestDeviceInfo] = None,
        iot_instance_id: str = None,
        product_key: str = None,
    ):
        # The LoRaWAN devices.
        self.device_info = device_info
        # The instance ID. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
        # 
        # >  If your instance has an ID, you must specify this parameter. Otherwise, the request fails. If no Overview page exists or no instance ID is displayed, you do not need to specify this parameter.
        # 
        # For more information, see the [Overview](~~356505~~) topic of IoT instances.
        self.iot_instance_id = iot_instance_id
        # The ProductKey of the product to which the devices belong.
        self.product_key = product_key

    def validate(self):
        if self.device_info:
            for k in self.device_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DeviceInfo'] = []
        if self.device_info is not None:
            for k in self.device_info:
                result['DeviceInfo'].append(k.to_map() if k else None)
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.device_info = []
        if m.get('DeviceInfo') is not None:
            for k in m.get('DeviceInfo'):
                temp_model = CreateLoRaNodesTaskRequestDeviceInfo()
                self.device_info.append(temp_model.from_map(k))
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class CreateLoRaNodesTaskResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        task_id: str = None,
    ):
        # The error code returned if the request fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the request fails.
        self.error_message = error_message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful.
        # 
        # *   **true**\
        # *   **false**\
        self.success = success
        # The task ID returned if the request was successful.
        # 
        # > Record the ID. You must use the ID to query the status of the device creation task.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class CreateLoRaNodesTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateLoRaNodesTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateLoRaNodesTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateOTADynamicUpgradeJobRequestTag(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The value of the update batch tag. The value must be 1 to 1,024 characters in length. You can add up to 10 tags for each update batch. The total length of the tag keys and tag values of all update batches cannot exceed 4,096 characters in length.
        # 
        # >  Update batch tags are optional. If you want to specify a tag, you must specify the Tag.N.Value and Tag.N.Key parameters in pair.
        self.key = key
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateOTADynamicUpgradeJobRequest(TeaModel):
    def __init__(
        self,
        download_protocol: str = None,
        dynamic_mode: int = None,
        firmware_id: str = None,
        group_id: str = None,
        group_type: str = None,
        iot_instance_id: str = None,
        maximum_per_minute: int = None,
        multi_module_mode: bool = None,
        need_confirm: bool = None,
        need_push: bool = None,
        overwrite_mode: int = None,
        product_key: str = None,
        retry_count: int = None,
        retry_interval: int = None,
        src_version: List[str] = None,
        tag: List[CreateOTADynamicUpgradeJobRequestTag] = None,
        timeout_in_minutes: int = None,
    ):
        # Specifies whether the device supports simultaneous updates of multiple modules. Default value: false. Valid values:
        # 
        # *   **false**\
        # 
        # *   **true**: In this case, do not set **OverwriteMode** to **2**.********\
        # 
        #     The update tasks for the same module are overwritten. The update tasks that are in progress are not overwritten. The update tasks of the modules do not affect each other.
        # 
        # >*   Only Enterprise Edition instances and new public instances are supported.
        # >*   You must use Link SDK for C 4.x to develop the device.
        # >*   If you initiate a group-based dynamic update batch, the settings of **MultiModuleMode** and **OverwriteMode** must be the same as those in the existing dynamic update batch of the group.
        # 
        # For more information, see [Overview](~~58328~~).
        self.download_protocol = download_protocol
        # Specifies whether to automatically push update tasks from IoT Platform to devices. Default value: true. Valid values:
        # 
        # *   **true**: After an update batch is created, IoT Platform automatically pushes update tasks to the specified online devices.
        # 
        #     In this case, a device can still initiate a request to obtain the information about the over-the-air (OTA) update task from IoT Platform.
        # 
        # *   **false**: A device must initiate a request to obtain the information about the OTA update task from IoT Platform.
        self.dynamic_mode = dynamic_mode
        # The **ProductKey** of the product to which the update package belongs.
        # 
        # A **ProductKey** is the unique identifier of a product in IoT Platform. You can view the information about all products within the current Alibaba Cloud account in the IoT Platform console or by calling the [QueryProductList](~~69271~~) operation.
        self.firmware_id = firmware_id
        # The type of the group. Valid value: **LINK_PLATFORM_DYNAMIC**.
        # 
        # *   If you specify this parameter, you must also specify the **GroupId** parameter. In this case, do not specify the **SrcVersion.N** parameter.
        # *   If you do not specify this parameter, you do not need to specify the **GroupId** parameter. In this case, you must specify the **SrcVersion.N** parameter.
        self.group_id = group_id
        # The download protocol of the update package. Valid values: **HTTPS** and **MQTT**. Default value: HTTPS. After the device receives the update package information pushed by IoT Platform, this protocol is used to download the update package.
        # 
        # > If you need to download the update package over MQTT, take note of the following items:
        # >*   Your service must be deployed in the China (Shanghai) region.
        # >*   The OTA update package can contain only one file, and the size of the file cannot exceed 16 MB.
        # >*   You must use the latest version of Link SDK for C to develop the device features to perform OTA updates and download files over MQTT. For more information, see [Sample code](~~330985~~).
        self.group_type = group_type
        # The ID of the update package.
        # 
        # An update package ID is returned when you call the [CreateOTAFirmware](~~147311~~) operation to create the update package.
        # 
        # You can also call the [ListOTAFirmware](~~147450~~) operation to obtain the ID.
        self.iot_instance_id = iot_instance_id
        # Specifies whether to overwrite the previous update task. Default value: 1. Valid values:
        # 
        # *   **1**: The previous update task is not overwritten. If a device already has an update task, the previous update task is implemented.
        # *   **2**: The previous update task is overwritten. Only the current update task is implemented. In this case, you cannot set **MultiModuleMode** to **true**.
        # 
        # >  The update task that is in progress is not overwritten.
        self.maximum_per_minute = maximum_per_minute
        # The list of firmware versions to be updated.
        # 
        # *   If you specify this parameter, do not specify the **GroupId** and **GroupType** parameters.
        # *   If you do not specify this parameter, you must specify the **GroupId** and **GroupType** parameters.
        # 
        # > If you use differential update packages to perform dynamic update tasks on dynamic groups, you do not need to specify this parameter.
        # >*   If you use differential update packages to perform dynamic update tasks based on versions, the value of this parameter must be the same as the value of **SrcVersion**.
        # >*   You can call the [QueryDeviceDetail](~~69594~~) operation and view the **FirmwareVersion** parameter in the response.
        # >*   The version numbers must be unique in the list.
        # >*   You can specify a maximum of 10 version numbers.
        self.multi_module_mode = multi_module_mode
        # The ID of the group.
        # 
        # *   If you specify this parameter, you must also specify the **GroupType** parameter. In this case, do not specify the **SrcVersion.N** parameter.
        # *   If you do not specify this parameter, you do not need to specify the **GroupType** parameter. In this case, you must specify the **SrcVersion.N** parameter.
        # 
        # You can call the [QueryDeviceGroupList](~~93356~~) operation to query the **GroupId** parameter.
        self.need_confirm = need_confirm
        # Specifies whether to control the update by using a mobile app. You must develop the mobile app as needed. Default value: false. Valid values:
        # 
        # *   **false**: A device obtains the information about the OTA update task based on the **NeedPush** parameter.
        # *   **true**: To perform an OTA update on a device, you must confirm the update by using your mobile app. Then, the device can obtain the information about the OTA update task based on the **NeedPush** parameter.
        self.need_push = need_push
        # The mode of dynamic update. Default value: 1. Valid values:
        # 
        # *   **1**: constantly updates the devices that meet the conditions.
        # *   **2**: updates only the devices that subsequently submit the latest firmware versions.
        self.overwrite_mode = overwrite_mode
        # The automatic retry interval if a device fails to be updated. Unit: minutes. Valid values:
        # 
        # *   **0**: An automatic retry is immediately performed.
        # *   **10**: An automatic retry is performed after 10 minutes.
        # *   **30**: An automatic retry is performed after 30 minutes.
        # *   **60**: An automatic retry is performed after 60 minutes (1 hour).
        # *   **1440**: An automatic retry is performed after 1,440 minutes (24 hours).
        # 
        # > The value of the **RetryInterval** parameter must be less than the value of the **TimeoutInMinutes** parameter. Examples:
        # >*   If the value of the **TimeoutInMinutes** parameter is set to 60, the maximum value of the **RetryInterval** parameter is 30.
        # >*   If the value of the **TimeoutInMinutes** parameter is set to 1440, the maximum value of the **RetryInterval** parameter is 60.
        # 
        # If the value of the **RetryInterval** parameter is set to 1440, we recommend that you do not specify the **TimeoutInMinutes** parameter. If an update times out, no retry is performed.
        # 
        # If you do not specify this parameter, no retry is performed.
        self.product_key = product_key
        # The timeout period of the update. If the device is not updated within the specified period, a timeout error occurs. Unit: minutes. Valid values: 1 to 1440.
        # 
        # > *   The timeout period starts from the time when the specified device submits the update progress for the first time. During the update, the update package may be repeatedly pushed to the specified device because the device goes online and offline multiple times. The start time of the update period remains unchanged.
        # >*   If an update fails due to timeout, no retry is triggered.
        # 
        # If you do not specify this parameter, timeout errors do not occur.
        self.retry_count = retry_count
        # The number of automatic retries.
        # 
        # If you specify the **RetryInterval** parameter, you must specify this parameter.
        # 
        # Valid values:
        # 
        # *   **1**: retries once.
        # *   **2**: retries twice.
        # *   **5**: retries five times.
        self.retry_interval = retry_interval
        self.src_version = src_version
        self.tag = tag
        # The maximum number of devices to which the download URL of the update package is pushed per minute. Valid values: 10 to 10000.
        # 
        # Default value: 10000.
        self.timeout_in_minutes = timeout_in_minutes

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.download_protocol is not None:
            result['DownloadProtocol'] = self.download_protocol
        if self.dynamic_mode is not None:
            result['DynamicMode'] = self.dynamic_mode
        if self.firmware_id is not None:
            result['FirmwareId'] = self.firmware_id
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_type is not None:
            result['GroupType'] = self.group_type
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.maximum_per_minute is not None:
            result['MaximumPerMinute'] = self.maximum_per_minute
        if self.multi_module_mode is not None:
            result['MultiModuleMode'] = self.multi_module_mode
        if self.need_confirm is not None:
            result['NeedConfirm'] = self.need_confirm
        if self.need_push is not None:
            result['NeedPush'] = self.need_push
        if self.overwrite_mode is not None:
            result['OverwriteMode'] = self.overwrite_mode
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.retry_count is not None:
            result['RetryCount'] = self.retry_count
        if self.retry_interval is not None:
            result['RetryInterval'] = self.retry_interval
        if self.src_version is not None:
            result['SrcVersion'] = self.src_version
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        if self.timeout_in_minutes is not None:
            result['TimeoutInMinutes'] = self.timeout_in_minutes
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DownloadProtocol') is not None:
            self.download_protocol = m.get('DownloadProtocol')
        if m.get('DynamicMode') is not None:
            self.dynamic_mode = m.get('DynamicMode')
        if m.get('FirmwareId') is not None:
            self.firmware_id = m.get('FirmwareId')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupType') is not None:
            self.group_type = m.get('GroupType')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('MaximumPerMinute') is not None:
            self.maximum_per_minute = m.get('MaximumPerMinute')
        if m.get('MultiModuleMode') is not None:
            self.multi_module_mode = m.get('MultiModuleMode')
        if m.get('NeedConfirm') is not None:
            self.need_confirm = m.get('NeedConfirm')
        if m.get('NeedPush') is not None:
            self.need_push = m.get('NeedPush')
        if m.get('OverwriteMode') is not None:
            self.overwrite_mode = m.get('OverwriteMode')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('RetryCount') is not None:
            self.retry_count = m.get('RetryCount')
        if m.get('RetryInterval') is not None:
            self.retry_interval = m.get('RetryInterval')
        if m.get('SrcVersion') is not None:
            self.src_version = m.get('SrcVersion')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = CreateOTADynamicUpgradeJobRequestTag()
                self.tag.append(temp_model.from_map(k))
        if m.get('TimeoutInMinutes') is not None:
            self.timeout_in_minutes = m.get('TimeoutInMinutes')
        return self


class CreateOTADynamicUpgradeJobResponseBodyData(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        utc_create: str = None,
    ):
        # The time when the update batch was created. The time is displayed in UTC.
        self.job_id = job_id
        self.utc_create = utc_create

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.utc_create is not None:
            result['UtcCreate'] = self.utc_create
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('UtcCreate') is not None:
            self.utc_create = m.get('UtcCreate')
        return self


class CreateOTADynamicUpgradeJobResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: CreateOTADynamicUpgradeJobResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error message returned if the call fails.
        self.code = code
        # The unique identifier of the update batch.
        self.data = data
        # The ID of the request.
        self.error_message = error_message
        # Indicates whether the call was successful.
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.request_id = request_id
        # The update batch information returned if the call is successful. For more information, see Data.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = CreateOTADynamicUpgradeJobResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateOTADynamicUpgradeJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateOTADynamicUpgradeJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateOTADynamicUpgradeJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateOTAFirmwareRequestMultiFiles(TeaModel):
    def __init__(
        self,
        file_md_5: str = None,
        name: str = None,
        sign_value: str = None,
        size: int = None,
        url: str = None,
    ):
        # The MD5 value of the file.
        # 
        # >  If you want to add multiple files to the OTA update package, you can configure this parameter. If you do not configure this parameter, the MD5 value of the file in OSS is used.
        self.file_md_5 = file_md_5
        # The name of the file in the update package. The name must be 1 to 32 characters in length. You can specify up to 20 file names. Each name must be unique in the OTA update package.
        # 
        # > If you want to add multiple files to the OTA update package, you must configure this parameter.
        self.name = name
        # The signature of the file. The value is calculated by using the specified **signature algorithm** to sign the file.
        # 
        # >  If you want to add multiple files to the OTA update package, you can configure this parameter. If you do not configure this parameter, the MD5 value of the file in OSS is used as the file signature.
        self.sign_value = sign_value
        # The size of the file in the OTA update package. Unit: bytes.
        # 
        # >  If you want to add multiple files to the OTA update package, you can configure this parameter. If you do not configure this parameter, the size of the file in OSS is used.
        self.size = size
        # The URL of the file. This parameter specifies the storage location of the file in OSS. You can call the [GenerateOTAUploadURL](~~147310~~) operation to generate a URL for each file in the OTA update package.
        # 
        # > If you want to add multiple files to the OTA update package, you must configure this parameter.
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_md_5 is not None:
            result['FileMd5'] = self.file_md_5
        if self.name is not None:
            result['Name'] = self.name
        if self.sign_value is not None:
            result['SignValue'] = self.sign_value
        if self.size is not None:
            result['Size'] = self.size
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileMd5') is not None:
            self.file_md_5 = m.get('FileMd5')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('SignValue') is not None:
            self.sign_value = m.get('SignValue')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class CreateOTAFirmwareRequest(TeaModel):
    def __init__(
        self,
        dest_version: str = None,
        firmware_desc: str = None,
        firmware_name: str = None,
        firmware_sign: str = None,
        firmware_size: int = None,
        firmware_url: str = None,
        iot_instance_id: str = None,
        module_name: str = None,
        multi_files: List[CreateOTAFirmwareRequestMultiFiles] = None,
        need_to_verify: bool = None,
        product_key: str = None,
        sign_method: str = None,
        src_version: str = None,
        type: int = None,
        udi: str = None,
    ):
        # The version number of the OTA update package. The value can contain letters, digits, periods (.), hyphens (-), and underscores (\_). The version number must be 1 to 64 characters in length.
        self.dest_version = dest_version
        # The description of the OTA update package. The description must be 1 to 100 characters in length.
        self.firmware_desc = firmware_desc
        # The name of the OTA update package. The name must be unique within an Alibaba Cloud account. The name cannot be modified after the OTA update package is created. The name must be 1 to 40 characters in length, and can contain letters, digits, hyphens (-), underscores (\_), and parentheses (). The name must start with a letter or a digit.
        self.firmware_name = firmware_name
        # The signature of the OTA update package. The value is calculated by using the specified **signature algorithm** to sign the OTA update package.
        # 
        # > If you add only one file to the OTA update package, you can configure this parameter. If you do not configure this parameter, the MD5 value of the OTA update package in OSS is used as the package signature.
        self.firmware_sign = firmware_sign
        # The size of the OTA update package. Unit: bytes.
        # 
        # > If you add only one file to the OTA update package, you can configure this parameter. If you do not configure this parameter, the size of the OTA update package in OSS is used.
        self.firmware_size = firmware_size
        # The URL of the OTA update package. This parameter specifies the storage location of the OTA update package in OSS. You can call the [GenerateOTAUploadURL](~~147310~~) operation to generate a URL for the OTA update package.
        # 
        # >If you add only one file to the OTA update package, you must configure this parameter.
        self.firmware_url = firmware_url
        # The ID of the instance. You can view the ID of the instance on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.
        # >*   If no **Overview** page or **ID** is generated for your instance, you do not need to configure this parameter.
        self.iot_instance_id = iot_instance_id
        # The name of the OTA module. OTA modules are the updatable units of devices that belong to the same product.
        # 
        # > *   If you do not configure this parameter, the default OTA module is used. The default value indicates that the complete device firmware is updated.
        # >*   You can call the [CreateOTAModule](~~186066~~) operation to create a custom OTA module. You can call the [ListOTAModuleByProduct](~~186532~~) operation to query the existing OTA modules of a product.
        self.module_name = module_name
        self.multi_files = multi_files
        # Specifies whether to verify the OTA update package before you create a batch update task.
        # 
        # *   **true** The system verifies the OTA update package before you create a batch update task. This is the default value.
        # *   **false**: The system does not verify the OTA update package before you create a batch update task.
        self.need_to_verify = need_to_verify
        # The **ProductKey** of the product to which the OTA update package belongs.
        self.product_key = product_key
        # The signature algorithm of the OTA update package. Set the value to **MD5**. The value indicates an MD5 signature.
        # 
        # Default value: **MD5**.
        self.sign_method = sign_method
        # The version number of the OTA module of the device to be updated.
        # 
        # You can call the [QueryDeviceDetail](~~69594~~) operation and view the **FirmwareVersion** parameter in the response.
        # 
        # > *   If you set the **Type** parameter to **1**, you must configure this parameter, and the value cannot be the same as the update package version that is specified by the **DestVersion** parameter.
        # >*   If you set the **Type** parameter to **0**, this parameter is optional.
        self.src_version = src_version
        # The type of the OTA update package. Valid values:
        # 
        # *   **0**: The uploaded file contains a full update package. IoT Platform pushes the full update package to a device for update.
        # *   **1**: The uploaded file contains only the differences between the latest update package and the previous update package. IoT Platform pushes only the differences to a device for update.
        # 
        # Default value: **0**.
        self.type = type
        # The custom information that you want to send to a device. The format of the custom information has no limits. However, the information cannot exceed 4,096 characters in length.
        # 
        # After you add the OTA update package and create an update task, IoT Platform sends the custom information to the specified device when IoT Platform pushes an update notification.
        self.udi = udi

    def validate(self):
        if self.multi_files:
            for k in self.multi_files:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dest_version is not None:
            result['DestVersion'] = self.dest_version
        if self.firmware_desc is not None:
            result['FirmwareDesc'] = self.firmware_desc
        if self.firmware_name is not None:
            result['FirmwareName'] = self.firmware_name
        if self.firmware_sign is not None:
            result['FirmwareSign'] = self.firmware_sign
        if self.firmware_size is not None:
            result['FirmwareSize'] = self.firmware_size
        if self.firmware_url is not None:
            result['FirmwareUrl'] = self.firmware_url
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.module_name is not None:
            result['ModuleName'] = self.module_name
        result['MultiFiles'] = []
        if self.multi_files is not None:
            for k in self.multi_files:
                result['MultiFiles'].append(k.to_map() if k else None)
        if self.need_to_verify is not None:
            result['NeedToVerify'] = self.need_to_verify
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.sign_method is not None:
            result['SignMethod'] = self.sign_method
        if self.src_version is not None:
            result['SrcVersion'] = self.src_version
        if self.type is not None:
            result['Type'] = self.type
        if self.udi is not None:
            result['Udi'] = self.udi
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DestVersion') is not None:
            self.dest_version = m.get('DestVersion')
        if m.get('FirmwareDesc') is not None:
            self.firmware_desc = m.get('FirmwareDesc')
        if m.get('FirmwareName') is not None:
            self.firmware_name = m.get('FirmwareName')
        if m.get('FirmwareSign') is not None:
            self.firmware_sign = m.get('FirmwareSign')
        if m.get('FirmwareSize') is not None:
            self.firmware_size = m.get('FirmwareSize')
        if m.get('FirmwareUrl') is not None:
            self.firmware_url = m.get('FirmwareUrl')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ModuleName') is not None:
            self.module_name = m.get('ModuleName')
        self.multi_files = []
        if m.get('MultiFiles') is not None:
            for k in m.get('MultiFiles'):
                temp_model = CreateOTAFirmwareRequestMultiFiles()
                self.multi_files.append(temp_model.from_map(k))
        if m.get('NeedToVerify') is not None:
            self.need_to_verify = m.get('NeedToVerify')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('SignMethod') is not None:
            self.sign_method = m.get('SignMethod')
        if m.get('SrcVersion') is not None:
            self.src_version = m.get('SrcVersion')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Udi') is not None:
            self.udi = m.get('Udi')
        return self


class CreateOTAFirmwareResponseBodyData(TeaModel):
    def __init__(
        self,
        firmware_id: str = None,
        utc_create: str = None,
    ):
        # The ID of the OTA update package. The ID is a unique identifier issued by IoT Platform to the OTA update package.
        self.firmware_id = firmware_id
        # The time when the OTA update package was created. The time is displayed in UTC.
        self.utc_create = utc_create

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.firmware_id is not None:
            result['FirmwareId'] = self.firmware_id
        if self.utc_create is not None:
            result['UtcCreate'] = self.utc_create
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FirmwareId') is not None:
            self.firmware_id = m.get('FirmwareId')
        if m.get('UtcCreate') is not None:
            self.utc_create = m.get('UtcCreate')
        return self


class CreateOTAFirmwareResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: CreateOTAFirmwareResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The OTA update package information that is returned if the call is successful. For more information, see the "**Data**" section of this topic.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful. Valid values:
        # 
        # *   **true**: The call was successful. The value indicates that the OTA update package was created.
        # *   **false**: The call failed. The value indicates that the system failed to create the OTA update package.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = CreateOTAFirmwareResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateOTAFirmwareResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateOTAFirmwareResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateOTAFirmwareResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateOTAModuleRequest(TeaModel):
    def __init__(
        self,
        alias_name: str = None,
        desc: str = None,
        iot_instance_id: str = None,
        module_name: str = None,
        product_key: str = None,
    ):
        # The alias of the OTA module. The alias must be 1 to 64 characters in length, and can contain letters, digits, periods(.), hyphens (-), and underscores (\_).
        self.alias_name = alias_name
        # The description of the OTA module. The description can be up to 100 characters in length.
        self.desc = desc
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The name of the OTA module. The name is unique in a product and cannot be modified. The name can contain letters, digits, periods (.), hyphens (-), and underscores (\_). The name must be 1 to 64 characters in length.
        # 
        # >  Letters are not case-sensitive. For example, you cannot use the module names scanner and Scanner at the same time.
        self.module_name = module_name
        # The ProductKey of the product to which the OTA module belongs.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias_name is not None:
            result['AliasName'] = self.alias_name
        if self.desc is not None:
            result['Desc'] = self.desc
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.module_name is not None:
            result['ModuleName'] = self.module_name
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliasName') is not None:
            self.alias_name = m.get('AliasName')
        if m.get('Desc') is not None:
            self.desc = m.get('Desc')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ModuleName') is not None:
            self.module_name = m.get('ModuleName')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class CreateOTAModuleResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateOTAModuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateOTAModuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateOTAModuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateOTAStaticUpgradeJobRequestTag(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The key of the update batch tag. The key must be 1 to 30 characters in length and can contain letters, digits, and periods (.). You can add up to 10 tags for each update batch.
        # 
        # The tags of an update batch are sent to devices when IoT Platform pushes update notifications to these devices.
        # 
        # >  Update batch tags are optional. If you want to specify a tag, you must specify the Tag.N.Value and Tag.N.Key parameters in pair.
        self.key = key
        # The value of the update batch tag. The value must be 1 to 1,024 characters in length. You can add up to 10 tags for each update batch. The total length of the tag keys and tag values of all update batches cannot exceed 4,096 characters in length.
        # 
        # >  Update batch tags are optional. If you want to specify a tag, you must specify the Tag.N.Value and Tag.N.Key parameters in pair.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateOTAStaticUpgradeJobRequest(TeaModel):
    def __init__(
        self,
        dn_list_file_url: str = None,
        download_protocol: str = None,
        firmware_id: str = None,
        gray_percent: str = None,
        group_id: str = None,
        group_type: str = None,
        iot_instance_id: str = None,
        maximum_per_minute: int = None,
        multi_module_mode: bool = None,
        need_confirm: bool = None,
        need_push: bool = None,
        overwrite_mode: int = None,
        product_key: str = None,
        retry_count: int = None,
        retry_interval: int = None,
        schedule_finish_time: int = None,
        schedule_time: int = None,
        src_version: List[str] = None,
        tag: List[CreateOTAStaticUpgradeJobRequestTag] = None,
        target_device_name: List[str] = None,
        target_selection: str = None,
        timeout_in_minutes: int = None,
    ):
        # The URL of the device list file that is used to perform a specific update.
        # 
        # > *   If you set the TargetSelection parameter to `SPECIFIC`, you must specify this parameter or the **TargetDeviceName.N** parameter. You cannot specify the two parameters at the same time.
        # >*   You can call the [GenerateDeviceNameListURL](~~186062~~) operation to generate a file URL. Then, you can perform the operations as prompted to upload the device list file.
        # >*   During a full update, the devices that have been updated are skipped.
        # >*   During a delta update, the devices that have been updated and the devices whose initial version numbers are different from the update package are skipped.
        self.dn_list_file_url = dn_list_file_url
        # The download protocol of the update package. Valid values: **HTTPS** and **MQTT**. Default value: HTTPS. After the device receives the update package information pushed by IoT Platform, this protocol is used to download the update package.
        # 
        # >If you need to download the update package over MQTT, take note of the following items:
        # >*   Your service must be deployed in the China (Shanghai), China (Beijing), or China (Shenzhen) region.
        # >*   The OTA update package can contain only one file, and the size of the file cannot exceed 16 MB.
        # >*   You must use the latest version of Link SDK for C to develop the device features to perform OTA updates and download files over MQTT. For more information, see [Sample code](~~330985~~).
        self.download_protocol = download_protocol
        # The ID of the update package.
        # 
        # An update package ID is returned when you call the [CreateOTAFirmware](~~147311~~) operation to create the update package.
        # 
        # You can also call the [ListOTAFirmware](~~147450~~) operation to obtain the ID.
        self.firmware_id = firmware_id
        # The ratio of the phased update. The value is a percentage in the string format. It can be up to three decimal places. The calculated number of devices is rounded down to the nearest integer. You must specify at least one device for a phased update.
        # 
        # For example, if you set the phased update ratio to 33.33 for 100 devices, the number of devices to be updated is 33.
        # 
        # You must specify this parameter if you set the TargetSelection parameter to `GRAY`.
        self.gray_percent = gray_percent
        # The ID of the group.
        # 
        # If you set the TargetSelection parameter to `GROUP`, you must specify this parameter and the **GroupType** parameter.
        # 
        # You can call the [QueryDeviceGroupList](~~93356~~) operation to query the **GroupId** parameter.
        self.group_id = group_id
        # The type of the group. Valid value: **LINK_PLATFORM**.
        # 
        # If you set the TargetSelection parameter to `GROUP`, you must specify this parameter and the **GroupId** parameter.
        self.group_type = group_type
        # The ID of the instance. You can view the ID of an instance on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must specify the ID for this parameter. If you do not specify the instance ID, the call fails.****\
        # >*   If no **Overview** page or **ID** is generated for your instance, you do not need to configure this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The maximum number of devices to which the download URL of the update package is pushed per minute. Valid values: 10 to 10000.
        # 
        # Default value: 10000.
        self.maximum_per_minute = maximum_per_minute
        # Specifies whether the device supports simultaneous updates of multiple modules. Default value: false. Valid values:
        # 
        # *   **false**\
        # 
        # *   **true**: In this case, do not set **OverwriteMode** to **2**.********\
        # 
        #     The update tasks for the same module are overwritten. The update tasks that are in progress are not overwritten. The update tasks of the modules do not affect each other.
        # 
        # >*   Only Enterprise Edition instances and new public instances are supported.
        # >*   You must use Link SDK for C 4.x to develop the device.
        # 
        # For more information, see [Overview](~~58328~~).
        self.multi_module_mode = multi_module_mode
        # Specifies whether to control the update by using a mobile app. You must develop the mobile app as needed. Default false: true. Valid values:
        # 
        # *   **false**: A device obtains the information about the OTA update task based on the **NeedPush** parameter.
        # *   **true**: To perform an OTA update on a device, you must confirm the update by using your mobile app. Then, the device can obtain the information about the OTA update task based on the **NeedPush** parameter.
        self.need_confirm = need_confirm
        # Specifies whether to automatically push update tasks from IoT Platform to devices. Default value: true. Valid values:
        # 
        # *   **true**: After an update batch is created, IoT Platform automatically pushes update tasks to the specified online devices.
        # 
        #     In this case, a device can still initiate a request to obtain the information about the over-the-air (OTA) update task from IoT Platform.
        # 
        # *   **false**: A device must initiate a request to obtain the information about the OTA update task from IoT Platform.
        self.need_push = need_push
        # Specifies whether to overwrite the previous update task. Default value: 1. Valid values:
        # 
        # *   **1**: The previous update task is not overwritten. If a device already has an update task, the previous update task is implemented.
        # *   **2**: The previous update task is overwritten. Only the current update task is implemented. In this case, you cannot set **MultiModuleMode** to **true**.
        # 
        # >  The update task that is in progress is not overwritten.
        self.overwrite_mode = overwrite_mode
        # The **ProductKey** of the product to which the update package belongs.
        # 
        # A **ProductKey** is the unique identifier of a product in IoT Platform. You can view the information about all products within the current Alibaba Cloud account in the IoT Platform console or by calling the [QueryProductList](~~69271~~) operation.
        self.product_key = product_key
        # The number of automatic retries.
        # 
        # If you specify the **RetryInterval** parameter, you must specify this parameter.
        # 
        # Valid values:
        # 
        # *   **1**: retries once.
        # *   **2**: retries twice.
        # *   **5**: retries five times.
        self.retry_count = retry_count
        # The automatic retry interval if a device fails to be updated. Unit: minutes. Valid values:
        # 
        # *   **0**: An automatic retry is immediately performed.
        # *   **10**: An automatic retry is performed after 10 minutes.
        # *   **30**: An automatic retry is performed after 30 minutes.
        # *   **60**: An automatic retry is performed after 60 minutes (1 hour).
        # *   **1440**: An automatic retry is performed after 1,440 minutes (24 hours).
        # 
        # > The value of the **RetryInterval** parameter must be less than the value of the **TimeoutInMinutes** parameter. Examples:
        # >*   If the value of the **TimeoutInMinutes** parameter is set to 60, the maximum value of the **RetryInterval** parameter is 30.
        # >*   If the value of the **TimeoutInMinutes** parameter is set to 1440, the maximum value of the **RetryInterval** parameter is 60.
        # 
        # If the value of the **RetryInterval** parameter is set to 1440, we recommend that you do not specify the **TimeoutInMinutes** parameter. If an update times out, no retry is performed.
        # 
        # If you do not specify this parameter, no retry is performed.
        self.retry_interval = retry_interval
        # The time to end the update.
        # 
        # The end time must be 1 hour to 30 days later than the start time that is specified by the **ScheduleTime** parameter. The value must be a 13-digit timestamp.
        # 
        # If you do not specify this parameter, the update is not forcibly ended.
        self.schedule_finish_time = schedule_finish_time
        # The time to start the over-the-air (OTA) update.
        # 
        # The scheduled time ranges from 5 minutes to 7 days later than the current time. The value must be a 13-digit timestamp.
        # 
        # If you do not specify this parameter, the update immediately starts.
        self.schedule_time = schedule_time
        self.src_version = src_version
        self.tag = tag
        self.target_device_name = target_device_name
        # The scope of the update batch. Valid values:
        # 
        # *   **ALL**: updates all devices.
        # *   **SPECIFIC**: updates specified devices.
        # *   **GRAY**: performs a phased update.
        # *   **GROUP**: updates specified groups.
        self.target_selection = target_selection
        # The timeout period of the update. If the device is not updated within the specified period, a timeout error occurs. Unit: minutes. Valid values: 1 to 1440.
        # 
        # > *   The timeout period starts from the time when the specified device submits the update progress for the first time. During the update, the update package may be repeatedly pushed to the specified device because the device goes online and offline multiple times. The start time of the update period remains unchanged.
        # >*   If an update fails due to timeout, no retry is triggered.
        # 
        # If you do not specify this parameter, timeout errors do not occur.
        self.timeout_in_minutes = timeout_in_minutes

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dn_list_file_url is not None:
            result['DnListFileUrl'] = self.dn_list_file_url
        if self.download_protocol is not None:
            result['DownloadProtocol'] = self.download_protocol
        if self.firmware_id is not None:
            result['FirmwareId'] = self.firmware_id
        if self.gray_percent is not None:
            result['GrayPercent'] = self.gray_percent
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_type is not None:
            result['GroupType'] = self.group_type
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.maximum_per_minute is not None:
            result['MaximumPerMinute'] = self.maximum_per_minute
        if self.multi_module_mode is not None:
            result['MultiModuleMode'] = self.multi_module_mode
        if self.need_confirm is not None:
            result['NeedConfirm'] = self.need_confirm
        if self.need_push is not None:
            result['NeedPush'] = self.need_push
        if self.overwrite_mode is not None:
            result['OverwriteMode'] = self.overwrite_mode
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.retry_count is not None:
            result['RetryCount'] = self.retry_count
        if self.retry_interval is not None:
            result['RetryInterval'] = self.retry_interval
        if self.schedule_finish_time is not None:
            result['ScheduleFinishTime'] = self.schedule_finish_time
        if self.schedule_time is not None:
            result['ScheduleTime'] = self.schedule_time
        if self.src_version is not None:
            result['SrcVersion'] = self.src_version
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        if self.target_device_name is not None:
            result['TargetDeviceName'] = self.target_device_name
        if self.target_selection is not None:
            result['TargetSelection'] = self.target_selection
        if self.timeout_in_minutes is not None:
            result['TimeoutInMinutes'] = self.timeout_in_minutes
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DnListFileUrl') is not None:
            self.dn_list_file_url = m.get('DnListFileUrl')
        if m.get('DownloadProtocol') is not None:
            self.download_protocol = m.get('DownloadProtocol')
        if m.get('FirmwareId') is not None:
            self.firmware_id = m.get('FirmwareId')
        if m.get('GrayPercent') is not None:
            self.gray_percent = m.get('GrayPercent')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupType') is not None:
            self.group_type = m.get('GroupType')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('MaximumPerMinute') is not None:
            self.maximum_per_minute = m.get('MaximumPerMinute')
        if m.get('MultiModuleMode') is not None:
            self.multi_module_mode = m.get('MultiModuleMode')
        if m.get('NeedConfirm') is not None:
            self.need_confirm = m.get('NeedConfirm')
        if m.get('NeedPush') is not None:
            self.need_push = m.get('NeedPush')
        if m.get('OverwriteMode') is not None:
            self.overwrite_mode = m.get('OverwriteMode')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('RetryCount') is not None:
            self.retry_count = m.get('RetryCount')
        if m.get('RetryInterval') is not None:
            self.retry_interval = m.get('RetryInterval')
        if m.get('ScheduleFinishTime') is not None:
            self.schedule_finish_time = m.get('ScheduleFinishTime')
        if m.get('ScheduleTime') is not None:
            self.schedule_time = m.get('ScheduleTime')
        if m.get('SrcVersion') is not None:
            self.src_version = m.get('SrcVersion')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = CreateOTAStaticUpgradeJobRequestTag()
                self.tag.append(temp_model.from_map(k))
        if m.get('TargetDeviceName') is not None:
            self.target_device_name = m.get('TargetDeviceName')
        if m.get('TargetSelection') is not None:
            self.target_selection = m.get('TargetSelection')
        if m.get('TimeoutInMinutes') is not None:
            self.timeout_in_minutes = m.get('TimeoutInMinutes')
        return self


class CreateOTAStaticUpgradeJobResponseBodyData(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        utc_create: str = None,
    ):
        # The unique identifier of the update batch.
        self.job_id = job_id
        # The time when the update batch was created. The time is displayed in UTC.
        self.utc_create = utc_create

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.utc_create is not None:
            result['UtcCreate'] = self.utc_create
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('UtcCreate') is not None:
            self.utc_create = m.get('UtcCreate')
        return self


class CreateOTAStaticUpgradeJobResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: CreateOTAStaticUpgradeJobResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The update batch information returned if the call is successful. For more information, see Data.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful. Valid values:
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = CreateOTAStaticUpgradeJobResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateOTAStaticUpgradeJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateOTAStaticUpgradeJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateOTAStaticUpgradeJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateOTAVerifyJobRequestTag(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The key of the update batch tag. The key must be 1 to 30 characters in length and can contain letters, digits, and periods (.). You can add up to 10 tags for each update batch.
        # 
        # The tags of an update batch are sent to devices when IoT Platform pushes update notifications to the devices.
        # 
        # >  Update batch tags are optional. If you want to specify a tag, you must specify the Tag.N.Value and Tag.N.Key parameters in pair.
        self.key = key
        # The value of the update batch tag. The value must be 1 to 1,024 characters in length. You can add up to 10 tags for each update batch. The total length of the tag keys and tag values of all update batches cannot exceed 4,096 characters.
        # 
        # >  Update batch tags are optional. If you want to specify a tag, you must specify the Tag.N.Value and Tag.N.Key parameters in pair.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateOTAVerifyJobRequest(TeaModel):
    def __init__(
        self,
        download_protocol: str = None,
        firmware_id: str = None,
        iot_instance_id: str = None,
        need_confirm: bool = None,
        need_push: bool = None,
        product_key: str = None,
        tag: List[CreateOTAVerifyJobRequestTag] = None,
        target_device_name: List[str] = None,
        timeout_in_minutes: int = None,
    ):
        # The download protocol of the update package. Valid values: **HTTPS** and **MQTT**. Default value: HTTPS. After the device receives the update package information pushed by IoT Platform, this protocol is used to download the update package.
        # 
        # > If you want to download the update package over MQTT, take note of the following items:
        # >*   The following regions are supported: China (Shanghai), China (Beijing), and China (Shenzhen).
        # >*   The OTA update package can contain only one file and the size of the file cannot exceed 16 MB.
        # >*   You must use the latest version of Link SDK for C to develop the device features to perform OTA updates and download files over MQTT. For more information, see [Sample code](~~330985~~).
        self.download_protocol = download_protocol
        # The ID of the update package.
        # 
        # The **FirmwareId** parameter is returned when you call the [CreateOTAFirmware](~~147311~~) operation to create an OTA update package.
        # 
        # You can also call the [ListOTAFirmware](~~147450~~) operation to obtain the ID.
        self.firmware_id = firmware_id
        # The ID of the instance. You can view the ID of an instance on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.****\
        # >*   If no **Overview** page or **ID** is generated for your instance, you do not need to configure this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # Specifies whether to control the update by using a mobile app. You must develop the mobile app as needed.
        # 
        # *   **false** (default): no. A device obtains the information about the OTA update task based on the **NeedPush** parameter.
        # *   **true**: yes To perform an OTA update on a device, you must confirm the update by using your mobile app. Then, the device can obtain the information about the OTA update task based on the **NeedPush** parameter.
        self.need_confirm = need_confirm
        # Specifies whether to automatically push update tasks from IoT Platform to devices.
        # 
        # *   **true** (default): yes. After an update batch is created, IoT Platform automatically pushes update tasks to the specified online devices.
        # 
        #     In this case, a device can still initiate a request to obtain the information about the over-the-air (OTA) update task from IoT Platform.
        # 
        # *   **false**: no. A device must initiate a request to obtain the information about the OTA update task from IoT Platform.
        self.need_push = need_push
        # The ProductKey of the product to which the OTA update package belongs.
        self.product_key = product_key
        self.tag = tag
        self.target_device_name = target_device_name
        # The timeout period for a device to update the firmware. Unit: minutes. Valid values: 1 to 1440.
        self.timeout_in_minutes = timeout_in_minutes

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.download_protocol is not None:
            result['DownloadProtocol'] = self.download_protocol
        if self.firmware_id is not None:
            result['FirmwareId'] = self.firmware_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.need_confirm is not None:
            result['NeedConfirm'] = self.need_confirm
        if self.need_push is not None:
            result['NeedPush'] = self.need_push
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        if self.target_device_name is not None:
            result['TargetDeviceName'] = self.target_device_name
        if self.timeout_in_minutes is not None:
            result['TimeoutInMinutes'] = self.timeout_in_minutes
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DownloadProtocol') is not None:
            self.download_protocol = m.get('DownloadProtocol')
        if m.get('FirmwareId') is not None:
            self.firmware_id = m.get('FirmwareId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('NeedConfirm') is not None:
            self.need_confirm = m.get('NeedConfirm')
        if m.get('NeedPush') is not None:
            self.need_push = m.get('NeedPush')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = CreateOTAVerifyJobRequestTag()
                self.tag.append(temp_model.from_map(k))
        if m.get('TargetDeviceName') is not None:
            self.target_device_name = m.get('TargetDeviceName')
        if m.get('TimeoutInMinutes') is not None:
            self.timeout_in_minutes = m.get('TimeoutInMinutes')
        return self


class CreateOTAVerifyJobResponseBodyData(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        utc_create: str = None,
    ):
        # The ID of the verification task.
        self.job_id = job_id
        # The time when the verification task was created. The time is displayed in UTC.
        self.utc_create = utc_create

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.utc_create is not None:
            result['UtcCreate'] = self.utc_create
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('UtcCreate') is not None:
            self.utc_create = m.get('UtcCreate')
        return self


class CreateOTAVerifyJobResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: CreateOTAVerifyJobResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The task information returned if the call is successful. For more information, see the following parameters.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request. The ID uniquely identifies this request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = CreateOTAVerifyJobResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateOTAVerifyJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateOTAVerifyJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateOTAVerifyJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateParserRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        iot_instance_id: str = None,
        name: str = None,
    ):
        self.description = description
        self.iot_instance_id = iot_instance_id
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class CreateParserResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        parser_id: int = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.parser_id = parser_id
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.parser_id is not None:
            result['ParserId'] = self.parser_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('ParserId') is not None:
            self.parser_id = m.get('ParserId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateParserResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateParserResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateParserResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateParserDataSourceRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        iot_instance_id: str = None,
        name: str = None,
    ):
        self.description = description
        self.iot_instance_id = iot_instance_id
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class CreateParserDataSourceResponseBodyDataSource(TeaModel):
    def __init__(
        self,
        data_source_id: int = None,
        description: str = None,
        name: str = None,
        utc_created: str = None,
    ):
        self.data_source_id = data_source_id
        self.description = description
        self.name = name
        self.utc_created = utc_created

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_source_id is not None:
            result['DataSourceId'] = self.data_source_id
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.utc_created is not None:
            result['UtcCreated'] = self.utc_created
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataSourceId') is not None:
            self.data_source_id = m.get('DataSourceId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('UtcCreated') is not None:
            self.utc_created = m.get('UtcCreated')
        return self


class CreateParserDataSourceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data_source: CreateParserDataSourceResponseBodyDataSource = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data_source = data_source
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data_source:
            self.data_source.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data_source is not None:
            result['DataSource'] = self.data_source.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('DataSource') is not None:
            temp_model = CreateParserDataSourceResponseBodyDataSource()
            self.data_source = temp_model.from_map(m['DataSource'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateParserDataSourceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateParserDataSourceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateParserDataSourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateProductRequest(TeaModel):
    def __init__(
        self,
        aliyun_commodity_code: str = None,
        auth_type: str = None,
        category_key: str = None,
        data_format: int = None,
        description: str = None,
        id_2: bool = None,
        iot_instance_id: str = None,
        join_permission_id: str = None,
        net_type: str = None,
        node_type: int = None,
        product_name: str = None,
        protocol_type: str = None,
        publish_auto: bool = None,
        resource_group_id: str = None,
        validate_type: int = None,
    ):
        # The edition of the product.
        # 
        # *   If you do not configure this parameter, a product of the Basic Edition is automatically created. You cannot use a TSL model to define the product.
        # *   If you want to configure this parameter, set the value to **iothub_senior**. A product that supports TSL models is created. You must also configure the **DataFormat** parameter.
        self.aliyun_commodity_code = aliyun_commodity_code
        # The verification method that is used to connect the devices of the product to IoT Platform.
        # 
        # You do not need to configure this parameter. **secret**: uses DeviceSecrets to verify the devices. Default value: secret. For more information, see [MQTT connections over TCP](~~73742~~).
        self.auth_type = auth_type
        # The identifier of the product category. If you configure this parameter, a TSL model of the product category is used. Otherwise, no TSL model is used.
        # 
        # You can call the [ListThingTemplates](~~150316~~) operation to query the details of product categories that are predefined by IoT Platform and obtain category keys.
        self.category_key = category_key
        # The data format.
        # 
        # If the **AliyunCommodityCode** parameter is set to **iothub_senior**, you must configure this parameter.
        # 
        # Valid values:
        # 
        # *   **0**: custom data format.
        # *   **1**: Alink JSON format.
        self.data_format = data_format
        # The description of the product. The description can be up to 100 characters in length.
        self.description = description
        # You do not need to configure this parameter.
        self.id_2 = id_2
        # The ID of the instance. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
        # 
        # 
        # **Important**\
        # 
        # *   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.
        # *   If no **Overview** page or ID is generated for your instance, you do not need to configure this parameter.
        # 
        # For more information about the instance, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # You do not need to configure this parameter.
        self.join_permission_id = join_permission_id
        # The network connection method.
        # 
        # If the **AliyunCommodityCode** parameter is set to **iothub_senior** and the devices of the product are directly connected devices or gateways, you must configure this parameter.
        # 
        # Valid values:
        # 
        # *   **WIFI**: Wi-Fi.
        # *   **CELLULAR**: cellular network.
        # *   **ETHERNET**: Ethernet.
        # *   **OTHER**: other networks.
        # 
        # Default value: WIFI.
        self.net_type = net_type
        # The node type of the product. Valid values:
        # 
        # *   **0**: device. Sub-devices cannot be attached to a device. A device can be directly connected to IoT Platform or connected to IoT Platform as a sub-device of a gateway. If you use the device as a sub-device, you must also configure the **ProtocolType** parameter.
        # *   **1**: gateway. Sub-devices can be attached to a gateway. A gateway can manage sub-devices, maintain topological relationships with sub-devices, and synchronize topological relationships to IoT Platform.
        self.node_type = node_type
        # The name of the product.
        # 
        # The name must be 4 to 30 characters in length, and can contain letters, digits, and underscores (\_).
        # 
        # 
        # **Important** Each product name must be unique within the current instance.
        self.product_name = product_name
        # The protocol used by the devices of the product to connect to the gateway.
        # 
        # If the **AliyunCommodityCode** parameter is set to **iothub_senior** and a gateway is required to connect the devices of the product to IoT Platform, you must configure this parameter.
        # 
        # Valid values:
        # 
        # *   **modbus**: Modbus.
        # *   **opc-ua**: Open Platform Communication Unified Architecture (OPC UA).
        # *   **customize**: custom protocol.
        # *   **ble**: Bluetooth Low Energy (BLE).
        # *   **zigbee**: ZigBee.
        self.protocol_type = protocol_type
        # Specifies whether to publish the TSL model after the product is created.
        # 
        # *   **true**: publishes the TSL model after the product is created.
        # *   **false**: does not publish the TSL model after the product is created.
        # 
        # Default value: **true**.
        self.publish_auto = publish_auto
        # The ID of the resource group to which the product belongs. If you specify a value for this parameter, the product is added to the resource group.
        # 
        # You can log on to the [Resource Management console](https://resourcemanager.console.aliyun.com/resource-groups) to view the ID of the resource group.
        # 
        # 
        # **Important**\
        # 
        # You can specify a value for this parameter only if you have activated Resource Management.
        self.resource_group_id = resource_group_id
        # The level of data verification. If you do not configure this parameter, the default value is used. Valid values:
        # 
        # *   **1**: weak verification. Default value: 1. IoT Platform verifies only the identifier and dataType fields of the data. All data is forwarded.
        # 
        #     In the IoT Platform console, the data is displayed on the **TSL Data** tab of the **Device Details** page. The data that fails to be verified is not displayed.
        # 
        #     You can view the data that failed to be verified in the **checkFailedData** parameter of the forwarded data. For more information, see [Data formats](~~73736~~).
        # 
        # *   **2**: no verification. IoT Platform does not verify the data. All data is forwarded.
        # 
        #     In the IoT Platform console, the data is not displayed on the **TSL Data** tab of the **Device Details** page.
        self.validate_type = validate_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_commodity_code is not None:
            result['AliyunCommodityCode'] = self.aliyun_commodity_code
        if self.auth_type is not None:
            result['AuthType'] = self.auth_type
        if self.category_key is not None:
            result['CategoryKey'] = self.category_key
        if self.data_format is not None:
            result['DataFormat'] = self.data_format
        if self.description is not None:
            result['Description'] = self.description
        if self.id_2 is not None:
            result['Id2'] = self.id_2
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.join_permission_id is not None:
            result['JoinPermissionId'] = self.join_permission_id
        if self.net_type is not None:
            result['NetType'] = self.net_type
        if self.node_type is not None:
            result['NodeType'] = self.node_type
        if self.product_name is not None:
            result['ProductName'] = self.product_name
        if self.protocol_type is not None:
            result['ProtocolType'] = self.protocol_type
        if self.publish_auto is not None:
            result['PublishAuto'] = self.publish_auto
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.validate_type is not None:
            result['ValidateType'] = self.validate_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliyunCommodityCode') is not None:
            self.aliyun_commodity_code = m.get('AliyunCommodityCode')
        if m.get('AuthType') is not None:
            self.auth_type = m.get('AuthType')
        if m.get('CategoryKey') is not None:
            self.category_key = m.get('CategoryKey')
        if m.get('DataFormat') is not None:
            self.data_format = m.get('DataFormat')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id2') is not None:
            self.id_2 = m.get('Id2')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('JoinPermissionId') is not None:
            self.join_permission_id = m.get('JoinPermissionId')
        if m.get('NetType') is not None:
            self.net_type = m.get('NetType')
        if m.get('NodeType') is not None:
            self.node_type = m.get('NodeType')
        if m.get('ProductName') is not None:
            self.product_name = m.get('ProductName')
        if m.get('ProtocolType') is not None:
            self.protocol_type = m.get('ProtocolType')
        if m.get('PublishAuto') is not None:
            self.publish_auto = m.get('PublishAuto')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ValidateType') is not None:
            self.validate_type = m.get('ValidateType')
        return self


class CreateProductResponseBodyData(TeaModel):
    def __init__(
        self,
        aliyun_commodity_code: str = None,
        auth_type: str = None,
        data_format: int = None,
        description: str = None,
        id_2: bool = None,
        node_type: int = None,
        product_key: str = None,
        product_name: str = None,
        product_secret: str = None,
        protocol_type: str = None,
    ):
        # The type of the product.
        # 
        # *   **iothub_senior**: A TSL model was used.
        # *   **iothub**: No TSL model was used.
        self.aliyun_commodity_code = aliyun_commodity_code
        # The authentication method that is used to connect the devices of the product to IoT Platform. Valid values:
        # 
        # *   **secret**: uses DeviceSecrets to verify the devices.
        # *   **id2**: uses IoT Internet Device ID to verify the devices.
        # *   **x509**: uses X.509 certificates to verify the devices.
        self.auth_type = auth_type
        # The data format.
        # 
        # *   **0**: custom data format.
        # *   **1**: Alink JSON format.
        # 
        # >  This parameter is returned only if the AliyunCommodityCode parameter is set to iothub_senior.
        self.data_format = data_format
        # The description of the product.
        self.description = description
        # Indicates whether IoT Internet Device ID was enabled.
        # 
        # *   **true**: IoT Internet Device ID was enabled.
        # *   **false**: IoT Internet Device ID was disabled.
        self.id_2 = id_2
        # The node type of the product. Valid values:
        # 
        # *   **0**: device. Sub-devices cannot be attached to a device. A device can be directly connected to IoT Platform or connected to IoT Platform as a sub-device of a gateway.
        # *   **1**: gateway. Sub-devices can be attached to a gateway. A gateway can manage sub-devices, maintain topological relationships with sub-devices, and synchronize topological relationships to IoT Platform.
        # 
        # >  This parameter is available only if the AliyunCommodityCode parameter is set to iothub_senior.
        self.node_type = node_type
        # The ProductKey of the product. A ProductKey is a globally unique identifier (GUID) issued by IoT Platform to a new product.
        # 
        # >  Secure the **ProductKey** of the product. The ProductKey is required when you perform specific operations.
        self.product_key = product_key
        # The name of the product.
        self.product_name = product_name
        # The ProductSecret of the product.
        self.product_secret = product_secret
        # The protocol used by the devices of the product to connect to the gateway.
        # 
        # >  This parameter is available only if the AliyunCommodityCode parameter is set to iothub_senior.
        self.protocol_type = protocol_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_commodity_code is not None:
            result['AliyunCommodityCode'] = self.aliyun_commodity_code
        if self.auth_type is not None:
            result['AuthType'] = self.auth_type
        if self.data_format is not None:
            result['DataFormat'] = self.data_format
        if self.description is not None:
            result['Description'] = self.description
        if self.id_2 is not None:
            result['Id2'] = self.id_2
        if self.node_type is not None:
            result['NodeType'] = self.node_type
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.product_name is not None:
            result['ProductName'] = self.product_name
        if self.product_secret is not None:
            result['ProductSecret'] = self.product_secret
        if self.protocol_type is not None:
            result['ProtocolType'] = self.protocol_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliyunCommodityCode') is not None:
            self.aliyun_commodity_code = m.get('AliyunCommodityCode')
        if m.get('AuthType') is not None:
            self.auth_type = m.get('AuthType')
        if m.get('DataFormat') is not None:
            self.data_format = m.get('DataFormat')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Id2') is not None:
            self.id_2 = m.get('Id2')
        if m.get('NodeType') is not None:
            self.node_type = m.get('NodeType')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('ProductName') is not None:
            self.product_name = m.get('ProductName')
        if m.get('ProductSecret') is not None:
            self.product_secret = m.get('ProductSecret')
        if m.get('ProtocolType') is not None:
            self.protocol_type = m.get('ProtocolType')
        return self


class CreateProductResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: CreateProductResponseBodyData = None,
        error_message: str = None,
        product_key: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The product information returned if the call is successful.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ProductKey of the product. A ProductKey is a GUID that is issued by IoT Platform to a product.
        self.product_key = product_key
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful. Valid values:
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = CreateProductResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateProductResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateProductResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateProductResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateProductDistributeJobRequest(TeaModel):
    def __init__(
        self,
        product_key: str = None,
        source_instance_id: str = None,
        target_aliyun_id: str = None,
        target_instance_id: str = None,
        target_uid: str = None,
    ):
        # The **ProductKey** of the product to be published.
        self.product_key = product_key
        # The ID of the source instance to which the product belongs.
        # 
        # *   The IDs of public instances in different regions:
        # 
        #     *   China (Shanghai): iotx-oxssharez200.
        #     *   Japan (Tokyo): iotx-oxssharez300.
        #     *   Singapore (Singapore): iotx-oxssharez400.
        #     *   US (Silicon Valley): iotx-oxssharez500.
        #     *   US (Virginia): iotx-oxssharez600.
        #     *   Germany (Frankfurt): iotx-oxssharez700.
        # 
        # *   The IDs of Enterprise Edition instances:
        # 
        #     1\. Log on to the IoT Platform console. Select a region from the drop-down list in the upper-left corner of the top navigation bar.
        # 
        #     2\. On the **Overview** page, click the instance name. On the **Instance Details** page, view the instance ID in the **Basic Information** section.
        self.source_instance_id = source_instance_id
        # The Alibaba Cloud account to which the product belongs. You can log on to the IoT Platform console, click the profile picture, and then view **Logon Account** on the **Security Settings** page.
        # 
        # The **TargetUid** and **TargetAliyunId** parameters cannot be left empty at the same time.
        self.target_aliyun_id = target_aliyun_id
        # The ID of the destination instance to which the product is distributed. For more information about instance IDs, see the description of the **SourceInstanceId** parameter.
        self.target_instance_id = target_instance_id
        # The ID of the Alibaba Cloud account to which the product belongs. You can log on to the IoT Platform console, click the profile picture, and then view **Account ID** on the **Security Settings** page.
        # 
        # The **TargetUid** and **TargetAliyunId** parameters cannot be left empty at the same time.
        self.target_uid = target_uid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.source_instance_id is not None:
            result['SourceInstanceId'] = self.source_instance_id
        if self.target_aliyun_id is not None:
            result['TargetAliyunId'] = self.target_aliyun_id
        if self.target_instance_id is not None:
            result['TargetInstanceId'] = self.target_instance_id
        if self.target_uid is not None:
            result['TargetUid'] = self.target_uid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('SourceInstanceId') is not None:
            self.source_instance_id = m.get('SourceInstanceId')
        if m.get('TargetAliyunId') is not None:
            self.target_aliyun_id = m.get('TargetAliyunId')
        if m.get('TargetInstanceId') is not None:
            self.target_instance_id = m.get('TargetInstanceId')
        if m.get('TargetUid') is not None:
            self.target_uid = m.get('TargetUid')
        return self


class CreateProductDistributeJobResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        job_id: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The task ID returned if the call is successful. The ID globally identifies the task.
        self.job_id = job_id
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateProductDistributeJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateProductDistributeJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateProductDistributeJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateProductTagsRequestProductTag(TeaModel):
    def __init__(
        self,
        tag_key: str = None,
        tag_value: str = None,
    ):
        # The keys of product tags. Each key must be 1 to 30 characters in length, and can contain letters, digits, and periods (.).
        # 
        # 
        # **Important** `abc` is a **key** that is reserved by IoT Platform. You cannot set a **key** to `abc`. If you set a `key` to abc, the key is automatically filtered when you query tags.
        self.tag_key = tag_key
        # The values of the product tags. Each tag value must be 1 to 128 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-).
        self.tag_value = tag_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        return self


class CreateProductTagsRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        product_key: str = None,
        product_tag: List[CreateProductTagsRequestProductTag] = None,
    ):
        # The ID of the instance. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
        # 
        # 
        # **Important**\
        # 
        # *   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.
        # *   If no **Overview** page or ID is generated for your instance, you do not need to configure this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The **ProductKey** of the product. A **ProductKey** is a GUID that is issued by IoT Platform to a product.
        # 
        # You can use the IoT Platform console or call the [QueryProductList](~~69271~~) operation to view the information about all products within the current account.
        self.product_key = product_key
        self.product_tag = product_tag

    def validate(self):
        if self.product_tag:
            for k in self.product_tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        result['ProductTag'] = []
        if self.product_tag is not None:
            for k in self.product_tag:
                result['ProductTag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        self.product_tag = []
        if m.get('ProductTag') is not None:
            for k in m.get('ProductTag'):
                temp_model = CreateProductTagsRequestProductTag()
                self.product_tag.append(temp_model.from_map(k))
        return self


class CreateProductTagsResponseBodyInvalidProductTagsProductTag(TeaModel):
    def __init__(
        self,
        tag_key: str = None,
        tag_value: str = None,
    ):
        # The key of the tag.
        self.tag_key = tag_key
        # The value of the tag.
        self.tag_value = tag_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        return self


class CreateProductTagsResponseBodyInvalidProductTags(TeaModel):
    def __init__(
        self,
        product_tag: List[CreateProductTagsResponseBodyInvalidProductTagsProductTag] = None,
    ):
        self.product_tag = product_tag

    def validate(self):
        if self.product_tag:
            for k in self.product_tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ProductTag'] = []
        if self.product_tag is not None:
            for k in self.product_tag:
                result['ProductTag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.product_tag = []
        if m.get('ProductTag') is not None:
            for k in m.get('ProductTag'):
                temp_model = CreateProductTagsResponseBodyInvalidProductTagsProductTag()
                self.product_tag.append(temp_model.from_map(k))
        return self


class CreateProductTagsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        invalid_product_tags: CreateProductTagsResponseBodyInvalidProductTags = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the request fails.
        self.error_message = error_message
        # The invalid product tags returned if the call fails.
        self.invalid_product_tags = invalid_product_tags
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful. The tags were attached to the product.
        # *   **false**: The call failed. This value indicates that the tags failed to be attached to the product.
        self.success = success

    def validate(self):
        if self.invalid_product_tags:
            self.invalid_product_tags.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.invalid_product_tags is not None:
            result['InvalidProductTags'] = self.invalid_product_tags.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('InvalidProductTags') is not None:
            temp_model = CreateProductTagsResponseBodyInvalidProductTags()
            self.invalid_product_tags = temp_model.from_map(m['InvalidProductTags'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateProductTagsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateProductTagsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateProductTagsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateProductTopicRequest(TeaModel):
    def __init__(
        self,
        codec: str = None,
        desc: str = None,
        enable_proxy_subscribe: bool = None,
        iot_instance_id: str = None,
        operation: str = None,
        product_key: str = None,
        topic_short_name: str = None,
    ):
        self.codec = codec
        # The description of the topic category. The description must be 1 to 100 characters in length.
        self.desc = desc
        self.enable_proxy_subscribe = enable_proxy_subscribe
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The operation permissions of the device on the topic category. Valid values:
        # 
        # *   **SUB**: Subscribe.
        # *   **PUB**: Publish.
        # *   **ALL**: Publish and Subscribe.
        self.operation = operation
        # The ProductKey of the product for which you want to create a topic category.
        self.product_key = product_key
        # The name of the user-defined category level that you want to set. By default, a topic category includes the following levels: \_productkey\_ and \_devicename\_. Separate the two levels with slashes (/). Format of a topic category: `productKey/deviceName/topicShortName` .
        # 
        # >  Each level can contain letters, digits, and underscores (\_), and cannot be empty.
        self.topic_short_name = topic_short_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.desc is not None:
            result['Desc'] = self.desc
        if self.enable_proxy_subscribe is not None:
            result['EnableProxySubscribe'] = self.enable_proxy_subscribe
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.operation is not None:
            result['Operation'] = self.operation
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.topic_short_name is not None:
            result['TopicShortName'] = self.topic_short_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Desc') is not None:
            self.desc = m.get('Desc')
        if m.get('EnableProxySubscribe') is not None:
            self.enable_proxy_subscribe = m.get('EnableProxySubscribe')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('Operation') is not None:
            self.operation = m.get('Operation')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('TopicShortName') is not None:
            self.topic_short_name = m.get('TopicShortName')
        return self


class CreateProductTopicResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        topic_id: int = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success
        # The ID of the topic category. The ID is generated by IoT Platform if the call is successful.
        # 
        # >  Secure the information for future reference. When you call an operation that is related to the topic category, you must provide this parameter.
        self.topic_id = topic_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.topic_id is not None:
            result['TopicId'] = self.topic_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TopicId') is not None:
            self.topic_id = m.get('TopicId')
        return self


class CreateProductTopicResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateProductTopicResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateProductTopicResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateRuleRequest(TeaModel):
    def __init__(
        self,
        data_type: str = None,
        iot_instance_id: str = None,
        name: str = None,
        product_key: str = None,
        resource_group_id: str = None,
        rule_desc: str = None,
        select: str = None,
        short_topic: str = None,
        topic: str = None,
        topic_type: int = None,
        where: str = None,
    ):
        # The format of the data that is processed based on the rule. The value of this parameter must be consistent with the format of device data that you want to process. Valid values:
        # 
        # *   **JSON**: JSON data. This is the default value.
        # *   **BINARY**: binary data.
        # 
        # >  If this parameter is set to **BINARY**, you cannot set the **TopicType** parameter to 0 and cannot forward data to Tablestore and ApsaraDB RDS.
        self.data_type = data_type
        # The ID of the instance. On the **Overview** page in the IoT Platform console, you can view the **ID** of the instance.
        # 
        # >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.
        # >*   If the **Overview** page or instance ID is not displayed in the IoT Platform console, you do not need to configure this parameter.
        # 
        # For more information about the instance, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The name of the data forwarding rule. The rule name must be 1 to 30 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-).
        self.name = name
        # The ProductKey of the product to which the rule applies.
        self.product_key = product_key
        # The ID of the resource group to which the rule is assigned. You can view the resource group information in the [Resource Management console](https://resourcemanager.console.aliyun.com/resource-groups).
        # 
        # >You can specify a value for this parameter only if you have activated Resource Management.
        # 
        # If you do not specify this parameter, the rule is assigned to the default resource group.
        self.resource_group_id = resource_group_id
        # The description of the rule. The description can be up to 100 characters in length.
        self.rule_desc = rule_desc
        # The SQL SELECT statement that you want to execute. For more information about the syntax, see [SQL statements](~~30554~~).
        # 
        # >  This parameter specifies the fields in SELECT statements. For example, if the SELECT statement is `SELECT a,b,c`, specify `a,b,c` for this parameter.
        self.select = select
        # The topic to which this rule is applied. Format: `${deviceName}/topicShortName`. `${deviceName}` specifies the name of the device, and `topicShortName` specifies the custom name of the topic.
        # 
        # *   Basic communication topics or Thing Specification Language (TSL)-based communication topics. Format: `${deviceName}/topicShortName`. You can replace `${deviceName}` with the `+` wildcard character. The wildcard character indicates that the topic applies to all devices under the product. Valid values of `topicShortName`:
        # 
        #     *   `/thing/event/property/post`: submits the property data of a device.
        # 
        #     *   `/thing/event/${tsl.event.identifier}/post`: submits the event data of a device. `${tsl.event.identifier}` specifies the identifier of an event in the TSL model.
        # 
        #     *   `/thing/lifecycle`: submits device lifecycle changes.
        # 
        #     *   `/thing/downlink/reply/message`: sends a response to a request from IoT Platform.
        # 
        #     *   `/thing/list/found`: submits the data when a gateway detects a new sub-device.
        # 
        #     *   `/thing/topo/lifecycle`: submits device topology changes.
        # 
        #     *   `/thing/event/property/history/post`: submits the historical property data of a device.
        # 
        #     *   `/thing/event/${tsl.event.identifier}/post`: submits the historical event data of a device. `${tsl.event.identifier}` specifies the identifier of an event in the TSL model.
        # 
        #     *   `/ota/upgrade`: submits the OTA update status.
        # 
        #     *   `/ota/version/post`: submits OTA module versions.
        # 
        #     *   `/thing/deviceinfo/update`: submits device tag changes.
        # 
        #     *   `/edge/driver/${driver_id}/point_post`: submits pass-through data from Link IoT Edge. `${driver_id}` specifies the ID of the driver that a device uses to access Link IoT Edge.
        # 
        #         The `${packageId}/${jobId}/ota/job/status` topic submits the status of OTA update batches. This topic is a basic communication topic. `${packageId}` specifies the ID of the update package. `${jobId}` specifies the ID of the update batch.
        # 
        # *   Custom topics. Example: `${deviceName}/user/get`.
        # 
        #     You can call the [QueryProductTopic](~~69647~~) operation to view all custom topics of the product.
        # 
        #     When you specify a custom topic, you can use the `+` and `#` wildcard characters.
        # 
        #     *   You can replace `${deviceName}` with the `+` wildcard character. The wildcard character specifies that the topic applies to all devices in the product.
        # 
        #     *   You can add `/user/#` after ${deviceName}. The `#` wildcard character can match all field values at the levels that follow `/user`.
        # 
        #         For more information about how to use wildcard characters, see [Custom topics with one or more wildcard characters](~~85539~~).
        # 
        # *   Topics that are used to submit device status changes. The topic name is in the `${deviceName}` format.
        # 
        #     You can use the `+` wildcard character. In this case, the status changes of all devices under the product are submitted.
        self.short_topic = short_topic
        # The complete topic to which the rule applies.
        # 
        # If you specify this parameter, you do not need to specify the **ShortTopic** and **TopicType** parameters.
        self.topic = topic
        # *   **0**: The topic is a basic communication topic or TSL-based communication topic. The topic that is used to submit the status of OTA update batches belongs to the basic communication topics.****\
        # *   **1**: a custom topic.
        # *   **2**: The topic is used to submit device status changes. Format: `/as/mqtt/status/${productKey}/${deviceName}`.
        self.topic_type = topic_type
        # The condition that is used to trigger the rule. For more information about the rule, see [SQL statements](~~30554~~).
        # 
        # >  This parameter specifies the fields in the **WHERE** clause. For example, if the **WHERE** clause is `WHERE a > 10`, you must specify `a > 10` for this parameter.
        self.where = where

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_type is not None:
            result['DataType'] = self.data_type
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.name is not None:
            result['Name'] = self.name
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.rule_desc is not None:
            result['RuleDesc'] = self.rule_desc
        if self.select is not None:
            result['Select'] = self.select
        if self.short_topic is not None:
            result['ShortTopic'] = self.short_topic
        if self.topic is not None:
            result['Topic'] = self.topic
        if self.topic_type is not None:
            result['TopicType'] = self.topic_type
        if self.where is not None:
            result['Where'] = self.where
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataType') is not None:
            self.data_type = m.get('DataType')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('RuleDesc') is not None:
            self.rule_desc = m.get('RuleDesc')
        if m.get('Select') is not None:
            self.select = m.get('Select')
        if m.get('ShortTopic') is not None:
            self.short_topic = m.get('ShortTopic')
        if m.get('Topic') is not None:
            self.topic = m.get('Topic')
        if m.get('TopicType') is not None:
            self.topic_type = m.get('TopicType')
        if m.get('Where') is not None:
            self.where = m.get('Where')
        return self


class CreateRuleResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        rule_id: int = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request. The ID uniquely identifies this request.
        self.request_id = request_id
        # The ID of the rule. If the call succeeds, the rule ID is generated by the rules engine.
        # 
        # >  Keep the information safe for future reference. You must provide the rule ID when you want to call rule-related operations.
        self.rule_id = rule_id
        # Indicates whether the call was successful. Valid values:
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateRuleActionRequest(TeaModel):
    def __init__(
        self,
        configuration: str = None,
        error_action_flag: bool = None,
        iot_instance_id: str = None,
        rule_id: int = None,
        type: str = None,
    ):
        # The configurations of the rule action. You must specify a JSON string. The configurations vary based on the types of rule actions. For more information about required syntax and examples, see the following tables.
        self.configuration = configuration
        # Specifies whether the rule action forwards error operation data. Error operation data is generated when the rules engine failed to forward data from the IoT Platform topic to the destination cloud service. A data forwarding failure indicates that forwarding retries also fail. Valid values:
        # 
        # *   **true**: forwards error operation data.
        # *   **false**: forwards normal data instead of error operation data.
        # 
        # Default value: **false**.
        self.error_action_flag = error_action_flag
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The ID of the rule for which you want to create an action. You can log on to the IoT Platform console, and choose **Rules** > **Data Forwarding** to view the rule ID. You can also call the [ListRule](~~69486~~) operation and view the rule ID in the response.
        self.rule_id = rule_id
        # The type of the rule action. Valid values:
        # 
        # *   **REPUBLISH**: forwards topic data that is processed by the rules engine to another IoT Platform topic.
        # *   **AMQP**: forwards data to an AMQP consumer group.
        # *   **MNS**: forwards data that is processed by the rules engine to Message Service (MNS).
        # *   **FC**: forwards topic data that is processed by the rules engine to Function Compute for event computing.
        # *   **OTS**: forwards data that is processed by the rules engine to OTS for NoSQL data storage.
        # 
        # >  If you set the **DataType** parameter to **BINARY**, rules are created in the binary format. These rules cannot be used to forward data to Tablestore.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.configuration is not None:
            result['Configuration'] = self.configuration
        if self.error_action_flag is not None:
            result['ErrorActionFlag'] = self.error_action_flag
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Configuration') is not None:
            self.configuration = m.get('Configuration')
        if m.get('ErrorActionFlag') is not None:
            self.error_action_flag = m.get('ErrorActionFlag')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateRuleActionResponseBody(TeaModel):
    def __init__(
        self,
        action_id: int = None,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The ID of the action. The action ID is generated by the rules engine if the call is successful.
        # 
        # >  Secure the information for future reference. When you call an operation that is related to the rule action, you must provide the action ID.
        self.action_id = action_id
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_id is not None:
            result['ActionId'] = self.action_id
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActionId') is not None:
            self.action_id = m.get('ActionId')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateRuleActionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateRuleActionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateRuleActionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateSceneRuleRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        rule_content: str = None,
        rule_description: str = None,
        rule_name: str = None,
    ):
        self.iot_instance_id = iot_instance_id
        self.rule_content = rule_content
        self.rule_description = rule_description
        self.rule_name = rule_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.rule_content is not None:
            result['RuleContent'] = self.rule_content
        if self.rule_description is not None:
            result['RuleDescription'] = self.rule_description
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('RuleContent') is not None:
            self.rule_content = m.get('RuleContent')
        if m.get('RuleDescription') is not None:
            self.rule_description = m.get('RuleDescription')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        return self


class CreateSceneRuleResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        rule_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.rule_id = rule_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateSceneRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateSceneRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateSceneRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateSchedulePeriodRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        end_time: str = None,
        iot_instance_id: str = None,
        schedule_code: str = None,
        sound_code_content: str = None,
        start_time: str = None,
    ):
        self.description = description
        self.end_time = end_time
        self.iot_instance_id = iot_instance_id
        self.schedule_code = schedule_code
        self.sound_code_content = sound_code_content
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.schedule_code is not None:
            result['ScheduleCode'] = self.schedule_code
        if self.sound_code_content is not None:
            result['SoundCodeContent'] = self.sound_code_content
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ScheduleCode') is not None:
            self.schedule_code = m.get('ScheduleCode')
        if m.get('SoundCodeContent') is not None:
            self.sound_code_content = m.get('SoundCodeContent')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class CreateSchedulePeriodResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateSchedulePeriodResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateSchedulePeriodResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateSchedulePeriodResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateSharePromotionActivityRequest(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        iot_instance_id: str = None,
        share_promotion_activity_name: str = None,
        start_time: int = None,
    ):
        self.end_time = end_time
        self.iot_instance_id = iot_instance_id
        self.share_promotion_activity_name = share_promotion_activity_name
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.share_promotion_activity_name is not None:
            result['SharePromotionActivityName'] = self.share_promotion_activity_name
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('SharePromotionActivityName') is not None:
            self.share_promotion_activity_name = m.get('SharePromotionActivityName')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class CreateSharePromotionActivityResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateSharePromotionActivityResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateSharePromotionActivityResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateSharePromotionActivityResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateSharePromotionSpeechModelRequest(TeaModel):
    def __init__(
        self,
        audio_format: str = None,
        biz_code: str = None,
        iot_instance_id: str = None,
        share_promotion_activity_id: str = None,
        share_task_code: str = None,
        speech_model_type: str = None,
        speech_rate: int = None,
        text: str = None,
        voice: str = None,
        volume: int = None,
    ):
        self.audio_format = audio_format
        self.biz_code = biz_code
        self.iot_instance_id = iot_instance_id
        self.share_promotion_activity_id = share_promotion_activity_id
        self.share_task_code = share_task_code
        self.speech_model_type = speech_model_type
        self.speech_rate = speech_rate
        self.text = text
        self.voice = voice
        self.volume = volume

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_format is not None:
            result['AudioFormat'] = self.audio_format
        if self.biz_code is not None:
            result['BizCode'] = self.biz_code
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.share_promotion_activity_id is not None:
            result['SharePromotionActivityId'] = self.share_promotion_activity_id
        if self.share_task_code is not None:
            result['ShareTaskCode'] = self.share_task_code
        if self.speech_model_type is not None:
            result['SpeechModelType'] = self.speech_model_type
        if self.speech_rate is not None:
            result['SpeechRate'] = self.speech_rate
        if self.text is not None:
            result['Text'] = self.text
        if self.voice is not None:
            result['Voice'] = self.voice
        if self.volume is not None:
            result['Volume'] = self.volume
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioFormat') is not None:
            self.audio_format = m.get('AudioFormat')
        if m.get('BizCode') is not None:
            self.biz_code = m.get('BizCode')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('SharePromotionActivityId') is not None:
            self.share_promotion_activity_id = m.get('SharePromotionActivityId')
        if m.get('ShareTaskCode') is not None:
            self.share_task_code = m.get('ShareTaskCode')
        if m.get('SpeechModelType') is not None:
            self.speech_model_type = m.get('SpeechModelType')
        if m.get('SpeechRate') is not None:
            self.speech_rate = m.get('SpeechRate')
        if m.get('Text') is not None:
            self.text = m.get('Text')
        if m.get('Voice') is not None:
            self.voice = m.get('Voice')
        if m.get('Volume') is not None:
            self.volume = m.get('Volume')
        return self


class CreateSharePromotionSpeechModelResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateSharePromotionSpeechModelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateSharePromotionSpeechModelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateSharePromotionSpeechModelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateSoundCodeRequest(TeaModel):
    def __init__(
        self,
        duration: int = None,
        iot_instance_id: str = None,
        name: str = None,
        open_type: str = None,
        sound_code_content: str = None,
    ):
        self.duration = duration
        self.iot_instance_id = iot_instance_id
        self.name = name
        self.open_type = open_type
        self.sound_code_content = sound_code_content

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.name is not None:
            result['Name'] = self.name
        if self.open_type is not None:
            result['OpenType'] = self.open_type
        if self.sound_code_content is not None:
            result['SoundCodeContent'] = self.sound_code_content
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OpenType') is not None:
            self.open_type = m.get('OpenType')
        if m.get('SoundCodeContent') is not None:
            self.sound_code_content = m.get('SoundCodeContent')
        return self


class CreateSoundCodeResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateSoundCodeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateSoundCodeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateSoundCodeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateSoundCodeLabelRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        label: str = None,
        schedule_code: str = None,
    ):
        self.iot_instance_id = iot_instance_id
        self.label = label
        self.schedule_code = schedule_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.label is not None:
            result['Label'] = self.label
        if self.schedule_code is not None:
            result['ScheduleCode'] = self.schedule_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('ScheduleCode') is not None:
            self.schedule_code = m.get('ScheduleCode')
        return self


class CreateSoundCodeLabelResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateSoundCodeLabelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateSoundCodeLabelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateSoundCodeLabelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateSoundCodeScheduleRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        end_date: str = None,
        iot_instance_id: str = None,
        name: str = None,
        open_type: str = None,
        start_date: str = None,
    ):
        self.description = description
        self.end_date = end_date
        self.iot_instance_id = iot_instance_id
        self.name = name
        self.open_type = open_type
        self.start_date = start_date

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.end_date is not None:
            result['EndDate'] = self.end_date
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.name is not None:
            result['Name'] = self.name
        if self.open_type is not None:
            result['OpenType'] = self.open_type
        if self.start_date is not None:
            result['StartDate'] = self.start_date
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EndDate') is not None:
            self.end_date = m.get('EndDate')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OpenType') is not None:
            self.open_type = m.get('OpenType')
        if m.get('StartDate') is not None:
            self.start_date = m.get('StartDate')
        return self


class CreateSoundCodeScheduleResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateSoundCodeScheduleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateSoundCodeScheduleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateSoundCodeScheduleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateSpeechRequest(TeaModel):
    def __init__(
        self,
        audio_format: str = None,
        biz_code: str = None,
        enable_sound_code: bool = None,
        iot_instance_id: str = None,
        project_code: str = None,
        sound_code_config: Dict[str, Any] = None,
        speech_rate: int = None,
        speech_type: str = None,
        text: str = None,
        voice: str = None,
        volume: int = None,
    ):
        self.audio_format = audio_format
        self.biz_code = biz_code
        self.enable_sound_code = enable_sound_code
        self.iot_instance_id = iot_instance_id
        self.project_code = project_code
        self.sound_code_config = sound_code_config
        self.speech_rate = speech_rate
        self.speech_type = speech_type
        self.text = text
        self.voice = voice
        self.volume = volume

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_format is not None:
            result['AudioFormat'] = self.audio_format
        if self.biz_code is not None:
            result['BizCode'] = self.biz_code
        if self.enable_sound_code is not None:
            result['EnableSoundCode'] = self.enable_sound_code
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.project_code is not None:
            result['ProjectCode'] = self.project_code
        if self.sound_code_config is not None:
            result['SoundCodeConfig'] = self.sound_code_config
        if self.speech_rate is not None:
            result['SpeechRate'] = self.speech_rate
        if self.speech_type is not None:
            result['SpeechType'] = self.speech_type
        if self.text is not None:
            result['Text'] = self.text
        if self.voice is not None:
            result['Voice'] = self.voice
        if self.volume is not None:
            result['Volume'] = self.volume
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioFormat') is not None:
            self.audio_format = m.get('AudioFormat')
        if m.get('BizCode') is not None:
            self.biz_code = m.get('BizCode')
        if m.get('EnableSoundCode') is not None:
            self.enable_sound_code = m.get('EnableSoundCode')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProjectCode') is not None:
            self.project_code = m.get('ProjectCode')
        if m.get('SoundCodeConfig') is not None:
            self.sound_code_config = m.get('SoundCodeConfig')
        if m.get('SpeechRate') is not None:
            self.speech_rate = m.get('SpeechRate')
        if m.get('SpeechType') is not None:
            self.speech_type = m.get('SpeechType')
        if m.get('Text') is not None:
            self.text = m.get('Text')
        if m.get('Voice') is not None:
            self.voice = m.get('Voice')
        if m.get('Volume') is not None:
            self.volume = m.get('Volume')
        return self


class CreateSpeechShrinkRequest(TeaModel):
    def __init__(
        self,
        audio_format: str = None,
        biz_code: str = None,
        enable_sound_code: bool = None,
        iot_instance_id: str = None,
        project_code: str = None,
        sound_code_config_shrink: str = None,
        speech_rate: int = None,
        speech_type: str = None,
        text: str = None,
        voice: str = None,
        volume: int = None,
    ):
        self.audio_format = audio_format
        self.biz_code = biz_code
        self.enable_sound_code = enable_sound_code
        self.iot_instance_id = iot_instance_id
        self.project_code = project_code
        self.sound_code_config_shrink = sound_code_config_shrink
        self.speech_rate = speech_rate
        self.speech_type = speech_type
        self.text = text
        self.voice = voice
        self.volume = volume

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_format is not None:
            result['AudioFormat'] = self.audio_format
        if self.biz_code is not None:
            result['BizCode'] = self.biz_code
        if self.enable_sound_code is not None:
            result['EnableSoundCode'] = self.enable_sound_code
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.project_code is not None:
            result['ProjectCode'] = self.project_code
        if self.sound_code_config_shrink is not None:
            result['SoundCodeConfig'] = self.sound_code_config_shrink
        if self.speech_rate is not None:
            result['SpeechRate'] = self.speech_rate
        if self.speech_type is not None:
            result['SpeechType'] = self.speech_type
        if self.text is not None:
            result['Text'] = self.text
        if self.voice is not None:
            result['Voice'] = self.voice
        if self.volume is not None:
            result['Volume'] = self.volume
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioFormat') is not None:
            self.audio_format = m.get('AudioFormat')
        if m.get('BizCode') is not None:
            self.biz_code = m.get('BizCode')
        if m.get('EnableSoundCode') is not None:
            self.enable_sound_code = m.get('EnableSoundCode')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProjectCode') is not None:
            self.project_code = m.get('ProjectCode')
        if m.get('SoundCodeConfig') is not None:
            self.sound_code_config_shrink = m.get('SoundCodeConfig')
        if m.get('SpeechRate') is not None:
            self.speech_rate = m.get('SpeechRate')
        if m.get('SpeechType') is not None:
            self.speech_type = m.get('SpeechType')
        if m.get('Text') is not None:
            self.text = m.get('Text')
        if m.get('Voice') is not None:
            self.voice = m.get('Voice')
        if m.get('Volume') is not None:
            self.volume = m.get('Volume')
        return self


class CreateSpeechResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateSpeechResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateSpeechResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateSpeechResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateStudioAppDomainOpenRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        host: str = None,
        iot_instance_id: str = None,
        project_id: str = None,
        protocol: str = None,
    ):
        self.app_id = app_id
        self.host = host
        self.iot_instance_id = iot_instance_id
        self.project_id = project_id
        self.protocol = protocol

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.host is not None:
            result['Host'] = self.host
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.protocol is not None:
            result['Protocol'] = self.protocol
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Protocol') is not None:
            self.protocol = m.get('Protocol')
        return self


class CreateStudioAppDomainOpenResponseBodyData(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        host: str = None,
        id: int = None,
        is_beian: str = None,
        project_id: str = None,
        protocol: str = None,
        tenant_id: str = None,
    ):
        self.app_id = app_id
        self.host = host
        self.id = id
        self.is_beian = is_beian
        self.project_id = project_id
        self.protocol = protocol
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.host is not None:
            result['Host'] = self.host
        if self.id is not None:
            result['Id'] = self.id
        if self.is_beian is not None:
            result['IsBeian'] = self.is_beian
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.protocol is not None:
            result['Protocol'] = self.protocol
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('IsBeian') is not None:
            self.is_beian = m.get('IsBeian')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Protocol') is not None:
            self.protocol = m.get('Protocol')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        return self


class CreateStudioAppDomainOpenResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: CreateStudioAppDomainOpenResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = CreateStudioAppDomainOpenResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateStudioAppDomainOpenResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateStudioAppDomainOpenResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateStudioAppDomainOpenResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateSubscribeRelationRequest(TeaModel):
    def __init__(
        self,
        consumer_group_ids: List[str] = None,
        device_data_flag: bool = None,
        device_life_cycle_flag: bool = None,
        device_status_change_flag: bool = None,
        device_tag_flag: bool = None,
        device_topo_life_cycle_flag: bool = None,
        found_device_list_flag: bool = None,
        iot_instance_id: str = None,
        mns_configuration: str = None,
        ota_event_flag: bool = None,
        ota_job_flag: bool = None,
        ota_version_flag: bool = None,
        product_key: str = None,
        subscribe_flags: str = None,
        thing_history_flag: bool = None,
        type: str = None,
    ):
        self.consumer_group_ids = consumer_group_ids
        # Specifies whether to push upstream device messages. Valid values:
        # 
        # *   **true**: yes.
        # *   **false**: no. This is the default value.
        self.device_data_flag = device_data_flag
        # Specifies whether to push messages about device lifecycle changes. Valid values:
        # 
        # *   **true**: yes.
        # *   **false**: no. This is the default value.
        self.device_life_cycle_flag = device_life_cycle_flag
        # Specifies whether to push messages about device status changes. Valid values:
        # 
        # *   **true**: yes.
        # *   **false**: no. This is the default value.
        self.device_status_change_flag = device_status_change_flag
        # Specifies whether to push messages about device tag changes. Valid values:
        # 
        # *   **true**: yes. This parameter is valid only if you set the **Type** parameter to **AMQP**.
        # *   **false**: no. This is the default value.
        self.device_tag_flag = device_tag_flag
        # Specifies whether to push messages about topological relationship changes of devices. Valid values:
        # 
        # *   **true**: yes. This parameter is valid only for gateway products.
        # *   **false**: no. This is the default value.
        self.device_topo_life_cycle_flag = device_topo_life_cycle_flag
        # Specifies whether to push messages when a gateway detects new sub-devices. Valid values:
        # 
        # *   **true**: yes. This parameter is valid only for gateway products.
        # *   **false**: no. This is the default value.
        self.found_device_list_flag = found_device_list_flag
        # The ID of the instance. You can view the ID of the instance on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.****\
        # >*   If no **Overview** page or **ID** is generated for your instance, you do not need to configure this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The configurations of the MNS queue. If you set the **Type** parameter to **AMQP**, this parameter is required.
        # 
        # For more information, see the "Definition of the MnsConfiguration parameter" section.
        self.mns_configuration = mns_configuration
        # Specifies whether to push notifications about the status of over-the-air (OTA) update batches. Valid values:
        # 
        # *   **true**: yes.
        # *   **false**: no. This is the default value.
        self.ota_event_flag = ota_event_flag
        # Specifies whether to push notifications about the status of OTA update batches. Valid values:
        # 
        # *   **true**: yes. This parameter is valid only if you set the **Type** parameter to **AMQP**.
        # *   **false**: no. This is the default value.
        self.ota_job_flag = ota_job_flag
        # Specifies whether to push messages about the version numbers of OTA modules. Valid values:
        # 
        # *   **true**: yes. This parameter is valid only if you set the **Type** parameter to **AMQP**.
        # *   **false**: no. This is the default value.
        self.ota_version_flag = ota_version_flag
        # The **ProductKey** of the product that is specified for the subscription.
        self.product_key = product_key
        # Specifies whether to receive the messages of a specific subscribed product.
        # 
        # If you subscribe to JT/T 808 gateway products, you must configure the **SubscribeFlags** parameter. Set the value to the following code.
        # 
        # ```
        # 
        # {
        #     "jt808DeviceDataFlag": true
        # }
        # ```
        self.subscribe_flags = subscribe_flags
        # Specifies whether to push upstream historical Thing Specification Language (TSL) data. Valid values:
        # 
        # *   **true**: yes.
        # *   **false**: no. This is the default value.
        self.thing_history_flag = thing_history_flag
        # The type of the subscription. Valid values:
        # 
        # *   **MNS**\
        # *   **AMQP**\
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.consumer_group_ids is not None:
            result['ConsumerGroupIds'] = self.consumer_group_ids
        if self.device_data_flag is not None:
            result['DeviceDataFlag'] = self.device_data_flag
        if self.device_life_cycle_flag is not None:
            result['DeviceLifeCycleFlag'] = self.device_life_cycle_flag
        if self.device_status_change_flag is not None:
            result['DeviceStatusChangeFlag'] = self.device_status_change_flag
        if self.device_tag_flag is not None:
            result['DeviceTagFlag'] = self.device_tag_flag
        if self.device_topo_life_cycle_flag is not None:
            result['DeviceTopoLifeCycleFlag'] = self.device_topo_life_cycle_flag
        if self.found_device_list_flag is not None:
            result['FoundDeviceListFlag'] = self.found_device_list_flag
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.mns_configuration is not None:
            result['MnsConfiguration'] = self.mns_configuration
        if self.ota_event_flag is not None:
            result['OtaEventFlag'] = self.ota_event_flag
        if self.ota_job_flag is not None:
            result['OtaJobFlag'] = self.ota_job_flag
        if self.ota_version_flag is not None:
            result['OtaVersionFlag'] = self.ota_version_flag
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.subscribe_flags is not None:
            result['SubscribeFlags'] = self.subscribe_flags
        if self.thing_history_flag is not None:
            result['ThingHistoryFlag'] = self.thing_history_flag
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConsumerGroupIds') is not None:
            self.consumer_group_ids = m.get('ConsumerGroupIds')
        if m.get('DeviceDataFlag') is not None:
            self.device_data_flag = m.get('DeviceDataFlag')
        if m.get('DeviceLifeCycleFlag') is not None:
            self.device_life_cycle_flag = m.get('DeviceLifeCycleFlag')
        if m.get('DeviceStatusChangeFlag') is not None:
            self.device_status_change_flag = m.get('DeviceStatusChangeFlag')
        if m.get('DeviceTagFlag') is not None:
            self.device_tag_flag = m.get('DeviceTagFlag')
        if m.get('DeviceTopoLifeCycleFlag') is not None:
            self.device_topo_life_cycle_flag = m.get('DeviceTopoLifeCycleFlag')
        if m.get('FoundDeviceListFlag') is not None:
            self.found_device_list_flag = m.get('FoundDeviceListFlag')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('MnsConfiguration') is not None:
            self.mns_configuration = m.get('MnsConfiguration')
        if m.get('OtaEventFlag') is not None:
            self.ota_event_flag = m.get('OtaEventFlag')
        if m.get('OtaJobFlag') is not None:
            self.ota_job_flag = m.get('OtaJobFlag')
        if m.get('OtaVersionFlag') is not None:
            self.ota_version_flag = m.get('OtaVersionFlag')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('SubscribeFlags') is not None:
            self.subscribe_flags = m.get('SubscribeFlags')
        if m.get('ThingHistoryFlag') is not None:
            self.thing_history_flag = m.get('ThingHistoryFlag')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateSubscribeRelationResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code that is returned if the call fails. For more information about error codes, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful. Valid values:
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateSubscribeRelationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateSubscribeRelationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateSubscribeRelationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateThingModelRequest(TeaModel):
    def __init__(
        self,
        function_block_id: str = None,
        function_block_name: str = None,
        iot_instance_id: str = None,
        product_key: str = None,
        thing_model_json: str = None,
    ):
        # The identifier of the custom TSL module. Each identifier is unique in a product. The identifier must be 1 to 30 characters in length, and can contain letters, digits, and underscores (\_).
        # 
        # This parameter must be used in combination with the **FunctionBlockName** parameter. If you do not specify this parameter, the system imports the default module.
        self.function_block_id = function_block_id
        # The name of the custom module. The name must be 4 to 30 characters in length, and can contain letters, digits, and underscores (\_).
        # 
        # This parameter must be used in combination with the **FunctionBlockId** parameter. If you do not specify this parameter, the system imports the default module.
        self.function_block_name = function_block_name
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The **ProductKey** of the product.
        # 
        # You can view the ProductKey on the Product Details page of the IoT Platform console. You can also obtain the ProductKey by calling the [QueryProductList](~~69271~~) operation.
        self.product_key = product_key
        # The details of the new features.
        # 
        # >  You can specify a maximum of 10 features.
        # 
        # Example:
        # 
        # ```
        # 
        # {
        #   "properties": [
        #     {
        #       "custom": true,
        #       "dataSpecsList": [
        #         {
        #           "childDataType": "TEXT",
        #           "childName": "CCID number of the device SIM card",
        #           "dataSpecs": {
        #             "custom": true,
        #             "dataType": "TEXT",
        #             "length": 20
        #           },
        #           "dataType": "STRUCT",
        #           "identifier": "CCID",
        #           "name": "CCID number of the device SIM card"
        #         },
        #         {
        #           "childDataType": "INT",
        #           "childName": "Battery power",
        #           "dataSpecs": {
        #             "custom": true,
        #             "dataType": "INT",
        #             "max": "60000",
        #             "min": "0",
        #             "step": "1"
        #           },
        #           "dataType": "STRUCT",
        #           "identifier": "battery",
        #           "name": "Battery power"
        #         },
        #         {
        #           "childDataType": "TEXT",
        #           "childName": "Other information",
        #           "dataSpecs": {
        #             "custom": true,
        #             "dataType": "TEXT",
        #             "length": 1024
        #           },
        #           "dataType": "STRUCT",
        #           "identifier": "other_info",
        #           "name": "Other information"
        #         }
        #       ],
        #       "dataType": "STRUCT",
        #       "identifier": "DEV_INFO",
        #       "name": "Device information",
        #       "productKey": "a1T***",
        #       "propertyId": 18786548,
        #       "required": false,
        #       "rwFlag": "READ_ONLY"
        #     },
        #     {
        #       "custom": true,
        #       "dataSpecs": {
        #         "childDataType": "INT",
        #         "custom": true,
        #         "dataType": "ARRAY",
        #         "size": 1,
        #         "dataSpecs": {
        #           "custom": true,
        #           "dataType": "INT",
        #           "max": "65535",
        #           "min": "0",
        #           "step": "1",
        #           "unit": "ppm",
        #           "unitName": "Parts per million"
        #         }
        #       },
        #       "dataType": "ARRAY",
        #       "identifier": "airRH_SR",
        #       "name": "Dehumidifier humidity",
        #       "productKey": "a1T***",
        #       "propertyId": 18786551,
        #       "required": false,
        #       "rwFlag": "READ_ONLY"
        #     }
        #   ],
        #   "services": [...],
        #   "events": [...]
        # }
        #                                 
        # ```
        # 
        # In the **properties** structure of the **ThingModelJson** parameter, you can use the **extendConfig** parameter to define the extended information of the TSL model. For more information, see [Data structure of ThingModelJson](~~150457~~).
        self.thing_model_json = thing_model_json

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.function_block_id is not None:
            result['FunctionBlockId'] = self.function_block_id
        if self.function_block_name is not None:
            result['FunctionBlockName'] = self.function_block_name
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.thing_model_json is not None:
            result['ThingModelJson'] = self.thing_model_json
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FunctionBlockId') is not None:
            self.function_block_id = m.get('FunctionBlockId')
        if m.get('FunctionBlockName') is not None:
            self.function_block_name = m.get('FunctionBlockName')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('ThingModelJson') is not None:
            self.thing_model_json = m.get('ThingModelJson')
        return self


class CreateThingModelResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateThingModelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateThingModelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateThingModelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateThingScriptRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        product_key: str = None,
        script_content: str = None,
        script_type: str = None,
    ):
        # The ID of the instance. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must specify this parameter. Otherwise, the call fails.
        # >*   If the **Overview** page does not appear in the console or no ID is generated for your instance, you do not need to specify this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The **ProductKey** of the product.
        # 
        # You can view the **ProductKey** on the Product Details page of the IoT Platform console. You can also obtain the ProductKey by calling the [QueryProductList](~~69271~~) operation.
        self.product_key = product_key
        # The content of the script. You must specify this parameter.
        # 
        # For more information about script examples, see [What is data parsing](~~68702~~).
        self.script_content = script_content
        # The language of the script. Valid values:
        # 
        # *   JavaScript
        # *   Python\_27: Python 2.7
        # *   PHP\_72: PHP 7.2
        self.script_type = script_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.script_content is not None:
            result['ScriptContent'] = self.script_content
        if self.script_type is not None:
            result['ScriptType'] = self.script_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('ScriptContent') is not None:
            self.script_content = m.get('ScriptContent')
        if m.get('ScriptType') is not None:
            self.script_type = m.get('ScriptType')
        return self


class CreateThingScriptResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the request fails.
        self.error_message = error_message
        # The ID of the request. The ID uniquely identifies this request.
        self.request_id = request_id
        # Indicates whether the request was successful.
        # 
        # *   **true**: The request was successful.
        # *   **false**: The request failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateThingScriptResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateThingScriptResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateThingScriptResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateTopicConfigRequest(TeaModel):
    def __init__(
        self,
        codec: str = None,
        description: str = None,
        enable_broadcast: bool = None,
        enable_proxy_subscribe: bool = None,
        iot_instance_id: str = None,
        operation: str = None,
        product_key: str = None,
        topic_full_name: str = None,
    ):
        self.codec = codec
        self.description = description
        self.enable_broadcast = enable_broadcast
        self.enable_proxy_subscribe = enable_proxy_subscribe
        self.iot_instance_id = iot_instance_id
        self.operation = operation
        self.product_key = product_key
        self.topic_full_name = topic_full_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.description is not None:
            result['Description'] = self.description
        if self.enable_broadcast is not None:
            result['EnableBroadcast'] = self.enable_broadcast
        if self.enable_proxy_subscribe is not None:
            result['EnableProxySubscribe'] = self.enable_proxy_subscribe
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.operation is not None:
            result['Operation'] = self.operation
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.topic_full_name is not None:
            result['TopicFullName'] = self.topic_full_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EnableBroadcast') is not None:
            self.enable_broadcast = m.get('EnableBroadcast')
        if m.get('EnableProxySubscribe') is not None:
            self.enable_proxy_subscribe = m.get('EnableProxySubscribe')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('Operation') is not None:
            self.operation = m.get('Operation')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('TopicFullName') is not None:
            self.topic_full_name = m.get('TopicFullName')
        return self


class CreateTopicConfigResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateTopicConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateTopicConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateTopicConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateTopicRouteTableRequest(TeaModel):
    def __init__(
        self,
        dst_topic: List[str] = None,
        iot_instance_id: str = None,
        src_topic: str = None,
    ):
        self.dst_topic = dst_topic
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The source topic. Example: `SrcTopic=/x7aWKW9 ****** /testDataToDataHub/user/update`.
        self.src_topic = src_topic

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dst_topic is not None:
            result['DstTopic'] = self.dst_topic
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.src_topic is not None:
            result['SrcTopic'] = self.src_topic
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DstTopic') is not None:
            self.dst_topic = m.get('DstTopic')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('SrcTopic') is not None:
            self.src_topic = m.get('SrcTopic')
        return self


class CreateTopicRouteTableResponseBodyFailureTopics(TeaModel):
    def __init__(
        self,
        topic: List[Dict[str, Any]] = None,
    ):
        self.topic = topic

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.topic is not None:
            result['Topic'] = self.topic
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Topic') is not None:
            self.topic = m.get('Topic')
        return self


class CreateTopicRouteTableResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        failure_topics: CreateTopicRouteTableResponseBodyFailureTopics = None,
        is_all_succeed: bool = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The list of topics returned if the call fails.
        self.failure_topics = failure_topics
        # Indicates whether all the message routing relationships between topics are established.
        # 
        # *   **true**: All the message routing relationships between topics are established.
        # *   **false**: Not all the message routing relationships between topics are established.
        self.is_all_succeed = is_all_succeed
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.failure_topics:
            self.failure_topics.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.failure_topics is not None:
            result['FailureTopics'] = self.failure_topics.to_map()
        if self.is_all_succeed is not None:
            result['IsAllSucceed'] = self.is_all_succeed
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('FailureTopics') is not None:
            temp_model = CreateTopicRouteTableResponseBodyFailureTopics()
            self.failure_topics = temp_model.from_map(m['FailureTopics'])
        if m.get('IsAllSucceed') is not None:
            self.is_all_succeed = m.get('IsAllSucceed')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateTopicRouteTableResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateTopicRouteTableResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateTopicRouteTableResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteClientIdsRequest(TeaModel):
    def __init__(
        self,
        iot_id: str = None,
        iot_instance_id: str = None,
    ):
        # The ID of the device.
        self.iot_id = iot_id
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class DeleteClientIdsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The response code. The value Success indicates that the call was successful. Other values indicate that errors occurred. For more information about error codes, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteClientIdsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteClientIdsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteClientIdsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteConsumerGroupRequest(TeaModel):
    def __init__(
        self,
        group_id: str = None,
        iot_instance_id: str = None,
    ):
        # The ID of the consumer group. After you call the [CreateConsumerGroup](~~170388~~) operation to create a consumer group, the consumer group ID is returned. You can call the [QueryConsumerGroupList](~~170419~~) operation to query the consumer group ID by group name. You can also go to the IoT Platform console,and choose **Rules** > **Server-side Subscription** > **Consumer Groups** to view the consumer group ID.
        self.group_id = group_id
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class DeleteConsumerGroupResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteConsumerGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteConsumerGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteConsumerGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteConsumerGroupSubscribeRelationRequest(TeaModel):
    def __init__(
        self,
        consumer_group_id: str = None,
        iot_instance_id: str = None,
        product_key: str = None,
    ):
        # The ID of the consumer group. You can call the [QuerySubscribeRelation](~~170352~~) operation to query the consumer group ID in an AMQP subscription. You can also go to the IoT Platform console,and choose **Rules** > **Server-side Subscription** to view the consumer group ID.
        self.consumer_group_id = consumer_group_id
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The **ProductKey** of the product that is specified for the subscription.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.consumer_group_id is not None:
            result['ConsumerGroupId'] = self.consumer_group_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConsumerGroupId') is not None:
            self.consumer_group_id = m.get('ConsumerGroupId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class DeleteConsumerGroupSubscribeRelationResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteConsumerGroupSubscribeRelationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteConsumerGroupSubscribeRelationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteConsumerGroupSubscribeRelationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteDataSourceItemRequest(TeaModel):
    def __init__(
        self,
        data_source_id: int = None,
        data_source_item_id: int = None,
        iot_instance_id: str = None,
    ):
        self.data_source_id = data_source_id
        self.data_source_item_id = data_source_item_id
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_source_id is not None:
            result['DataSourceId'] = self.data_source_id
        if self.data_source_item_id is not None:
            result['DataSourceItemId'] = self.data_source_item_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataSourceId') is not None:
            self.data_source_id = m.get('DataSourceId')
        if m.get('DataSourceItemId') is not None:
            self.data_source_item_id = m.get('DataSourceItemId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class DeleteDataSourceItemResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteDataSourceItemResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteDataSourceItemResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteDataSourceItemResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteDestinationRequest(TeaModel):
    def __init__(
        self,
        destination_id: int = None,
        iot_instance_id: str = None,
    ):
        self.destination_id = destination_id
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.destination_id is not None:
            result['DestinationId'] = self.destination_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DestinationId') is not None:
            self.destination_id = m.get('DestinationId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class DeleteDestinationResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteDestinationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteDestinationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteDestinationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteDeviceRequest(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        iot_id: str = None,
        iot_instance_id: str = None,
        product_key: str = None,
    ):
        # The DeviceName of the device.
        # 
        # 
        # > If you configure this parameter, you must specify a value for the **ProductKey** parameter.
        self.device_name = device_name
        # The ID of the device.
        # 
        # 
        # 
        # **Important** The IotId parameter specifies a globally unique identifier (GUID) for the device. The value of the **IotId** parameter corresponds to a combination of the values of the **ProductKey** and **DeviceName** parameters. If you specify a value for this parameter, you do not need to configure the **ProductKey** or **DeviceName** parameter. If you specify values for the **IotId**, **ProductKey**, and **DeviceName** parameters, the value of the **IotId** parameter takes precedence.
        self.iot_id = iot_id
        # The ID of the instance. You can view the ID of the instance on the **Overview** page in the IoT Platform console.
        # 
        # 
        # 
        # >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.
        # >*   If no **Overview** page or **ID** is generated for your instance, you do not need to configure this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The **ProductKey** of the product to which the device belongs.
        # 
        # 
        # 
        # > If you configure this parameter, you must specify a value for the **DeviceName** parameter.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class DeleteDeviceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteDeviceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteDeviceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteDeviceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteDeviceDistributeJobRequest(TeaModel):
    def __init__(
        self,
        job_id: str = None,
    ):
        # The ID of the distribution task. The ID globally identifies the task.
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class DeleteDeviceDistributeJobResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteDeviceDistributeJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteDeviceDistributeJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteDeviceDistributeJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteDeviceDynamicGroupRequest(TeaModel):
    def __init__(
        self,
        group_id: str = None,
        iot_instance_id: str = None,
    ):
        self.group_id = group_id
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class DeleteDeviceDynamicGroupResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteDeviceDynamicGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteDeviceDynamicGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteDeviceDynamicGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteDeviceFileRequest(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        file_id: str = None,
        iot_id: str = None,
        iot_instance_id: str = None,
        product_key: str = None,
    ):
        # The name of the device.
        # 
        # >  If you specify this parameter, you must also specify the **ProductKey** parameter.
        self.device_name = device_name
        # The ID of the file. You can call the [QueryDeviceFileList](~~112001~~) operation and view the file ID in the response.
        self.file_id = file_id
        # The ID of the device. The ID is a unique identifier that is issued by IoT Platform to the device.
        # 
        # >  If you specify this parameter, you do not need to specify **ProductKey** or **DeviceName**. The **IotId** parameter specifies a globally unique identifier (GUID) of the device, which corresponds to a combination of **ProductKey** and **DeviceName**. If you specify both **IotId** and the combination of **ProductKey** and **DeviceName**, **IotId** takes precedence.
        self.iot_id = iot_id
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The ProductKey of the product to which the device belongs.
        # 
        # >  If you specify this parameter, you must also specify the **DeviceName** parameter.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.file_id is not None:
            result['FileId'] = self.file_id
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('FileId') is not None:
            self.file_id = m.get('FileId')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class DeleteDeviceFileResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteDeviceFileResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteDeviceFileResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteDeviceFileResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteDeviceGroupRequest(TeaModel):
    def __init__(
        self,
        group_id: str = None,
        iot_instance_id: str = None,
    ):
        # The ID of the group. The ID is the globally unique identifier (GUID) for the group.
        self.group_id = group_id
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class DeleteDeviceGroupResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteDeviceGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteDeviceGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteDeviceGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteDevicePropRequest(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        iot_id: str = None,
        iot_instance_id: str = None,
        product_key: str = None,
        prop_key: str = None,
    ):
        # The name of the device.
        # 
        # >  If you specify this parameter, you must also specify the **ProductKey** parameter.
        self.device_name = device_name
        # The ID of the device.
        # 
        # >  If you specify this parameter, you do not need to specify **ProductKey** or **DeviceName**. The **IotId** parameter specifies a globally unique identifier (GUID) of the device, which corresponds to a combination of **ProductKey** and **DeviceName**. If you specify both **IotId** and the combination of **ProductKey** and **DeviceName**, **IotId** takes precedence.
        self.iot_id = iot_id
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The ProductKey of the product to which the device belongs.
        # 
        # >  If you specify this parameter, you must also specify the **DeviceName** parameter.
        self.product_key = product_key
        # The key of the tag.
        # 
        # >  IoT Platform searches for the specified tag key and then deletes the tag. If no result is found, no operation is performed.
        self.prop_key = prop_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.prop_key is not None:
            result['PropKey'] = self.prop_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('PropKey') is not None:
            self.prop_key = m.get('PropKey')
        return self


class DeleteDevicePropResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteDevicePropResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteDevicePropResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteDevicePropResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteDeviceSpeechRequestDeviceSpeechList(TeaModel):
    def __init__(
        self,
        audio_format: str = None,
        biz_code: str = None,
    ):
        self.audio_format = audio_format
        self.biz_code = biz_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_format is not None:
            result['AudioFormat'] = self.audio_format
        if self.biz_code is not None:
            result['BizCode'] = self.biz_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioFormat') is not None:
            self.audio_format = m.get('AudioFormat')
        if m.get('BizCode') is not None:
            self.biz_code = m.get('BizCode')
        return self


class DeleteDeviceSpeechRequest(TeaModel):
    def __init__(
        self,
        device_speech_list: List[DeleteDeviceSpeechRequestDeviceSpeechList] = None,
        iot_id: str = None,
        iot_instance_id: str = None,
    ):
        self.device_speech_list = device_speech_list
        self.iot_id = iot_id
        self.iot_instance_id = iot_instance_id

    def validate(self):
        if self.device_speech_list:
            for k in self.device_speech_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DeviceSpeechList'] = []
        if self.device_speech_list is not None:
            for k in self.device_speech_list:
                result['DeviceSpeechList'].append(k.to_map() if k else None)
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.device_speech_list = []
        if m.get('DeviceSpeechList') is not None:
            for k in m.get('DeviceSpeechList'):
                temp_model = DeleteDeviceSpeechRequestDeviceSpeechList()
                self.device_speech_list.append(temp_model.from_map(k))
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class DeleteDeviceSpeechResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteDeviceSpeechResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteDeviceSpeechResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteDeviceSpeechResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteDeviceTunnelRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        tunnel_id: str = None,
    ):
        self.iot_instance_id = iot_instance_id
        self.tunnel_id = tunnel_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.tunnel_id is not None:
            result['TunnelId'] = self.tunnel_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('TunnelId') is not None:
            self.tunnel_id = m.get('TunnelId')
        return self


class DeleteDeviceTunnelResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteDeviceTunnelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteDeviceTunnelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteDeviceTunnelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteEdgeDriverRequest(TeaModel):
    def __init__(
        self,
        driver_id: str = None,
        iot_instance_id: str = None,
    ):
        # The ID of the driver. To obtain the driver ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Drivers** page, move the pointer over the name of the driver that you want to delete and obtain the driver ID.
        # 
        # You can also call the [QueryEdgeDriver](~~155776~~) operation to query the driver ID.
        self.driver_id = driver_id
        # The ID of the Internet of Things (IoT) service instance. This parameter is not required for the public instance but required for Enterprise Edition instances.
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.driver_id is not None:
            result['DriverId'] = self.driver_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DriverId') is not None:
            self.driver_id = m.get('DriverId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class DeleteEdgeDriverResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The return code of the operation. A value of Success indicates that the call was successful. Other values indicate that specific errors occurred. For more information, see [Error codes](~~135200~~).
        self.code = code
        # The error message that is returned if the call failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful. A value of true indicates that the call was successful. A value of false indicates that the call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteEdgeDriverResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteEdgeDriverResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteEdgeDriverResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteEdgeDriverVersionRequest(TeaModel):
    def __init__(
        self,
        driver_id: str = None,
        driver_version: str = None,
        iot_instance_id: str = None,
    ):
        # The ID of the driver. To obtain the driver ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Drivers** page, move the pointer over the name of the driver for which you want to delete a driver version and obtain the driver ID.
        # 
        # You can also call the [QueryEdgeDriver](~~155776~~) operation to query the driver ID.
        self.driver_id = driver_id
        # The version number of the driver.
        self.driver_version = driver_version
        # The ID of the Internet of Things (IoT) service instance. This parameter is not required for the public instance but required for Enterprise Edition instances.
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.driver_id is not None:
            result['DriverId'] = self.driver_id
        if self.driver_version is not None:
            result['DriverVersion'] = self.driver_version
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DriverId') is not None:
            self.driver_id = m.get('DriverId')
        if m.get('DriverVersion') is not None:
            self.driver_version = m.get('DriverVersion')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class DeleteEdgeDriverVersionResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The return code of the operation. A value of Success indicates that the call was successful. Other values indicate that specific errors occurred. For more information, see [Error codes](~~135200~~).
        self.code = code
        # The error message that is returned if the call failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful. A value of true indicates that the call was successful. A value of false indicates that the call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteEdgeDriverVersionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteEdgeDriverVersionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteEdgeDriverVersionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteEdgeInstanceRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        iot_instance_id: str = None,
    ):
        # The ID of the edge instance. To obtain the instance ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Edge Instances** page, move the pointer over the name of the edge instance that you want to delete and obtain the instance ID.
        # 
        # You can also call the [QueryEdgeInstance](~~135214~~) operation to query the instance ID.
        self.instance_id = instance_id
        # The ID of the Internet of Things (IoT) service instance. This parameter is not required for the public instance but required for Enterprise Edition instances.
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class DeleteEdgeInstanceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The return code of the operation. A value of Success indicates that the call was successful. Other values indicate that specific errors occurred. For more information, see [Error codes](~~135200~~).
        self.code = code
        # The error message that is returned if the call failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful. A value of true indicates that the call was successful. A value of false indicates that the call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteEdgeInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteEdgeInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteEdgeInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteEdgeInstanceMessageRoutingRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        iot_instance_id: str = None,
        route_id: int = None,
    ):
        self.instance_id = instance_id
        self.iot_instance_id = iot_instance_id
        self.route_id = route_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.route_id is not None:
            result['RouteId'] = self.route_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('RouteId') is not None:
            self.route_id = m.get('RouteId')
        return self


class DeleteEdgeInstanceMessageRoutingResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteEdgeInstanceMessageRoutingResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteEdgeInstanceMessageRoutingResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteEdgeInstanceMessageRoutingResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteJobRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        job_id: str = None,
    ):
        self.iot_instance_id = iot_instance_id
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class DeleteJobResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteOTAFirmwareRequest(TeaModel):
    def __init__(
        self,
        firmware_id: str = None,
        iot_instance_id: str = None,
    ):
        # The unique ID of the OTA update package.
        # 
        # An update package ID is returned when you call the [CreateOTAFirmware](~~147311~~) operation to create the update package.
        # 
        # You can call the [ListOTAFirmware](~~147450~~) operation and view the update package ID in the response.
        self.firmware_id = firmware_id
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.firmware_id is not None:
            result['FirmwareId'] = self.firmware_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FirmwareId') is not None:
            self.firmware_id = m.get('FirmwareId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class DeleteOTAFirmwareResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteOTAFirmwareResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteOTAFirmwareResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteOTAFirmwareResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteOTAModuleRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        module_name: str = None,
        product_key: str = None,
    ):
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The name of the OTA module.
        self.module_name = module_name
        # The **ProductKey** of the product to which the OTA module belongs.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.module_name is not None:
            result['ModuleName'] = self.module_name
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ModuleName') is not None:
            self.module_name = m.get('ModuleName')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class DeleteOTAModuleResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteOTAModuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteOTAModuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteOTAModuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteParserRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        parser_id: int = None,
    ):
        self.iot_instance_id = iot_instance_id
        self.parser_id = parser_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.parser_id is not None:
            result['ParserId'] = self.parser_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ParserId') is not None:
            self.parser_id = m.get('ParserId')
        return self


class DeleteParserResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteParserResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteParserResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteParserResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteParserDataSourceRequest(TeaModel):
    def __init__(
        self,
        data_source_id: int = None,
        iot_instance_id: str = None,
    ):
        self.data_source_id = data_source_id
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_source_id is not None:
            result['DataSourceId'] = self.data_source_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataSourceId') is not None:
            self.data_source_id = m.get('DataSourceId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class DeleteParserDataSourceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteParserDataSourceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteParserDataSourceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteParserDataSourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeletePowerStationRequest(TeaModel):
    def __init__(
        self,
        algorithm_instance_uid: str = None,
        iot_instance_id: str = None,
        power_station_uid: str = None,
    ):
        self.algorithm_instance_uid = algorithm_instance_uid
        self.iot_instance_id = iot_instance_id
        self.power_station_uid = power_station_uid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.algorithm_instance_uid is not None:
            result['AlgorithmInstanceUid'] = self.algorithm_instance_uid
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.power_station_uid is not None:
            result['PowerStationUid'] = self.power_station_uid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlgorithmInstanceUid') is not None:
            self.algorithm_instance_uid = m.get('AlgorithmInstanceUid')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('PowerStationUid') is not None:
            self.power_station_uid = m.get('PowerStationUid')
        return self


class DeletePowerStationResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeletePowerStationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeletePowerStationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeletePowerStationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteProductRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        product_key: str = None,
    ):
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The ProductKey of the product that you want to delete. A ProductKey is a GUID that is issued by IoT Platform to a product. You can use the IoT Platform console or call the [QueryProductList](~~69271~~) operation to view the information about all products within the current account.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class DeleteProductResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteProductResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteProductResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteProductResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteProductTagsRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        product_key: str = None,
        product_tag_key: List[str] = None,
    ):
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # 
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The ProductKey of the product. A ProductKey is a GUID that is issued by IoT Platform to a product. You can use the IoT Platform console or call the [QueryProductList](~~69271~~) operation to view the information about all products within the current account.
        self.product_key = product_key
        self.product_tag_key = product_tag_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.product_tag_key is not None:
            result['ProductTagKey'] = self.product_tag_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('ProductTagKey') is not None:
            self.product_tag_key = m.get('ProductTagKey')
        return self


class DeleteProductTagsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteProductTagsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteProductTagsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteProductTagsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteProductTopicRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        topic_id: str = None,
    ):
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The ID of the topic category that you want to delete.
        self.topic_id = topic_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.topic_id is not None:
            result['TopicId'] = self.topic_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('TopicId') is not None:
            self.topic_id = m.get('TopicId')
        return self


class DeleteProductTopicResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteProductTopicResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteProductTopicResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteProductTopicResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteRuleRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        rule_id: int = None,
    ):
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The ID of the rule that you want to delete. You can log on to the IoT Platform console and choose **Rules** > **Data Forwarding** to view the rule ID. You can also call the [ListRule](~~69486~~) operation and view the rule ID in the response.
        self.rule_id = rule_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        return self


class DeleteRuleResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteRuleActionRequest(TeaModel):
    def __init__(
        self,
        action_id: int = None,
        iot_instance_id: str = None,
    ):
        # The identifier of the rule action that you want to delete.
        # 
        # After you call the [CreateRuleAction](~~69586~~) operation to create a rule action, the rule action ID is returned. You can call the [ListRuleActions](~~69517~~) operation to view the rule action ID.
        self.action_id = action_id
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_id is not None:
            result['ActionId'] = self.action_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActionId') is not None:
            self.action_id = m.get('ActionId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class DeleteRuleActionResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteRuleActionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteRuleActionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteRuleActionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteSceneRuleRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        rule_id: str = None,
    ):
        self.iot_instance_id = iot_instance_id
        self.rule_id = rule_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        return self


class DeleteSceneRuleResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteSceneRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteSceneRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteSceneRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteSchedulePeriodRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        period_code: str = None,
    ):
        self.iot_instance_id = iot_instance_id
        self.period_code = period_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.period_code is not None:
            result['PeriodCode'] = self.period_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('PeriodCode') is not None:
            self.period_code = m.get('PeriodCode')
        return self


class DeleteSchedulePeriodResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteSchedulePeriodResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteSchedulePeriodResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteSchedulePeriodResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteShareTaskDeviceRequest(TeaModel):
    def __init__(
        self,
        iot_id_list: List[str] = None,
        iot_instance_id: str = None,
        share_task_id: str = None,
    ):
        self.iot_id_list = iot_id_list
        self.iot_instance_id = iot_instance_id
        self.share_task_id = share_task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_id_list is not None:
            result['IotIdList'] = self.iot_id_list
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.share_task_id is not None:
            result['ShareTaskId'] = self.share_task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotIdList') is not None:
            self.iot_id_list = m.get('IotIdList')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ShareTaskId') is not None:
            self.share_task_id = m.get('ShareTaskId')
        return self


class DeleteShareTaskDeviceResponseBodyData(TeaModel):
    def __init__(
        self,
        progress: int = None,
        progress_id: str = None,
    ):
        self.progress = progress
        self.progress_id = progress_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.progress is not None:
            result['Progress'] = self.progress
        if self.progress_id is not None:
            result['ProgressId'] = self.progress_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Progress') is not None:
            self.progress = m.get('Progress')
        if m.get('ProgressId') is not None:
            self.progress_id = m.get('ProgressId')
        return self


class DeleteShareTaskDeviceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: DeleteShareTaskDeviceResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DeleteShareTaskDeviceResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteShareTaskDeviceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteShareTaskDeviceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteShareTaskDeviceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteSoundCodeRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        sound_code: str = None,
    ):
        self.iot_instance_id = iot_instance_id
        self.sound_code = sound_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.sound_code is not None:
            result['SoundCode'] = self.sound_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('SoundCode') is not None:
            self.sound_code = m.get('SoundCode')
        return self


class DeleteSoundCodeResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteSoundCodeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteSoundCodeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteSoundCodeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteSoundCodeLabelRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        sound_code: str = None,
    ):
        self.iot_instance_id = iot_instance_id
        self.sound_code = sound_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.sound_code is not None:
            result['SoundCode'] = self.sound_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('SoundCode') is not None:
            self.sound_code = m.get('SoundCode')
        return self


class DeleteSoundCodeLabelResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteSoundCodeLabelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteSoundCodeLabelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteSoundCodeLabelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteSoundCodeScheduleRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        schedule_code: str = None,
    ):
        self.iot_instance_id = iot_instance_id
        self.schedule_code = schedule_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.schedule_code is not None:
            result['ScheduleCode'] = self.schedule_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ScheduleCode') is not None:
            self.schedule_code = m.get('ScheduleCode')
        return self


class DeleteSoundCodeScheduleResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteSoundCodeScheduleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteSoundCodeScheduleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteSoundCodeScheduleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteSpeechRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        speech_code_list: List[str] = None,
    ):
        self.iot_instance_id = iot_instance_id
        self.speech_code_list = speech_code_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.speech_code_list is not None:
            result['SpeechCodeList'] = self.speech_code_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('SpeechCodeList') is not None:
            self.speech_code_list = m.get('SpeechCodeList')
        return self


class DeleteSpeechResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteSpeechResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteSpeechResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteSpeechResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteStudioAppDomainOpenRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        domain_id: int = None,
        iot_instance_id: str = None,
        project_id: str = None,
    ):
        self.app_id = app_id
        self.domain_id = domain_id
        self.iot_instance_id = iot_instance_id
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.domain_id is not None:
            result['DomainId'] = self.domain_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('DomainId') is not None:
            self.domain_id = m.get('DomainId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class DeleteStudioAppDomainOpenResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: bool = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteStudioAppDomainOpenResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteStudioAppDomainOpenResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteStudioAppDomainOpenResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteSubscribeRelationRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        product_key: str = None,
        type: str = None,
    ):
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The ProductKey of the product that is specified for the subscription.
        self.product_key = product_key
        # The type of the subscription. Valid values:
        # 
        # *   **MNS**\
        # *   **AMQP**\
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DeleteSubscribeRelationResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteSubscribeRelationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteSubscribeRelationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteSubscribeRelationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteThingModelRequest(TeaModel):
    def __init__(
        self,
        event_identifier: List[str] = None,
        function_block_id: str = None,
        iot_instance_id: str = None,
        product_key: str = None,
        property_identifier: List[str] = None,
        resource_group_id: str = None,
        service_identifier: List[str] = None,
    ):
        self.event_identifier = event_identifier
        # The identifier of the custom TSL module. Each identifier is unique in a product.
        # 
        # *   If you configure the BatteryModule parameter when a value is specified for the **PropertyIdentifier.N**, **ServiceIdentifier.N**, or **EventIdentifier.N** parameter, the operation removes one or more specified features from the specified custom TSL module. If you do not configure the BatteryModule parameter, the operation removes one or more specified features from the default TSL module.
        # *   If you configure the BatteryModule parameter when the **PropertyIdentifier.N**, **ServiceIdentifier.N**, and **EventIdentifier.N** parameters are empty, the operation removes all features from the specified custom TSL module.
        self.function_block_id = function_block_id
        # The ID of the instance. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.
        # >*   If no **Overview** page or ID is generated for your instance, you do not need to configure this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The ProductKey of the product.
        self.product_key = product_key
        self.property_identifier = property_identifier
        # The ID of the resource group.
        # 
        # >  You cannot configure this parameter.
        self.resource_group_id = resource_group_id
        self.service_identifier = service_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.event_identifier is not None:
            result['EventIdentifier'] = self.event_identifier
        if self.function_block_id is not None:
            result['FunctionBlockId'] = self.function_block_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.property_identifier is not None:
            result['PropertyIdentifier'] = self.property_identifier
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.service_identifier is not None:
            result['ServiceIdentifier'] = self.service_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EventIdentifier') is not None:
            self.event_identifier = m.get('EventIdentifier')
        if m.get('FunctionBlockId') is not None:
            self.function_block_id = m.get('FunctionBlockId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('PropertyIdentifier') is not None:
            self.property_identifier = m.get('PropertyIdentifier')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ServiceIdentifier') is not None:
            self.service_identifier = m.get('ServiceIdentifier')
        return self


class DeleteThingModelResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the request fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteThingModelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteThingModelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteThingModelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteTopicConfigRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        product_key: str = None,
        topic_full_name: str = None,
    ):
        self.iot_instance_id = iot_instance_id
        self.product_key = product_key
        self.topic_full_name = topic_full_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.topic_full_name is not None:
            result['TopicFullName'] = self.topic_full_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('TopicFullName') is not None:
            self.topic_full_name = m.get('TopicFullName')
        return self


class DeleteTopicConfigResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteTopicConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteTopicConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteTopicConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteTopicRouteTableRequest(TeaModel):
    def __init__(
        self,
        dst_topic: List[str] = None,
        iot_instance_id: str = None,
        src_topic: str = None,
    ):
        self.dst_topic = dst_topic
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        self.src_topic = src_topic

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dst_topic is not None:
            result['DstTopic'] = self.dst_topic
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.src_topic is not None:
            result['SrcTopic'] = self.src_topic
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DstTopic') is not None:
            self.dst_topic = m.get('DstTopic')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('SrcTopic') is not None:
            self.src_topic = m.get('SrcTopic')
        return self


class DeleteTopicRouteTableResponseBodyFailureTopics(TeaModel):
    def __init__(
        self,
        topic: List[Dict[str, Any]] = None,
    ):
        self.topic = topic

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.topic is not None:
            result['Topic'] = self.topic
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Topic') is not None:
            self.topic = m.get('Topic')
        return self


class DeleteTopicRouteTableResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        failure_topics: DeleteTopicRouteTableResponseBodyFailureTopics = None,
        is_all_succeed: bool = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The list of topics returned if the call fails.
        self.failure_topics = failure_topics
        # Indicates whether all the routing relationships of the topic are deleted.
        # 
        # *   **true**: All the routing relationships of the topic are deleted.
        # *   **false**: Not all the message routing relationships of the topic are deleted.
        self.is_all_succeed = is_all_succeed
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.failure_topics:
            self.failure_topics.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.failure_topics is not None:
            result['FailureTopics'] = self.failure_topics.to_map()
        if self.is_all_succeed is not None:
            result['IsAllSucceed'] = self.is_all_succeed
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('FailureTopics') is not None:
            temp_model = DeleteTopicRouteTableResponseBodyFailureTopics()
            self.failure_topics = temp_model.from_map(m['FailureTopics'])
        if m.get('IsAllSucceed') is not None:
            self.is_all_succeed = m.get('IsAllSucceed')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteTopicRouteTableResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteTopicRouteTableResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteTopicRouteTableResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteUserDefineTableDataByPrimaryKeyRequest(TeaModel):
    def __init__(
        self,
        conditions: Dict[str, Any] = None,
        iot_instance_id: str = None,
        table_identifier: str = None,
    ):
        self.conditions = conditions
        self.iot_instance_id = iot_instance_id
        self.table_identifier = table_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.conditions is not None:
            result['Conditions'] = self.conditions
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.table_identifier is not None:
            result['TableIdentifier'] = self.table_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Conditions') is not None:
            self.conditions = m.get('Conditions')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('TableIdentifier') is not None:
            self.table_identifier = m.get('TableIdentifier')
        return self


class DeleteUserDefineTableDataByPrimaryKeyShrinkRequest(TeaModel):
    def __init__(
        self,
        conditions_shrink: str = None,
        iot_instance_id: str = None,
        table_identifier: str = None,
    ):
        self.conditions_shrink = conditions_shrink
        self.iot_instance_id = iot_instance_id
        self.table_identifier = table_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.conditions_shrink is not None:
            result['Conditions'] = self.conditions_shrink
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.table_identifier is not None:
            result['TableIdentifier'] = self.table_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Conditions') is not None:
            self.conditions_shrink = m.get('Conditions')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('TableIdentifier') is not None:
            self.table_identifier = m.get('TableIdentifier')
        return self


class DeleteUserDefineTableDataByPrimaryKeyResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteUserDefineTableDataByPrimaryKeyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteUserDefineTableDataByPrimaryKeyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteUserDefineTableDataByPrimaryKeyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DetachDestinationRequest(TeaModel):
    def __init__(
        self,
        destination_id: int = None,
        iot_instance_id: str = None,
        parser_id: int = None,
    ):
        # The ID of the data destination. You can call the [ListDestination](~~433025~~) operation to query data destinations and obtain the ID of the **data destination**.
        self.destination_id = destination_id
        # The ID of the instance. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.
        # >*   If no **Overview** page or ID is generated for your instance, you do not need to configure this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The ID of the parser. You can call the [ListParser](~~444814~~) operation to query parsers and obtain the ID of the **parser**.
        self.parser_id = parser_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.destination_id is not None:
            result['DestinationId'] = self.destination_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.parser_id is not None:
            result['ParserId'] = self.parser_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DestinationId') is not None:
            self.destination_id = m.get('DestinationId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ParserId') is not None:
            self.parser_id = m.get('ParserId')
        return self


class DetachDestinationResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DetachDestinationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DetachDestinationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DetachDestinationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DetachParserDataSourceRequest(TeaModel):
    def __init__(
        self,
        data_source_id: int = None,
        iot_instance_id: str = None,
        parser_id: int = None,
    ):
        self.data_source_id = data_source_id
        self.iot_instance_id = iot_instance_id
        self.parser_id = parser_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_source_id is not None:
            result['DataSourceId'] = self.data_source_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.parser_id is not None:
            result['ParserId'] = self.parser_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataSourceId') is not None:
            self.data_source_id = m.get('DataSourceId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ParserId') is not None:
            self.parser_id = m.get('ParserId')
        return self


class DetachParserDataSourceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DetachParserDataSourceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DetachParserDataSourceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DetachParserDataSourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DisableDeviceTunnelRequest(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        iot_instance_id: str = None,
        product_key: str = None,
    ):
        self.device_name = device_name
        self.iot_instance_id = iot_instance_id
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class DisableDeviceTunnelResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DisableDeviceTunnelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DisableDeviceTunnelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DisableDeviceTunnelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DisableDeviceTunnelShareRequest(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        iot_instance_id: str = None,
        product_key: str = None,
    ):
        self.device_name = device_name
        self.iot_instance_id = iot_instance_id
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class DisableDeviceTunnelShareResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DisableDeviceTunnelShareResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DisableDeviceTunnelShareResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DisableDeviceTunnelShareResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DisableSceneRuleRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        rule_id: str = None,
    ):
        self.iot_instance_id = iot_instance_id
        self.rule_id = rule_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        return self


class DisableSceneRuleResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DisableSceneRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DisableSceneRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DisableSceneRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DisableThingRequest(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        iot_id: str = None,
        iot_instance_id: str = None,
        product_key: str = None,
    ):
        # The DeviceName of the device.
        # 
        # >  If you specify this parameter, you must also specify the **ProductKey** parameter.
        self.device_name = device_name
        # The ID of the device. The ID is a unique identifier that is issued by IoT Platform to the device.
        # 
        # >  If you specify this parameter, you do not need to specify **ProductKey** or **DeviceName**. The **IotId** parameter specifies a globally unique identifier (GUID) of the device, which corresponds to a combination of **ProductKey** and **DeviceName**. If you specify both **IotId** and the combination of **ProductKey** and **DeviceName**, **IotId** takes precedence.
        self.iot_id = iot_id
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The ProductKey of the product to which the device belongs.
        # 
        # >  If you specify this parameter, you must also specify the **DeviceName** parameter.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class DisableThingResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DisableThingResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DisableThingResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DisableThingResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class EnableDeviceTunnelRequest(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        iot_instance_id: str = None,
        product_key: str = None,
    ):
        self.device_name = device_name
        self.iot_instance_id = iot_instance_id
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class EnableDeviceTunnelResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class EnableDeviceTunnelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: EnableDeviceTunnelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = EnableDeviceTunnelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class EnableDeviceTunnelShareRequest(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        iot_instance_id: str = None,
        product_key: str = None,
    ):
        self.device_name = device_name
        self.iot_instance_id = iot_instance_id
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class EnableDeviceTunnelShareResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class EnableDeviceTunnelShareResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: EnableDeviceTunnelShareResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = EnableDeviceTunnelShareResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class EnableSceneRuleRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        rule_id: str = None,
    ):
        self.iot_instance_id = iot_instance_id
        self.rule_id = rule_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        return self


class EnableSceneRuleResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class EnableSceneRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: EnableSceneRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = EnableSceneRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class EnableThingRequest(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        iot_id: str = None,
        iot_instance_id: str = None,
        product_key: str = None,
    ):
        # The DeviceName of the device.
        # 
        # >  If you specify this parameter, you must also specify the **ProductKey** parameter.
        self.device_name = device_name
        # The ID of the device. The ID is a unique identifier that is issued by IoT Platform to the device.
        # 
        # >  If you provide this parameter, you do not need to provide the **ProductKey** or **DeviceName** parameters. As the GUID of the device, **IotId** corresponds to the combination of **ProductKey** and **DeviceName**. If you specify both **IotId** and the combination of **ProductKey** and **DeviceName**, **IotId** takes precedence.
        self.iot_id = iot_id
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The ProductKey of the product to which the device belongs.
        # 
        # >  If you specify this parameter, you must also specify the **DeviceName** parameter.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class EnableThingResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class EnableThingResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: EnableThingResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = EnableThingResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GenerateDeviceNameListURLRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
    ):
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to configure this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class GenerateDeviceNameListURLResponseBodyData(TeaModel):
    def __init__(
        self,
        access_key_id: str = None,
        file_url: str = None,
        host: str = None,
        key: str = None,
        object_storage: str = None,
        policy: str = None,
        signature: str = None,
        utc_create: str = None,
    ):
        # The AccessKey ID of the bucket owner.
        # 
        # The OSS bucket stores the file.
        self.access_key_id = access_key_id
        # The URL of the file that is stored in OSS.
        # 
        # After the device list file is uploaded, this parameter is used to call the [CreateOTAStaticUpgradeJob](~~147496~~) operation to create a static update batch.
        self.file_url = file_url
        # The endpoint of OSS.
        self.host = host
        # The full path of the file in OSS. You can call the OSS PostObject operation to upload the file to OSS.
        self.key = key
        # The type of the object storage. Default value: OSS.
        self.object_storage = object_storage
        # The parameter that is used by OSS to verify form fields for the request.
        self.policy = policy
        # The signature that is calculated based on **AccessKeySecret** and **Policy**. When you call an OSS operation, OSS uses the signature information to verify the POST request.
        self.signature = signature
        # The time when the URL of the file that you want to upload was generated. The time is displayed in UTC.
        self.utc_create = utc_create

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_key_id is not None:
            result['AccessKeyId'] = self.access_key_id
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.host is not None:
            result['Host'] = self.host
        if self.key is not None:
            result['Key'] = self.key
        if self.object_storage is not None:
            result['ObjectStorage'] = self.object_storage
        if self.policy is not None:
            result['Policy'] = self.policy
        if self.signature is not None:
            result['Signature'] = self.signature
        if self.utc_create is not None:
            result['UtcCreate'] = self.utc_create
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccessKeyId') is not None:
            self.access_key_id = m.get('AccessKeyId')
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('ObjectStorage') is not None:
            self.object_storage = m.get('ObjectStorage')
        if m.get('Policy') is not None:
            self.policy = m.get('Policy')
        if m.get('Signature') is not None:
            self.signature = m.get('Signature')
        if m.get('UtcCreate') is not None:
            self.utc_create = m.get('UtcCreate')
        return self


class GenerateDeviceNameListURLResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GenerateDeviceNameListURLResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The information returned if the call is successful. For more information, see the following parameters:
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GenerateDeviceNameListURLResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GenerateDeviceNameListURLResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GenerateDeviceNameListURLResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GenerateDeviceNameListURLResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GenerateFileUploadURLRequest(TeaModel):
    def __init__(
        self,
        biz_code: str = None,
        file_name: str = None,
        file_suffix: str = None,
        iot_instance_id: str = None,
    ):
        self.biz_code = biz_code
        self.file_name = file_name
        self.file_suffix = file_suffix
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_code is not None:
            result['BizCode'] = self.biz_code
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_suffix is not None:
            result['FileSuffix'] = self.file_suffix
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BizCode') is not None:
            self.biz_code = m.get('BizCode')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileSuffix') is not None:
            self.file_suffix = m.get('FileSuffix')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class GenerateFileUploadURLResponseBodyData(TeaModel):
    def __init__(
        self,
        host: str = None,
        key: str = None,
        object_storage: str = None,
        oss_access_key_id: str = None,
        policy: str = None,
        signature: str = None,
    ):
        self.host = host
        self.key = key
        self.object_storage = object_storage
        self.oss_access_key_id = oss_access_key_id
        self.policy = policy
        self.signature = signature

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.host is not None:
            result['Host'] = self.host
        if self.key is not None:
            result['Key'] = self.key
        if self.object_storage is not None:
            result['ObjectStorage'] = self.object_storage
        if self.oss_access_key_id is not None:
            result['OssAccessKeyId'] = self.oss_access_key_id
        if self.policy is not None:
            result['Policy'] = self.policy
        if self.signature is not None:
            result['Signature'] = self.signature
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('ObjectStorage') is not None:
            self.object_storage = m.get('ObjectStorage')
        if m.get('OssAccessKeyId') is not None:
            self.oss_access_key_id = m.get('OssAccessKeyId')
        if m.get('Policy') is not None:
            self.policy = m.get('Policy')
        if m.get('Signature') is not None:
            self.signature = m.get('Signature')
        return self


class GenerateFileUploadURLResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GenerateFileUploadURLResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GenerateFileUploadURLResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GenerateFileUploadURLResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GenerateFileUploadURLResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GenerateFileUploadURLResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GenerateOTAUploadURLRequest(TeaModel):
    def __init__(
        self,
        file_suffix: str = None,
        iot_instance_id: str = None,
    ):
        # The file name extension of the update package file. Valid values: bin, dav, apk, tar, gz, tar.gz, zip, and gzip.
        # 
        # Default value: bin.
        self.file_suffix = file_suffix
        # The ID of the instance. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.
        # >*   If no **Overview** page or ID is generated for your instance, you do not need to configure this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_suffix is not None:
            result['FileSuffix'] = self.file_suffix
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileSuffix') is not None:
            self.file_suffix = m.get('FileSuffix')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class GenerateOTAUploadURLResponseBodyData(TeaModel):
    def __init__(
        self,
        firmware_url: str = None,
        host: str = None,
        key: str = None,
        ossaccess_key_id: str = None,
        object_storage: str = None,
        policy: str = None,
        signature: str = None,
        utc_create: str = None,
    ):
        # The URL of the update package file that is stored in OSS.
        # 
        # After the update package file is uploaded, this parameter is used to call the [CreateOTAFirmware](~~147311~~) operation to create an update package.
        self.firmware_url = firmware_url
        # The endpoint of OSS.
        self.host = host
        # The full path of the file in OSS. The file is uploaded by calling the OSS PostObject operation.
        self.key = key
        # The AccessKey ID of the bucket owner.
        # 
        # This OSS bucket stores the update package file.
        self.ossaccess_key_id = ossaccess_key_id
        # The type of object storage. Default value: OSS.
        self.object_storage = object_storage
        # The parameter that is used by OSS to verify form fields for the request.
        self.policy = policy
        # The signature that is calculated based on **AccessKeySecret** and **Policy**. When you call an OSS operation, OSS uses the signature information to verify the POST request.
        self.signature = signature
        # The time when the URL of the uploaded update package file was generated. The time is displayed in UTC.
        self.utc_create = utc_create

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.firmware_url is not None:
            result['FirmwareUrl'] = self.firmware_url
        if self.host is not None:
            result['Host'] = self.host
        if self.key is not None:
            result['Key'] = self.key
        if self.ossaccess_key_id is not None:
            result['OSSAccessKeyId'] = self.ossaccess_key_id
        if self.object_storage is not None:
            result['ObjectStorage'] = self.object_storage
        if self.policy is not None:
            result['Policy'] = self.policy
        if self.signature is not None:
            result['Signature'] = self.signature
        if self.utc_create is not None:
            result['UtcCreate'] = self.utc_create
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FirmwareUrl') is not None:
            self.firmware_url = m.get('FirmwareUrl')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('OSSAccessKeyId') is not None:
            self.ossaccess_key_id = m.get('OSSAccessKeyId')
        if m.get('ObjectStorage') is not None:
            self.object_storage = m.get('ObjectStorage')
        if m.get('Policy') is not None:
            self.policy = m.get('Policy')
        if m.get('Signature') is not None:
            self.signature = m.get('Signature')
        if m.get('UtcCreate') is not None:
            self.utc_create = m.get('UtcCreate')
        return self


class GenerateOTAUploadURLResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GenerateOTAUploadURLResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The information returned if the call is successful. For more information, see the following parameters.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful. Valid values:
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GenerateOTAUploadURLResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GenerateOTAUploadURLResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GenerateOTAUploadURLResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GenerateOTAUploadURLResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDataAPIServiceDetailRequest(TeaModel):
    def __init__(
        self,
        api_srn: str = None,
        iot_instance_id: str = None,
    ):
        self.api_srn = api_srn
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.api_srn is not None:
            result['ApiSrn'] = self.api_srn
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApiSrn') is not None:
            self.api_srn = m.get('ApiSrn')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParamsRequestParams(TeaModel):
    def __init__(
        self,
        desc: str = None,
        example: str = None,
        name: str = None,
        required: bool = None,
        type: str = None,
    ):
        self.desc = desc
        self.example = example
        self.name = name
        self.required = required
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desc is not None:
            result['Desc'] = self.desc
        if self.example is not None:
            result['Example'] = self.example
        if self.name is not None:
            result['Name'] = self.name
        if self.required is not None:
            result['Required'] = self.required
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Desc') is not None:
            self.desc = m.get('Desc')
        if m.get('Example') is not None:
            self.example = m.get('Example')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Required') is not None:
            self.required = m.get('Required')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParams(TeaModel):
    def __init__(
        self,
        request_params: List[GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParamsRequestParams] = None,
    ):
        self.request_params = request_params

    def validate(self):
        if self.request_params:
            for k in self.request_params:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['RequestParams'] = []
        if self.request_params is not None:
            for k in self.request_params:
                result['RequestParams'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.request_params = []
        if m.get('RequestParams') is not None:
            for k in m.get('RequestParams'):
                temp_model = GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParamsRequestParams()
                self.request_params.append(temp_model.from_map(k))
        return self


class GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParamsResponseParams(TeaModel):
    def __init__(
        self,
        desc: str = None,
        example: str = None,
        name: str = None,
        required: bool = None,
        type: str = None,
    ):
        self.desc = desc
        self.example = example
        self.name = name
        self.required = required
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desc is not None:
            result['Desc'] = self.desc
        if self.example is not None:
            result['Example'] = self.example
        if self.name is not None:
            result['Name'] = self.name
        if self.required is not None:
            result['Required'] = self.required
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Desc') is not None:
            self.desc = m.get('Desc')
        if m.get('Example') is not None:
            self.example = m.get('Example')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Required') is not None:
            self.required = m.get('Required')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParams(TeaModel):
    def __init__(
        self,
        response_params: List[GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParamsResponseParams] = None,
    ):
        self.response_params = response_params

    def validate(self):
        if self.response_params:
            for k in self.response_params:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ResponseParams'] = []
        if self.response_params is not None:
            for k in self.response_params:
                result['ResponseParams'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.response_params = []
        if m.get('ResponseParams') is not None:
            for k in m.get('ResponseParams'):
                temp_model = GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParamsResponseParams()
                self.response_params.append(temp_model.from_map(k))
        return self


class GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTO(TeaModel):
    def __init__(
        self,
        origin_sql: str = None,
        request_params: GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParams = None,
        response_params: GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParams = None,
        template_sql: str = None,
    ):
        self.origin_sql = origin_sql
        self.request_params = request_params
        self.response_params = response_params
        self.template_sql = template_sql

    def validate(self):
        if self.request_params:
            self.request_params.validate()
        if self.response_params:
            self.response_params.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.origin_sql is not None:
            result['OriginSql'] = self.origin_sql
        if self.request_params is not None:
            result['RequestParams'] = self.request_params.to_map()
        if self.response_params is not None:
            result['ResponseParams'] = self.response_params.to_map()
        if self.template_sql is not None:
            result['TemplateSql'] = self.template_sql
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OriginSql') is not None:
            self.origin_sql = m.get('OriginSql')
        if m.get('RequestParams') is not None:
            temp_model = GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParams()
            self.request_params = temp_model.from_map(m['RequestParams'])
        if m.get('ResponseParams') is not None:
            temp_model = GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParams()
            self.response_params = temp_model.from_map(m['ResponseParams'])
        if m.get('TemplateSql') is not None:
            self.template_sql = m.get('TemplateSql')
        return self


class GetDataAPIServiceDetailResponseBodyData(TeaModel):
    def __init__(
        self,
        api_path: str = None,
        api_srn: str = None,
        create_time: int = None,
        date_format: str = None,
        description: str = None,
        display_name: str = None,
        last_update_time: int = None,
        request_method: str = None,
        request_protocol: str = None,
        sql_template_dto: GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTO = None,
        status: int = None,
    ):
        self.api_path = api_path
        self.api_srn = api_srn
        self.create_time = create_time
        self.date_format = date_format
        self.description = description
        self.display_name = display_name
        self.last_update_time = last_update_time
        self.request_method = request_method
        self.request_protocol = request_protocol
        self.sql_template_dto = sql_template_dto
        self.status = status

    def validate(self):
        if self.sql_template_dto:
            self.sql_template_dto.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.api_path is not None:
            result['ApiPath'] = self.api_path
        if self.api_srn is not None:
            result['ApiSrn'] = self.api_srn
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.date_format is not None:
            result['DateFormat'] = self.date_format
        if self.description is not None:
            result['Description'] = self.description
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.last_update_time is not None:
            result['LastUpdateTime'] = self.last_update_time
        if self.request_method is not None:
            result['RequestMethod'] = self.request_method
        if self.request_protocol is not None:
            result['RequestProtocol'] = self.request_protocol
        if self.sql_template_dto is not None:
            result['SqlTemplateDTO'] = self.sql_template_dto.to_map()
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApiPath') is not None:
            self.api_path = m.get('ApiPath')
        if m.get('ApiSrn') is not None:
            self.api_srn = m.get('ApiSrn')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DateFormat') is not None:
            self.date_format = m.get('DateFormat')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('LastUpdateTime') is not None:
            self.last_update_time = m.get('LastUpdateTime')
        if m.get('RequestMethod') is not None:
            self.request_method = m.get('RequestMethod')
        if m.get('RequestProtocol') is not None:
            self.request_protocol = m.get('RequestProtocol')
        if m.get('SqlTemplateDTO') is not None:
            temp_model = GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTO()
            self.sql_template_dto = temp_model.from_map(m['SqlTemplateDTO'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class GetDataAPIServiceDetailResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetDataAPIServiceDetailResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetDataAPIServiceDetailResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDataAPIServiceDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDataAPIServiceDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDataAPIServiceDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDestinationRequest(TeaModel):
    def __init__(
        self,
        destination_id: int = None,
        iot_instance_id: str = None,
    ):
        self.destination_id = destination_id
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.destination_id is not None:
            result['DestinationId'] = self.destination_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DestinationId') is not None:
            self.destination_id = m.get('DestinationId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class GetDestinationResponseBodyDestination(TeaModel):
    def __init__(
        self,
        configuration: str = None,
        destination_id: str = None,
        is_failover: bool = None,
        name: str = None,
        status: str = None,
        type: str = None,
        utc_created: str = None,
    ):
        # The configuration data of the data destination.
        self.configuration = configuration
        # The ID of the data destination.
        self.destination_id = destination_id
        # Indicates whether the data destination is configured to receive error operation data. Error operation data is data that failed to be forwarded for two consecutive times.
        # 
        # *   **true**: The data destination is configured to receive error operation data.
        # *   **false**: The data destination is configured to receive regular data instead of error operation data.
        # 
        # Default value: **false**.
        self.is_failover = is_failover
        # The name of the data destination.
        self.name = name
        self.status = status
        # The operation that is performed on the data of the data destination.
        # 
        # *   **REPUBLISH**: forwards topic data that is processed by a parser script to an IoT Platform communication topic.
        # *   **AMQP**: forwards topic data that is processed by a parser script to an Advanced Message Queuing Protocol (AMQP) consumer group.
        # *   **DATAHUB**: forwards topic data to Alibaba Cloud DataHub for stream data processing.
        # *   **ONS**: forwards topic data that is processed by a parser script to Message Queue for Apache RocketMQ for message distribution.
        # *   **MNS**: forwards topic data to Message Service (MNS) for message transmission.
        # *   **FC**: forwards topic data to Function Compute for event computing.
        # *   **OTS**: forwards topic data to Tablestore for NoSQL data storage.
        self.type = type
        # The time when the data destination was created. The time is displayed in UTC. Format: `yyyy-MM-dd\"T\"HH:mm:ss.SSS\"Z\"`.
        self.utc_created = utc_created

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.configuration is not None:
            result['Configuration'] = self.configuration
        if self.destination_id is not None:
            result['DestinationId'] = self.destination_id
        if self.is_failover is not None:
            result['IsFailover'] = self.is_failover
        if self.name is not None:
            result['Name'] = self.name
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        if self.utc_created is not None:
            result['UtcCreated'] = self.utc_created
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Configuration') is not None:
            self.configuration = m.get('Configuration')
        if m.get('DestinationId') is not None:
            self.destination_id = m.get('DestinationId')
        if m.get('IsFailover') is not None:
            self.is_failover = m.get('IsFailover')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UtcCreated') is not None:
            self.utc_created = m.get('UtcCreated')
        return self


class GetDestinationResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        destination: GetDestinationResponseBodyDestination = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The information about the data destination.
        self.destination = destination
        # The error message returned if the request fails.
        self.error_message = error_message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success

    def validate(self):
        if self.destination:
            self.destination.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.destination is not None:
            result['Destination'] = self.destination.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Destination') is not None:
            temp_model = GetDestinationResponseBodyDestination()
            self.destination = temp_model.from_map(m['Destination'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDestinationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDestinationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDestinationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDeviceShadowRequest(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        iot_instance_id: str = None,
        product_key: str = None,
    ):
        # The DeviceName of the device.
        self.device_name = device_name
        # The ID of the instance. You can view the ID of the instance on the **Overview** page in the IoT Platform console.****\
        # 
        # >*   If the instance has an ID, you must specify the **IotInstanceId** parameter. If you do not specify this parameter, the call fails.
        # >*   If the instance does not have an **ID** or the **Overview** page is not displayed, you do not need to specify this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The **ProductKey** of the product to which the device belongs.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class GetDeviceShadowResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        shadow_message: str = None,
        success: bool = None,
    ):
        # The error code that is returned if the call fails. For more information about error codes, see [Error codes](~~87387~~).
        self.code = code
        # The error message that is returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # The shadow information that is returned if the call is successful.
        # 
        # >  The structure of the shadow information varies based on the status of the device. For more information, see the [Overview](~~53930~~) topic of Device shadows.
        self.shadow_message = shadow_message
        # Indicates whether the call was successful. Valid values:
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.shadow_message is not None:
            result['ShadowMessage'] = self.shadow_message
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ShadowMessage') is not None:
            self.shadow_message = m.get('ShadowMessage')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDeviceShadowResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDeviceShadowResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDeviceShadowResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDeviceStatusRequest(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        iot_id: str = None,
        iot_instance_id: str = None,
        product_key: str = None,
    ):
        # The DeviceName of the device.
        # 
        # >  If you specify this parameter, you must also specify the **ProductKey** parameter.
        self.device_name = device_name
        # The ID of the device. The ID is a unique identifier that is issued by IoT Platform to the device.
        # 
        # >  If you specify this parameter, you do not need to specify **ProductKey** or **DeviceName**. The **IotId** parameter specifies a globally unique identifier (GUID) of the device, which corresponds to a combination of **ProductKey** and **DeviceName**. If you specify both **IotId** and the combination of **ProductKey** and **DeviceName**, **IotId** takes precedence.
        self.iot_id = iot_id
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The ProductKey of the product to which the device belongs.
        # 
        # >  If you specify this parameter, you must also specify the **DeviceName** parameter.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class GetDeviceStatusResponseBodyData(TeaModel):
    def __init__(
        self,
        status: str = None,
        timestamp: int = None,
    ):
        # The status of the device. Valid values:
        # 
        # *   **ONLINE**: The device is online.
        # *   **OFFLINE**: The device is offline.
        # *   **UNACTIVE**: The device is not activated.
        # *   **DISABLE**: The device is disabled.
        self.status = status
        # The time when the device status changed.
        self.timestamp = timestamp

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.status is not None:
            result['Status'] = self.status
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        return self


class GetDeviceStatusResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetDeviceStatusResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The device status returned if the call is successful.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetDeviceStatusResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDeviceStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDeviceStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDeviceStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDeviceTunnelShareStatusRequest(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        iot_instance_id: str = None,
        product_key: str = None,
    ):
        self.device_name = device_name
        self.iot_instance_id = iot_instance_id
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class GetDeviceTunnelShareStatusResponseBodyData(TeaModel):
    def __init__(
        self,
        gmt_opened: int = None,
        is_open: bool = None,
        password: str = None,
        share_id: str = None,
    ):
        self.gmt_opened = gmt_opened
        self.is_open = is_open
        self.password = password
        self.share_id = share_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gmt_opened is not None:
            result['GmtOpened'] = self.gmt_opened
        if self.is_open is not None:
            result['IsOpen'] = self.is_open
        if self.password is not None:
            result['Password'] = self.password
        if self.share_id is not None:
            result['ShareId'] = self.share_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GmtOpened') is not None:
            self.gmt_opened = m.get('GmtOpened')
        if m.get('IsOpen') is not None:
            self.is_open = m.get('IsOpen')
        if m.get('Password') is not None:
            self.password = m.get('Password')
        if m.get('ShareId') is not None:
            self.share_id = m.get('ShareId')
        return self


class GetDeviceTunnelShareStatusResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetDeviceTunnelShareStatusResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetDeviceTunnelShareStatusResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDeviceTunnelShareStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDeviceTunnelShareStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDeviceTunnelShareStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDeviceTunnelStatusRequest(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        iot_instance_id: str = None,
        product_key: str = None,
    ):
        self.device_name = device_name
        self.iot_instance_id = iot_instance_id
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class GetDeviceTunnelStatusResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDeviceTunnelStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDeviceTunnelStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDeviceTunnelStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDownloadFileRequest(TeaModel):
    def __init__(
        self,
        context: Dict[str, Any] = None,
        iot_instance_id: str = None,
        long_job_id: str = None,
    ):
        self.context = context
        self.iot_instance_id = iot_instance_id
        self.long_job_id = long_job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.context is not None:
            result['Context'] = self.context
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.long_job_id is not None:
            result['LongJobId'] = self.long_job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Context') is not None:
            self.context = m.get('Context')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('LongJobId') is not None:
            self.long_job_id = m.get('LongJobId')
        return self


class GetDownloadFileShrinkRequest(TeaModel):
    def __init__(
        self,
        context_shrink: str = None,
        iot_instance_id: str = None,
        long_job_id: str = None,
    ):
        self.context_shrink = context_shrink
        self.iot_instance_id = iot_instance_id
        self.long_job_id = long_job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.context_shrink is not None:
            result['Context'] = self.context_shrink
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.long_job_id is not None:
            result['LongJobId'] = self.long_job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Context') is not None:
            self.context_shrink = m.get('Context')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('LongJobId') is not None:
            self.long_job_id = m.get('LongJobId')
        return self


class GetDownloadFileResponseBodyDataHeader(TeaModel):
    def __init__(
        self,
        alias: str = None,
        dim_date_class: str = None,
        field_name: str = None,
        field_type: str = None,
        geo_class: str = None,
        time_class: str = None,
        type_class: str = None,
    ):
        self.alias = alias
        self.dim_date_class = dim_date_class
        self.field_name = field_name
        self.field_type = field_type
        self.geo_class = geo_class
        self.time_class = time_class
        self.type_class = type_class

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.dim_date_class is not None:
            result['DimDateClass'] = self.dim_date_class
        if self.field_name is not None:
            result['FieldName'] = self.field_name
        if self.field_type is not None:
            result['FieldType'] = self.field_type
        if self.geo_class is not None:
            result['GeoClass'] = self.geo_class
        if self.time_class is not None:
            result['TimeClass'] = self.time_class
        if self.type_class is not None:
            result['TypeClass'] = self.type_class
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('DimDateClass') is not None:
            self.dim_date_class = m.get('DimDateClass')
        if m.get('FieldName') is not None:
            self.field_name = m.get('FieldName')
        if m.get('FieldType') is not None:
            self.field_type = m.get('FieldType')
        if m.get('GeoClass') is not None:
            self.geo_class = m.get('GeoClass')
        if m.get('TimeClass') is not None:
            self.time_class = m.get('TimeClass')
        if m.get('TypeClass') is not None:
            self.type_class = m.get('TypeClass')
        return self


class GetDownloadFileResponseBodyDataQuerySettingAstExpr(TeaModel):
    def __init__(
        self,
        expr: str = None,
        expr_type: str = None,
    ):
        self.expr = expr
        self.expr_type = expr_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expr is not None:
            result['Expr'] = self.expr
        if self.expr_type is not None:
            result['ExprType'] = self.expr_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Expr') is not None:
            self.expr = m.get('Expr')
        if m.get('ExprType') is not None:
            self.expr_type = m.get('ExprType')
        return self


class GetDownloadFileResponseBodyDataQuerySettingSelectedHeaders(TeaModel):
    def __init__(
        self,
        alias: str = None,
        dim_date_class: str = None,
        field_name: str = None,
        field_type: str = None,
        geo_class: str = None,
        time_class: str = None,
    ):
        self.alias = alias
        self.dim_date_class = dim_date_class
        self.field_name = field_name
        self.field_type = field_type
        self.geo_class = geo_class
        self.time_class = time_class

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.dim_date_class is not None:
            result['DimDateClass'] = self.dim_date_class
        if self.field_name is not None:
            result['FieldName'] = self.field_name
        if self.field_type is not None:
            result['FieldType'] = self.field_type
        if self.geo_class is not None:
            result['GeoClass'] = self.geo_class
        if self.time_class is not None:
            result['TimeClass'] = self.time_class
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('DimDateClass') is not None:
            self.dim_date_class = m.get('DimDateClass')
        if m.get('FieldName') is not None:
            self.field_name = m.get('FieldName')
        if m.get('FieldType') is not None:
            self.field_type = m.get('FieldType')
        if m.get('GeoClass') is not None:
            self.geo_class = m.get('GeoClass')
        if m.get('TimeClass') is not None:
            self.time_class = m.get('TimeClass')
        return self


class GetDownloadFileResponseBodyDataQuerySetting(TeaModel):
    def __init__(
        self,
        ast_expr: List[GetDownloadFileResponseBodyDataQuerySettingAstExpr] = None,
        selected_headers: List[GetDownloadFileResponseBodyDataQuerySettingSelectedHeaders] = None,
    ):
        self.ast_expr = ast_expr
        self.selected_headers = selected_headers

    def validate(self):
        if self.ast_expr:
            for k in self.ast_expr:
                if k:
                    k.validate()
        if self.selected_headers:
            for k in self.selected_headers:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AstExpr'] = []
        if self.ast_expr is not None:
            for k in self.ast_expr:
                result['AstExpr'].append(k.to_map() if k else None)
        result['SelectedHeaders'] = []
        if self.selected_headers is not None:
            for k in self.selected_headers:
                result['SelectedHeaders'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.ast_expr = []
        if m.get('AstExpr') is not None:
            for k in m.get('AstExpr'):
                temp_model = GetDownloadFileResponseBodyDataQuerySettingAstExpr()
                self.ast_expr.append(temp_model.from_map(k))
        self.selected_headers = []
        if m.get('SelectedHeaders') is not None:
            for k in m.get('SelectedHeaders'):
                temp_model = GetDownloadFileResponseBodyDataQuerySettingSelectedHeaders()
                self.selected_headers.append(temp_model.from_map(k))
        return self


class GetDownloadFileResponseBodyData(TeaModel):
    def __init__(
        self,
        async_execute: bool = None,
        begin_time: int = None,
        csv_file_name: str = None,
        csv_url: str = None,
        dataset_id: str = None,
        end_time: int = None,
        header: List[GetDownloadFileResponseBodyDataHeader] = None,
        long_job_id: str = None,
        page_no: int = None,
        page_size: int = None,
        preview_size: int = None,
        query_setting: GetDownloadFileResponseBodyDataQuerySetting = None,
        result: List[Dict[str, Any]] = None,
        result_data_in_string: str = None,
        status: int = None,
        total_count: int = None,
    ):
        self.async_execute = async_execute
        self.begin_time = begin_time
        self.csv_file_name = csv_file_name
        self.csv_url = csv_url
        self.dataset_id = dataset_id
        self.end_time = end_time
        self.header = header
        self.long_job_id = long_job_id
        self.page_no = page_no
        self.page_size = page_size
        self.preview_size = preview_size
        self.query_setting = query_setting
        self.result = result
        self.result_data_in_string = result_data_in_string
        self.status = status
        self.total_count = total_count

    def validate(self):
        if self.header:
            for k in self.header:
                if k:
                    k.validate()
        if self.query_setting:
            self.query_setting.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.async_execute is not None:
            result['AsyncExecute'] = self.async_execute
        if self.begin_time is not None:
            result['BeginTime'] = self.begin_time
        if self.csv_file_name is not None:
            result['CsvFileName'] = self.csv_file_name
        if self.csv_url is not None:
            result['CsvUrl'] = self.csv_url
        if self.dataset_id is not None:
            result['DatasetId'] = self.dataset_id
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        result['Header'] = []
        if self.header is not None:
            for k in self.header:
                result['Header'].append(k.to_map() if k else None)
        if self.long_job_id is not None:
            result['LongJobId'] = self.long_job_id
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.preview_size is not None:
            result['PreviewSize'] = self.preview_size
        if self.query_setting is not None:
            result['QuerySetting'] = self.query_setting.to_map()
        if self.result is not None:
            result['Result'] = self.result
        if self.result_data_in_string is not None:
            result['ResultDataInString'] = self.result_data_in_string
        if self.status is not None:
            result['Status'] = self.status
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AsyncExecute') is not None:
            self.async_execute = m.get('AsyncExecute')
        if m.get('BeginTime') is not None:
            self.begin_time = m.get('BeginTime')
        if m.get('CsvFileName') is not None:
            self.csv_file_name = m.get('CsvFileName')
        if m.get('CsvUrl') is not None:
            self.csv_url = m.get('CsvUrl')
        if m.get('DatasetId') is not None:
            self.dataset_id = m.get('DatasetId')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        self.header = []
        if m.get('Header') is not None:
            for k in m.get('Header'):
                temp_model = GetDownloadFileResponseBodyDataHeader()
                self.header.append(temp_model.from_map(k))
        if m.get('LongJobId') is not None:
            self.long_job_id = m.get('LongJobId')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('PreviewSize') is not None:
            self.preview_size = m.get('PreviewSize')
        if m.get('QuerySetting') is not None:
            temp_model = GetDownloadFileResponseBodyDataQuerySetting()
            self.query_setting = temp_model.from_map(m['QuerySetting'])
        if m.get('Result') is not None:
            self.result = m.get('Result')
        if m.get('ResultDataInString') is not None:
            self.result_data_in_string = m.get('ResultDataInString')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class GetDownloadFileResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetDownloadFileResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetDownloadFileResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetDownloadFileResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetDownloadFileResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDownloadFileResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetEdgeDriverVersionRequest(TeaModel):
    def __init__(
        self,
        driver_id: str = None,
        driver_version: str = None,
        iot_instance_id: str = None,
    ):
        # The ID of the driver. To obtain the driver ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Drivers** page, move the pointer over the name of the driver whose version information you want to query and obtain the driver ID.
        # 
        # You can also call the [QueryEdgeDriver](~~155776~~) operation to query the driver ID.
        self.driver_id = driver_id
        # The version number of the driver.
        self.driver_version = driver_version
        # The ID of the Internet of Things (IoT) service instance. This parameter is not required for the public instance but required for Enterprise Edition instances.
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.driver_id is not None:
            result['DriverId'] = self.driver_id
        if self.driver_version is not None:
            result['DriverVersion'] = self.driver_version
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DriverId') is not None:
            self.driver_id = m.get('DriverId')
        if m.get('DriverVersion') is not None:
            self.driver_version = m.get('DriverVersion')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class GetEdgeDriverVersionResponseBodyData(TeaModel):
    def __init__(
        self,
        argument: str = None,
        config_check_rule: str = None,
        container_config: str = None,
        description: str = None,
        driver_config: str = None,
        driver_id: str = None,
        driver_version: str = None,
        edge_version: str = None,
        gmt_create_timestamp: int = None,
        gmt_modified_timestamp: int = None,
        source_config: str = None,
        version_state: str = None,
    ):
        # The Java Virtual Machine (JVM) startup parameter.
        self.argument = argument
        # The rule for verifying configurations. The value is a JSON string in the following format:
        # 
        # `{"deviceConfig":{"required":false},"driverConfig":{"required":false}`
        # 
        # The JSON string contains the following parameters:
        # 
        # *   driverConfig: the rule for verifying the configuration of the driver when the driver is to be deployed in an edge instance.
        # *   deviceConfig: the rule for verifying the configurations of devices that use the driver when the driver is to be deployed in an edge instance.
        self.config_check_rule = config_check_rule
        # The configuration of the container where the driver runs. The value is a JSON string. For more information about parameters in the JSON string, see the following parameter description of ContainerConfig.
        self.container_config = container_config
        # The description of the driver.
        self.description = description
        # The configuration of the driver. The value is a JSON string in the following format:
        # 
        # `{"format":"JSON","content":"{}"}`
        # 
        # The JSON string contains the following parameters:
        # 
        # *   format: the format of the driver configuration. Valid values: KV (key-value pair), JSON (JSON string), and FILE (configuration file).
        # *   content: the content of the driver configuration. If the format parameter is set to KV or JSON, the value of this parameter is the configuration content. If the format parameter is set to FILE, the value of this parameter is the URL of the configuration file stored in Object Storage Service (OSS).
        self.driver_config = driver_config
        # The ID of the driver.
        self.driver_id = driver_id
        # The version number of the driver.
        self.driver_version = driver_version
        # The earliest version of Link IoT Edge that is supported by the driver.
        self.edge_version = edge_version
        # The UNIX timestamp when the driver was created.
        self.gmt_create_timestamp = gmt_create_timestamp
        # The last UNIX timestamp when the driver was updated.
        self.gmt_modified_timestamp = gmt_modified_timestamp
        self.source_config = source_config
        # The status of the driver version. Valid values:
        # 
        # *   0: The driver version was not published.
        # *   1: The driver version was published.
        self.version_state = version_state

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.argument is not None:
            result['Argument'] = self.argument
        if self.config_check_rule is not None:
            result['ConfigCheckRule'] = self.config_check_rule
        if self.container_config is not None:
            result['ContainerConfig'] = self.container_config
        if self.description is not None:
            result['Description'] = self.description
        if self.driver_config is not None:
            result['DriverConfig'] = self.driver_config
        if self.driver_id is not None:
            result['DriverId'] = self.driver_id
        if self.driver_version is not None:
            result['DriverVersion'] = self.driver_version
        if self.edge_version is not None:
            result['EdgeVersion'] = self.edge_version
        if self.gmt_create_timestamp is not None:
            result['GmtCreateTimestamp'] = self.gmt_create_timestamp
        if self.gmt_modified_timestamp is not None:
            result['GmtModifiedTimestamp'] = self.gmt_modified_timestamp
        if self.source_config is not None:
            result['SourceConfig'] = self.source_config
        if self.version_state is not None:
            result['VersionState'] = self.version_state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Argument') is not None:
            self.argument = m.get('Argument')
        if m.get('ConfigCheckRule') is not None:
            self.config_check_rule = m.get('ConfigCheckRule')
        if m.get('ContainerConfig') is not None:
            self.container_config = m.get('ContainerConfig')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DriverConfig') is not None:
            self.driver_config = m.get('DriverConfig')
        if m.get('DriverId') is not None:
            self.driver_id = m.get('DriverId')
        if m.get('DriverVersion') is not None:
            self.driver_version = m.get('DriverVersion')
        if m.get('EdgeVersion') is not None:
            self.edge_version = m.get('EdgeVersion')
        if m.get('GmtCreateTimestamp') is not None:
            self.gmt_create_timestamp = m.get('GmtCreateTimestamp')
        if m.get('GmtModifiedTimestamp') is not None:
            self.gmt_modified_timestamp = m.get('GmtModifiedTimestamp')
        if m.get('SourceConfig') is not None:
            self.source_config = m.get('SourceConfig')
        if m.get('VersionState') is not None:
            self.version_state = m.get('VersionState')
        return self


class GetEdgeDriverVersionResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetEdgeDriverVersionResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The return code of the operation. A value of Success indicates that the call was successful. Other values indicate that specific errors occurred. For more information, see [Error codes](~~135200~~).
        self.code = code
        # The data that is returned if the call was successful.
        self.data = data
        # The error message that is returned if the call failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful. A value of true indicates that the call was successful. A value of false indicates that the call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetEdgeDriverVersionResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetEdgeDriverVersionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetEdgeDriverVersionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetEdgeDriverVersionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetEdgeInstanceRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        iot_instance_id: str = None,
    ):
        # The ID of the edge instance. To obtain the instance ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Edge Instances** page, move the pointer over the name of the edge instance whose detailed information you want to query and obtain the instance ID.
        # 
        # You can also call the [QueryEdgeInstance](~~135214~~) operation to query the instance ID.
        self.instance_id = instance_id
        # The ID of the Internet of Things (IoT) service instance. This parameter is not required for the public instance but required for Enterprise Edition instances.
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class GetEdgeInstanceResponseBodyData(TeaModel):
    def __init__(
        self,
        biz_enable: bool = None,
        gmt_create: str = None,
        gmt_create_timestamp: int = None,
        gmt_modified: str = None,
        gmt_modified_timestamp: int = None,
        instance_id: str = None,
        latest_deployment_status: int = None,
        latest_deployment_type: str = None,
        name: str = None,
        role_arn: str = None,
        role_attach_time: str = None,
        role_attach_timestamp: int = None,
        role_name: str = None,
        spec: int = None,
        tags: str = None,
        type: str = None,
    ):
        # Indicates whether the edge instance was enabled. Valid values:
        # 
        # *   true: enabled
        # *   false: disabled
        self.biz_enable = biz_enable
        # The time when the edge instance was created.
        self.gmt_create = gmt_create
        # The UNIX timestamp when the edge instance was created.
        self.gmt_create_timestamp = gmt_create_timestamp
        # The last time when the edge instance was updated.
        self.gmt_modified = gmt_modified
        # The last UNIX timestamp when the edge instance was updated.
        self.gmt_modified_timestamp = gmt_modified_timestamp
        # The ID of the edge instance.
        self.instance_id = instance_id
        # The status of the latest deployment task. Valid values:
        # 
        # *   0: The task was not started.
        # *   1: The task was being processed.
        # *   2: The task was successful.
        # *   3: The task failed.
        self.latest_deployment_status = latest_deployment_status
        # The type of the latest deployment task. Valid values:
        # 
        # *   deploy: deploys the edge instance.
        # *   reset: resets the edge instance.
        self.latest_deployment_type = latest_deployment_type
        # The name of the edge instance.
        self.name = name
        # The Alibaba Cloud Resource Name (ARN) of the RAM role.
        self.role_arn = role_arn
        # The time when the RAM role was attached to IoT Platform.
        self.role_attach_time = role_attach_time
        # The UNIX timestamp when the RAM role was attached to IoT Platform.
        self.role_attach_timestamp = role_attach_timestamp
        # The name of the RAM role.
        self.role_name = role_name
        # The specifications of the edge instance. Valid values:
        # 
        # *   10: Lite Edition
        # *   20: Standard Edition
        # *   30: Pro Edition
        self.spec = spec
        # The tags of the edge instance. Each tag is a `key-value` pair. Multiple tags are separated with commas(,). Example: `k1:v1,k2:v2`.
        self.tags = tags
        # Indicates whether you own the edge instance or you are authorized to use the edge instance. Valid values:
        # 
        # *   0: You own the edge instance.
        # *   1: You are authorized to use the edge instance.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_enable is not None:
            result['BizEnable'] = self.biz_enable
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_create_timestamp is not None:
            result['GmtCreateTimestamp'] = self.gmt_create_timestamp
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.gmt_modified_timestamp is not None:
            result['GmtModifiedTimestamp'] = self.gmt_modified_timestamp
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.latest_deployment_status is not None:
            result['LatestDeploymentStatus'] = self.latest_deployment_status
        if self.latest_deployment_type is not None:
            result['LatestDeploymentType'] = self.latest_deployment_type
        if self.name is not None:
            result['Name'] = self.name
        if self.role_arn is not None:
            result['RoleArn'] = self.role_arn
        if self.role_attach_time is not None:
            result['RoleAttachTime'] = self.role_attach_time
        if self.role_attach_timestamp is not None:
            result['RoleAttachTimestamp'] = self.role_attach_timestamp
        if self.role_name is not None:
            result['RoleName'] = self.role_name
        if self.spec is not None:
            result['Spec'] = self.spec
        if self.tags is not None:
            result['Tags'] = self.tags
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BizEnable') is not None:
            self.biz_enable = m.get('BizEnable')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtCreateTimestamp') is not None:
            self.gmt_create_timestamp = m.get('GmtCreateTimestamp')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('GmtModifiedTimestamp') is not None:
            self.gmt_modified_timestamp = m.get('GmtModifiedTimestamp')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('LatestDeploymentStatus') is not None:
            self.latest_deployment_status = m.get('LatestDeploymentStatus')
        if m.get('LatestDeploymentType') is not None:
            self.latest_deployment_type = m.get('LatestDeploymentType')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RoleArn') is not None:
            self.role_arn = m.get('RoleArn')
        if m.get('RoleAttachTime') is not None:
            self.role_attach_time = m.get('RoleAttachTime')
        if m.get('RoleAttachTimestamp') is not None:
            self.role_attach_timestamp = m.get('RoleAttachTimestamp')
        if m.get('RoleName') is not None:
            self.role_name = m.get('RoleName')
        if m.get('Spec') is not None:
            self.spec = m.get('Spec')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetEdgeInstanceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetEdgeInstanceResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The return code of the operation. A value of Success indicates that the call was successful. Other values indicate that specific errors occurred. For more information, see [Error codes](~~135200~~).
        self.code = code
        # The data that is returned if the call was successful.
        self.data = data
        # The error message that is returned if the call failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful. A value of true indicates that the call was successful. A value of false indicates that the call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetEdgeInstanceResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetEdgeInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetEdgeInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetEdgeInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetEdgeInstanceDeploymentRequest(TeaModel):
    def __init__(
        self,
        deployment_id: str = None,
        instance_id: str = None,
        iot_instance_id: str = None,
    ):
        # The ID of the deployment task. You can call the [QueryEdgeInstanceHistoricDeployment](~~135275~~) operation to query the ID of a deployment task.
        self.deployment_id = deployment_id
        # The ID of the edge instance. To obtain the instance ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Edge Instances** page, move the pointer over the name of the edge instance for which you want to query detailed information about a deployment task and obtain the instance ID.
        # 
        # You can also call the [QueryEdgeInstance](~~135214~~) operation to query the instance ID.
        self.instance_id = instance_id
        # The ID of the Internet of Things (IoT) service instance. This parameter is not required for the public instance but required for Enterprise Edition instances.
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.deployment_id is not None:
            result['DeploymentId'] = self.deployment_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeploymentId') is not None:
            self.deployment_id = m.get('DeploymentId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList(TeaModel):
    def __init__(
        self,
        gmt_completed: str = None,
        gmt_completed_timestamp: int = None,
        gmt_create: str = None,
        gmt_create_timestamp: int = None,
        gmt_modified: str = None,
        gmt_modified_timestamp: int = None,
        log: str = None,
        operate_type: int = None,
        resource_id: str = None,
        resource_name: str = None,
        resource_type: str = None,
        snapshot_id: str = None,
        stage: int = None,
        status: int = None,
    ):
        # The time when the deployment task snapshot was complete.
        self.gmt_completed = gmt_completed
        # The UNIX timestamp when the deployment task snapshot was complete.
        self.gmt_completed_timestamp = gmt_completed_timestamp
        # The time when the deployment task snapshot was created.
        self.gmt_create = gmt_create
        # The UNIX timestamp when the deployment task snapshot was created.
        self.gmt_create_timestamp = gmt_create_timestamp
        # The last time when the deployment task snapshot was modified.
        self.gmt_modified = gmt_modified
        # The last UNIX timestamp when the deployment task snapshot was modified.
        self.gmt_modified_timestamp = gmt_modified_timestamp
        # The logs of resource deployment.
        self.log = log
        # The type of the operation.
        # 
        # *   0: deploys resources.
        # *   1: deletes resources.
        self.operate_type = operate_type
        # The ID of the resource.
        self.resource_id = resource_id
        # The name of the resource.
        self.resource_name = resource_name
        # The type of the resource.
        self.resource_type = resource_type
        # The ID of the deployment task snapshot.
        self.snapshot_id = snapshot_id
        # The stage of the snapshot task.
        # 
        # *   0: The snapshot task was in the initial state.
        # *   8: The snapshot task was being assembled.
        # *   16: The snapshot task was being packaged.
        # *   24: The snapshot task was being dispatched.
        # *   32: The snapshot task was complete.
        self.stage = stage
        # The status of the snapshot task.
        # 
        # *   0: The snapshot task was not started.
        # *   1: The snapshot task was being processed.
        # *   2: The snapshot task was successful.
        # *   3: The snapshot task failed.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gmt_completed is not None:
            result['GmtCompleted'] = self.gmt_completed
        if self.gmt_completed_timestamp is not None:
            result['GmtCompletedTimestamp'] = self.gmt_completed_timestamp
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_create_timestamp is not None:
            result['GmtCreateTimestamp'] = self.gmt_create_timestamp
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.gmt_modified_timestamp is not None:
            result['GmtModifiedTimestamp'] = self.gmt_modified_timestamp
        if self.log is not None:
            result['Log'] = self.log
        if self.operate_type is not None:
            result['OperateType'] = self.operate_type
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.resource_name is not None:
            result['ResourceName'] = self.resource_name
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.snapshot_id is not None:
            result['SnapshotId'] = self.snapshot_id
        if self.stage is not None:
            result['Stage'] = self.stage
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GmtCompleted') is not None:
            self.gmt_completed = m.get('GmtCompleted')
        if m.get('GmtCompletedTimestamp') is not None:
            self.gmt_completed_timestamp = m.get('GmtCompletedTimestamp')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtCreateTimestamp') is not None:
            self.gmt_create_timestamp = m.get('GmtCreateTimestamp')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('GmtModifiedTimestamp') is not None:
            self.gmt_modified_timestamp = m.get('GmtModifiedTimestamp')
        if m.get('Log') is not None:
            self.log = m.get('Log')
        if m.get('OperateType') is not None:
            self.operate_type = m.get('OperateType')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('ResourceName') is not None:
            self.resource_name = m.get('ResourceName')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('SnapshotId') is not None:
            self.snapshot_id = m.get('SnapshotId')
        if m.get('Stage') is not None:
            self.stage = m.get('Stage')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class GetEdgeInstanceDeploymentResponseBodyDataTaskList(TeaModel):
    def __init__(
        self,
        gateway_id: str = None,
        gmt_completed: str = None,
        gmt_completed_timestamp: int = None,
        gmt_create: str = None,
        gmt_create_timestamp: int = None,
        gmt_modified: str = None,
        gmt_modified_timestamp: int = None,
        resource_snapshot_list: List[GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList] = None,
        stage: int = None,
        status: int = None,
        task_id: str = None,
    ):
        # The ID of the gateway.
        self.gateway_id = gateway_id
        # The time when the deployment subtask was complete.
        self.gmt_completed = gmt_completed
        # The UNIX timestamp when the deployment subtask was complete.
        self.gmt_completed_timestamp = gmt_completed_timestamp
        # The time when the deployment subtask was created.
        self.gmt_create = gmt_create
        # The UNIX timestamp when the deployment subtask was created.
        self.gmt_create_timestamp = gmt_create_timestamp
        # The last time when the deployment subtask was modified.
        self.gmt_modified = gmt_modified
        # The last UNIX timestamp when the deployment subtask was modified.
        self.gmt_modified_timestamp = gmt_modified_timestamp
        # The list of deployment task snapshots.
        self.resource_snapshot_list = resource_snapshot_list
        # The stage of the deployment subtask.
        # 
        # *   0: The subtask was not started.
        # *   8: The subtask was being assembled.
        # *   16: The subtask was being packaged.
        # *   24: The subtask was being dispatched.
        # *   32: The subtask was complete.
        self.stage = stage
        # The status of the deployment subtask.
        # 
        # *   0: The subtask was in the initial state.
        # *   1: The subtask was being processed.
        # *   2: The subtask was successful.
        # *   3: The subtask failed.
        self.status = status
        # The ID of the deployment subtask.
        self.task_id = task_id

    def validate(self):
        if self.resource_snapshot_list:
            for k in self.resource_snapshot_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gateway_id is not None:
            result['GatewayId'] = self.gateway_id
        if self.gmt_completed is not None:
            result['GmtCompleted'] = self.gmt_completed
        if self.gmt_completed_timestamp is not None:
            result['GmtCompletedTimestamp'] = self.gmt_completed_timestamp
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_create_timestamp is not None:
            result['GmtCreateTimestamp'] = self.gmt_create_timestamp
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.gmt_modified_timestamp is not None:
            result['GmtModifiedTimestamp'] = self.gmt_modified_timestamp
        result['ResourceSnapshotList'] = []
        if self.resource_snapshot_list is not None:
            for k in self.resource_snapshot_list:
                result['ResourceSnapshotList'].append(k.to_map() if k else None)
        if self.stage is not None:
            result['Stage'] = self.stage
        if self.status is not None:
            result['Status'] = self.status
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GatewayId') is not None:
            self.gateway_id = m.get('GatewayId')
        if m.get('GmtCompleted') is not None:
            self.gmt_completed = m.get('GmtCompleted')
        if m.get('GmtCompletedTimestamp') is not None:
            self.gmt_completed_timestamp = m.get('GmtCompletedTimestamp')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtCreateTimestamp') is not None:
            self.gmt_create_timestamp = m.get('GmtCreateTimestamp')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('GmtModifiedTimestamp') is not None:
            self.gmt_modified_timestamp = m.get('GmtModifiedTimestamp')
        self.resource_snapshot_list = []
        if m.get('ResourceSnapshotList') is not None:
            for k in m.get('ResourceSnapshotList'):
                temp_model = GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList()
                self.resource_snapshot_list.append(temp_model.from_map(k))
        if m.get('Stage') is not None:
            self.stage = m.get('Stage')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class GetEdgeInstanceDeploymentResponseBodyData(TeaModel):
    def __init__(
        self,
        deployment_id: str = None,
        description: str = None,
        gmt_completed: str = None,
        gmt_completed_timestamp: int = None,
        gmt_create: str = None,
        gmt_create_timestamp: int = None,
        gmt_modified: str = None,
        gmt_modified_timestamp: int = None,
        status: int = None,
        task_list: List[GetEdgeInstanceDeploymentResponseBodyDataTaskList] = None,
        type: str = None,
    ):
        # The ID of the deployment task.
        self.deployment_id = deployment_id
        # The description of the deployment task.
        self.description = description
        # The time when the deployment task was complete.
        self.gmt_completed = gmt_completed
        # The UNIX timestamp when the deployment task was complete.
        self.gmt_completed_timestamp = gmt_completed_timestamp
        # The time when the deployment task was created.
        self.gmt_create = gmt_create
        # The UNIX timestamp when the deployment task was created.
        self.gmt_create_timestamp = gmt_create_timestamp
        # The last time when the deployment task was modified.
        self.gmt_modified = gmt_modified
        # The last UNIX timestamp when the deployment task was modified.
        self.gmt_modified_timestamp = gmt_modified_timestamp
        # The status of the deployment task.
        # 
        # *   0: The task was not started.
        # *   1: The task was being processed.
        # *   2: The task was successful.
        # *   3: The task failed.
        self.status = status
        # The list of deployment subtasks.
        self.task_list = task_list
        # The type of the deployment task.
        # 
        # *   deploy: deploys the edge instance.
        # *   reset: resets the edge instance.
        self.type = type

    def validate(self):
        if self.task_list:
            for k in self.task_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.deployment_id is not None:
            result['DeploymentId'] = self.deployment_id
        if self.description is not None:
            result['Description'] = self.description
        if self.gmt_completed is not None:
            result['GmtCompleted'] = self.gmt_completed
        if self.gmt_completed_timestamp is not None:
            result['GmtCompletedTimestamp'] = self.gmt_completed_timestamp
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_create_timestamp is not None:
            result['GmtCreateTimestamp'] = self.gmt_create_timestamp
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.gmt_modified_timestamp is not None:
            result['GmtModifiedTimestamp'] = self.gmt_modified_timestamp
        if self.status is not None:
            result['Status'] = self.status
        result['TaskList'] = []
        if self.task_list is not None:
            for k in self.task_list:
                result['TaskList'].append(k.to_map() if k else None)
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeploymentId') is not None:
            self.deployment_id = m.get('DeploymentId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('GmtCompleted') is not None:
            self.gmt_completed = m.get('GmtCompleted')
        if m.get('GmtCompletedTimestamp') is not None:
            self.gmt_completed_timestamp = m.get('GmtCompletedTimestamp')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtCreateTimestamp') is not None:
            self.gmt_create_timestamp = m.get('GmtCreateTimestamp')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('GmtModifiedTimestamp') is not None:
            self.gmt_modified_timestamp = m.get('GmtModifiedTimestamp')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        self.task_list = []
        if m.get('TaskList') is not None:
            for k in m.get('TaskList'):
                temp_model = GetEdgeInstanceDeploymentResponseBodyDataTaskList()
                self.task_list.append(temp_model.from_map(k))
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetEdgeInstanceDeploymentResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetEdgeInstanceDeploymentResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The return code of the operation. A value of Success indicates that the call was successful. Other values indicate that specific errors occurred. For more information, see [Error codes](~~135200~~).
        self.code = code
        # The data that is returned if the call was successful.
        self.data = data
        # The error message that is returned if the call failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful. A value of true indicates that the call was successful. A value of false indicates that the call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetEdgeInstanceDeploymentResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetEdgeInstanceDeploymentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetEdgeInstanceDeploymentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetEdgeInstanceDeploymentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetEdgeInstanceMessageRoutingRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        iot_instance_id: str = None,
        route_id: int = None,
    ):
        self.instance_id = instance_id
        self.iot_instance_id = iot_instance_id
        self.route_id = route_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.route_id is not None:
            result['RouteId'] = self.route_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('RouteId') is not None:
            self.route_id = m.get('RouteId')
        return self


class GetEdgeInstanceMessageRoutingResponseBodyDataRouteContext(TeaModel):
    def __init__(
        self,
        qos: str = None,
        source_application_name: str = None,
        source_fc_function_name: str = None,
        source_fc_service_name: str = None,
        target_application_name: str = None,
        target_fc_function_name: str = None,
        target_fc_service_name: str = None,
    ):
        self.qos = qos
        self.source_application_name = source_application_name
        self.source_fc_function_name = source_fc_function_name
        self.source_fc_service_name = source_fc_service_name
        self.target_application_name = target_application_name
        self.target_fc_function_name = target_fc_function_name
        self.target_fc_service_name = target_fc_service_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.qos is not None:
            result['Qos'] = self.qos
        if self.source_application_name is not None:
            result['SourceApplicationName'] = self.source_application_name
        if self.source_fc_function_name is not None:
            result['SourceFcFunctionName'] = self.source_fc_function_name
        if self.source_fc_service_name is not None:
            result['SourceFcServiceName'] = self.source_fc_service_name
        if self.target_application_name is not None:
            result['TargetApplicationName'] = self.target_application_name
        if self.target_fc_function_name is not None:
            result['TargetFcFunctionName'] = self.target_fc_function_name
        if self.target_fc_service_name is not None:
            result['TargetFcServiceName'] = self.target_fc_service_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Qos') is not None:
            self.qos = m.get('Qos')
        if m.get('SourceApplicationName') is not None:
            self.source_application_name = m.get('SourceApplicationName')
        if m.get('SourceFcFunctionName') is not None:
            self.source_fc_function_name = m.get('SourceFcFunctionName')
        if m.get('SourceFcServiceName') is not None:
            self.source_fc_service_name = m.get('SourceFcServiceName')
        if m.get('TargetApplicationName') is not None:
            self.target_application_name = m.get('TargetApplicationName')
        if m.get('TargetFcFunctionName') is not None:
            self.target_fc_function_name = m.get('TargetFcFunctionName')
        if m.get('TargetFcServiceName') is not None:
            self.target_fc_service_name = m.get('TargetFcServiceName')
        return self


class GetEdgeInstanceMessageRoutingResponseBodyData(TeaModel):
    def __init__(
        self,
        gmt_create: str = None,
        gmt_create_timestamp: int = None,
        gmt_modified: str = None,
        gmt_modified_timestamp: int = None,
        name: str = None,
        route_context: GetEdgeInstanceMessageRoutingResponseBodyDataRouteContext = None,
        source_data: str = None,
        source_type: str = None,
        target_data: str = None,
        target_type: str = None,
        topic_filter: str = None,
    ):
        self.gmt_create = gmt_create
        self.gmt_create_timestamp = gmt_create_timestamp
        self.gmt_modified = gmt_modified
        self.gmt_modified_timestamp = gmt_modified_timestamp
        self.name = name
        self.route_context = route_context
        self.source_data = source_data
        self.source_type = source_type
        self.target_data = target_data
        self.target_type = target_type
        self.topic_filter = topic_filter

    def validate(self):
        if self.route_context:
            self.route_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_create_timestamp is not None:
            result['GmtCreateTimestamp'] = self.gmt_create_timestamp
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.gmt_modified_timestamp is not None:
            result['GmtModifiedTimestamp'] = self.gmt_modified_timestamp
        if self.name is not None:
            result['Name'] = self.name
        if self.route_context is not None:
            result['RouteContext'] = self.route_context.to_map()
        if self.source_data is not None:
            result['SourceData'] = self.source_data
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        if self.target_data is not None:
            result['TargetData'] = self.target_data
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        if self.topic_filter is not None:
            result['TopicFilter'] = self.topic_filter
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtCreateTimestamp') is not None:
            self.gmt_create_timestamp = m.get('GmtCreateTimestamp')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('GmtModifiedTimestamp') is not None:
            self.gmt_modified_timestamp = m.get('GmtModifiedTimestamp')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RouteContext') is not None:
            temp_model = GetEdgeInstanceMessageRoutingResponseBodyDataRouteContext()
            self.route_context = temp_model.from_map(m['RouteContext'])
        if m.get('SourceData') is not None:
            self.source_data = m.get('SourceData')
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        if m.get('TargetData') is not None:
            self.target_data = m.get('TargetData')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        if m.get('TopicFilter') is not None:
            self.topic_filter = m.get('TopicFilter')
        return self


class GetEdgeInstanceMessageRoutingResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetEdgeInstanceMessageRoutingResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetEdgeInstanceMessageRoutingResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetEdgeInstanceMessageRoutingResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetEdgeInstanceMessageRoutingResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetEdgeInstanceMessageRoutingResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetGatewayBySubDeviceRequest(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        iot_id: str = None,
        iot_instance_id: str = None,
        product_key: str = None,
    ):
        # The DeviceName of the sub-device.
        # 
        # >  If you specify this parameter, you must also specify the **ProductKey** parameter.
        self.device_name = device_name
        # The ID of the sub-device. The ID is a unique identifier that is issued by IoT Platform to the sub-device.
        # 
        # >  If you specify this parameter, you do not need to specify **ProductKey** or **DeviceName**. The **IotId** parameter specifies a globally unique identifier (GUID) of the device, which corresponds to a combination of **ProductKey** and **DeviceName**. If you specify both **IotId** and the combination of **ProductKey** and **DeviceName**, **IotId** takes precedence.
        self.iot_id = iot_id
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The ProductKey of the product to which the device belongs.
        # 
        # >  If you specify this parameter, you must also specify the **DeviceName** parameter.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class GetGatewayBySubDeviceResponseBodyData(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        device_secret: str = None,
        firmware_version: str = None,
        gmt_active: str = None,
        gmt_create: str = None,
        gmt_online: str = None,
        ip_address: str = None,
        node_type: str = None,
        product_key: str = None,
        product_name: str = None,
        status: str = None,
        utc_active: str = None,
        utc_create: str = None,
        utc_online: str = None,
        iot_id: str = None,
        region: str = None,
    ):
        # The DeviceName of the gateway.
        self.device_name = device_name
        # The DeviceSecret of the gateway.
        self.device_secret = device_secret
        # The firmware version number of the device.
        self.firmware_version = firmware_version
        # The activation time of the gateway. The time is displayed in GMT. The time is the local time of the region where the gateway resides.
        self.gmt_active = gmt_active
        # The creation time of the gateway. The time is displayed in GMT. The time is the local time of the region where the gateway resides.
        self.gmt_create = gmt_create
        # The last online time of the gateway. The time is displayed in GMT. The time is the local time of the region where the gateway resides.
        self.gmt_online = gmt_online
        # The IP address of the gateway.
        self.ip_address = ip_address
        # The node type. The value 1 indicates that the device is a gateway.
        self.node_type = node_type
        # The **ProductKey** of the product to which the gateway belongs.
        self.product_key = product_key
        # The name of the product to which the gateway belongs.
        self.product_name = product_name
        # The status of the gateway device. Valid values:
        # 
        # *   **online**: The device is online.
        # *   **offline**: The device is offline.
        # *   **unactive**: The device is not activated.
        # *   **disable**: The device is disabled.
        self.status = status
        # The activation time of the gateway. The time is displayed in UTC. The actual time of the region where the gateway resides is calculated based on the time zone of the region.
        self.utc_active = utc_active
        # The creation time of the gateway. The time is displayed in UTC. The actual time of the region where the gateway resides is calculated based on the time zone of the region.
        self.utc_create = utc_create
        # The last online time of the gateway. The time is displayed in UTC. The actual time of the region where the gateway resides is calculated based on the time zone of the region.
        self.utc_online = utc_online
        # The ID of the gateway device. The ID is the unique identifier that is issued by IoT Platform to the device.
        self.iot_id = iot_id
        # The region where the gateway resides. This region corresponds to the region that is displayed in the IoT Platform console.
        self.region = region

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.device_secret is not None:
            result['DeviceSecret'] = self.device_secret
        if self.firmware_version is not None:
            result['FirmwareVersion'] = self.firmware_version
        if self.gmt_active is not None:
            result['GmtActive'] = self.gmt_active
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_online is not None:
            result['GmtOnline'] = self.gmt_online
        if self.ip_address is not None:
            result['IpAddress'] = self.ip_address
        if self.node_type is not None:
            result['NodeType'] = self.node_type
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.product_name is not None:
            result['ProductName'] = self.product_name
        if self.status is not None:
            result['Status'] = self.status
        if self.utc_active is not None:
            result['UtcActive'] = self.utc_active
        if self.utc_create is not None:
            result['UtcCreate'] = self.utc_create
        if self.utc_online is not None:
            result['UtcOnline'] = self.utc_online
        if self.iot_id is not None:
            result['iotId'] = self.iot_id
        if self.region is not None:
            result['region'] = self.region
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('DeviceSecret') is not None:
            self.device_secret = m.get('DeviceSecret')
        if m.get('FirmwareVersion') is not None:
            self.firmware_version = m.get('FirmwareVersion')
        if m.get('GmtActive') is not None:
            self.gmt_active = m.get('GmtActive')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtOnline') is not None:
            self.gmt_online = m.get('GmtOnline')
        if m.get('IpAddress') is not None:
            self.ip_address = m.get('IpAddress')
        if m.get('NodeType') is not None:
            self.node_type = m.get('NodeType')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('ProductName') is not None:
            self.product_name = m.get('ProductName')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UtcActive') is not None:
            self.utc_active = m.get('UtcActive')
        if m.get('UtcCreate') is not None:
            self.utc_create = m.get('UtcCreate')
        if m.get('UtcOnline') is not None:
            self.utc_online = m.get('UtcOnline')
        if m.get('iotId') is not None:
            self.iot_id = m.get('iotId')
        if m.get('region') is not None:
            self.region = m.get('region')
        return self


class GetGatewayBySubDeviceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetGatewayBySubDeviceResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The gateway details returned if the call is successful.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetGatewayBySubDeviceResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetGatewayBySubDeviceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetGatewayBySubDeviceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetGatewayBySubDeviceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetLoraNodesTaskRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        task_id: str = None,
    ):
        # The instance ID.
        # 
        # You can obtain the **ID** of the instance on the **Overview** page in the IoT Platform console. If your instance has an ID, you must specify this parameter. Otherwise, the request fails.
        # 
        # > The ID of a public instance may not be displayed on the Overview page. For more information about how to obtain the instance ID, see [How do I obtain an instance ID?](~~267533~~)
        self.iot_instance_id = iot_instance_id
        # The ID of the task for creating the LoRaWAN devices. You can call the [CreateLoRaNodesTask](~~109299~~) operation and obtain the task ID from the value of the **TaskId** response parameter.
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class GetLoraNodesTaskResponseBodySuccessDevEuis(TeaModel):
    def __init__(
        self,
        success_dev_eui: List[str] = None,
    ):
        self.success_dev_eui = success_dev_eui

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.success_dev_eui is not None:
            result['SuccessDevEui'] = self.success_dev_eui
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SuccessDevEui') is not None:
            self.success_dev_eui = m.get('SuccessDevEui')
        return self


class GetLoraNodesTaskResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        success_count: int = None,
        success_dev_euis: GetLoraNodesTaskResponseBodySuccessDevEuis = None,
        task_id: str = None,
        task_state: str = None,
        total_count: int = None,
    ):
        # The error code returned if the request fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the request fails.
        self.error_message = error_message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success
        # The number of devices that were created.
        self.success_count = success_count
        self.success_dev_euis = success_dev_euis
        # The task ID returned if the request is successful.
        self.task_id = task_id
        # The task status.
        # 
        # *   **RUNNING**: The task is in progress.
        # *   **FINISH**: The task is completed.
        self.task_state = task_state
        # The total number of devices that you want to create.
        self.total_count = total_count

    def validate(self):
        if self.success_dev_euis:
            self.success_dev_euis.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.success_count is not None:
            result['SuccessCount'] = self.success_count
        if self.success_dev_euis is not None:
            result['SuccessDevEuis'] = self.success_dev_euis.to_map()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_state is not None:
            result['TaskState'] = self.task_state
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('SuccessCount') is not None:
            self.success_count = m.get('SuccessCount')
        if m.get('SuccessDevEuis') is not None:
            temp_model = GetLoraNodesTaskResponseBodySuccessDevEuis()
            self.success_dev_euis = temp_model.from_map(m['SuccessDevEuis'])
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskState') is not None:
            self.task_state = m.get('TaskState')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class GetLoraNodesTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetLoraNodesTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetLoraNodesTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetParserRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        parser_id: int = None,
    ):
        self.iot_instance_id = iot_instance_id
        self.parser_id = parser_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.parser_id is not None:
            result['ParserId'] = self.parser_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ParserId') is not None:
            self.parser_id = m.get('ParserId')
        return self


class GetParserResponseBodyData(TeaModel):
    def __init__(
        self,
        data_source_id: int = None,
        description: str = None,
        name: str = None,
        parser_id: int = None,
        script: str = None,
        script_draft: str = None,
        status: str = None,
        utc_created: str = None,
        utc_modified: str = None,
    ):
        self.data_source_id = data_source_id
        self.description = description
        self.name = name
        self.parser_id = parser_id
        self.script = script
        self.script_draft = script_draft
        self.status = status
        self.utc_created = utc_created
        self.utc_modified = utc_modified

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_source_id is not None:
            result['DataSourceId'] = self.data_source_id
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.parser_id is not None:
            result['ParserId'] = self.parser_id
        if self.script is not None:
            result['Script'] = self.script
        if self.script_draft is not None:
            result['ScriptDraft'] = self.script_draft
        if self.status is not None:
            result['Status'] = self.status
        if self.utc_created is not None:
            result['UtcCreated'] = self.utc_created
        if self.utc_modified is not None:
            result['UtcModified'] = self.utc_modified
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataSourceId') is not None:
            self.data_source_id = m.get('DataSourceId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ParserId') is not None:
            self.parser_id = m.get('ParserId')
        if m.get('Script') is not None:
            self.script = m.get('Script')
        if m.get('ScriptDraft') is not None:
            self.script_draft = m.get('ScriptDraft')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UtcCreated') is not None:
            self.utc_created = m.get('UtcCreated')
        if m.get('UtcModified') is not None:
            self.utc_modified = m.get('UtcModified')
        return self


class GetParserResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetParserResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetParserResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetParserResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetParserResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetParserResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetParserDataSourceRequest(TeaModel):
    def __init__(
        self,
        data_source_id: int = None,
        iot_instance_id: str = None,
    ):
        self.data_source_id = data_source_id
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_source_id is not None:
            result['DataSourceId'] = self.data_source_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataSourceId') is not None:
            self.data_source_id = m.get('DataSourceId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class GetParserDataSourceResponseBodyDataSource(TeaModel):
    def __init__(
        self,
        create_user_id: int = None,
        data_source_id: int = None,
        description: str = None,
        name: str = None,
        utc_created: str = None,
    ):
        self.create_user_id = create_user_id
        self.data_source_id = data_source_id
        self.description = description
        self.name = name
        self.utc_created = utc_created

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_user_id is not None:
            result['CreateUserId'] = self.create_user_id
        if self.data_source_id is not None:
            result['DataSourceId'] = self.data_source_id
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.utc_created is not None:
            result['UtcCreated'] = self.utc_created
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateUserId') is not None:
            self.create_user_id = m.get('CreateUserId')
        if m.get('DataSourceId') is not None:
            self.data_source_id = m.get('DataSourceId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('UtcCreated') is not None:
            self.utc_created = m.get('UtcCreated')
        return self


class GetParserDataSourceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data_source: GetParserDataSourceResponseBodyDataSource = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data_source = data_source
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data_source:
            self.data_source.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data_source is not None:
            result['DataSource'] = self.data_source.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('DataSource') is not None:
            temp_model = GetParserDataSourceResponseBodyDataSource()
            self.data_source = temp_model.from_map(m['DataSource'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetParserDataSourceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetParserDataSourceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetParserDataSourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetRuleRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        rule_id: int = None,
    ):
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The ID of the rule that you want to query. You can log on to the IoT Platform console and choose **Rules** > **Data Forwarding** to view the rule ID. You can also call the [ListRule](~~69486~~) operation and view the rule ID in the response.
        self.rule_id = rule_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        return self


class GetRuleResponseBodyRuleInfo(TeaModel):
    def __init__(
        self,
        create_user_id: int = None,
        created: str = None,
        data_type: str = None,
        id: int = None,
        modified: str = None,
        name: str = None,
        product_key: str = None,
        rule_desc: str = None,
        select: str = None,
        short_topic: str = None,
        status: str = None,
        topic: str = None,
        topic_type: int = None,
        utc_created: str = None,
        utc_modified: str = None,
        where: str = None,
    ):
        # The ID of the user who created the rule.
        self.create_user_id = create_user_id
        # The time when the rule was created. The time is displayed in UTC-6.
        self.created = created
        # The data type of the rule. Valid values: **JSON** and **BINARY** .
        self.data_type = data_type
        # The ID of the rule.
        self.id = id
        # The time when the rule was last modified. The time is displayed in UTC-6.
        self.modified = modified
        # The name of the rule.
        self.name = name
        # The ProductKey of the product to which the rule applies.
        self.product_key = product_key
        # The description of this rule.
        self.rule_desc = rule_desc
        # The values of **Select** in the SQL statements of the rule.
        self.select = select
        # The topic to which the rule applies. The topic does not include the ProductKey level. Format: `${deviceName}/topicShortName`. ${deviceName} indicates the name of the device, and topicShortName indicates the custom name of the topic.
        # 
        # >  For information about how to use the `+` or `#` wildcard in a topic, see [Topic wildcards](~~73731~~).
        self.short_topic = short_topic
        # The status of the rule. Valid values:
        # 
        # *   **RUNNING**: Running
        # *   **STOP**: Stopped
        self.status = status
        # The complete topic to which the rule applies. Format: `${productKey}/${deviceName}/topicShortName`.
        # 
        # >  For information about how to use the `+` or `#` wildcard in a topic, see [Topic wildcards](~~73731~~).
        self.topic = topic
        # The type of the topic. This parameter is returned if you set the SQL statement for the rule. Valid values:
        # 
        # *   **0**: a basic communication topic or TSL communication topic.
        # *   **1**: a custom topic.
        # *   **2**: a device status topic.
        # 
        # If no SQL statement is set for the rule, the value **-1** is returned.
        self.topic_type = topic_type
        # The time when the rule was created. The time is displayed in UTC.
        self.utc_created = utc_created
        # The time when the rule was last modified. The time is displayed in UTC.
        self.utc_modified = utc_modified
        # The **Where** query condition in the SQL statements of the rule.
        self.where = where

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_user_id is not None:
            result['CreateUserId'] = self.create_user_id
        if self.created is not None:
            result['Created'] = self.created
        if self.data_type is not None:
            result['DataType'] = self.data_type
        if self.id is not None:
            result['Id'] = self.id
        if self.modified is not None:
            result['Modified'] = self.modified
        if self.name is not None:
            result['Name'] = self.name
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.rule_desc is not None:
            result['RuleDesc'] = self.rule_desc
        if self.select is not None:
            result['Select'] = self.select
        if self.short_topic is not None:
            result['ShortTopic'] = self.short_topic
        if self.status is not None:
            result['Status'] = self.status
        if self.topic is not None:
            result['Topic'] = self.topic
        if self.topic_type is not None:
            result['TopicType'] = self.topic_type
        if self.utc_created is not None:
            result['UtcCreated'] = self.utc_created
        if self.utc_modified is not None:
            result['UtcModified'] = self.utc_modified
        if self.where is not None:
            result['Where'] = self.where
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateUserId') is not None:
            self.create_user_id = m.get('CreateUserId')
        if m.get('Created') is not None:
            self.created = m.get('Created')
        if m.get('DataType') is not None:
            self.data_type = m.get('DataType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Modified') is not None:
            self.modified = m.get('Modified')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('RuleDesc') is not None:
            self.rule_desc = m.get('RuleDesc')
        if m.get('Select') is not None:
            self.select = m.get('Select')
        if m.get('ShortTopic') is not None:
            self.short_topic = m.get('ShortTopic')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Topic') is not None:
            self.topic = m.get('Topic')
        if m.get('TopicType') is not None:
            self.topic_type = m.get('TopicType')
        if m.get('UtcCreated') is not None:
            self.utc_created = m.get('UtcCreated')
        if m.get('UtcModified') is not None:
            self.utc_modified = m.get('UtcModified')
        if m.get('Where') is not None:
            self.where = m.get('Where')
        return self


class GetRuleResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        rule_info: GetRuleResponseBodyRuleInfo = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # The rule information returned if the call is successful. For more information, see RuleInfo.
        self.rule_info = rule_info
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.rule_info:
            self.rule_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.rule_info is not None:
            result['RuleInfo'] = self.rule_info.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RuleInfo') is not None:
            temp_model = GetRuleResponseBodyRuleInfo()
            self.rule_info = temp_model.from_map(m['RuleInfo'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetRuleActionRequest(TeaModel):
    def __init__(
        self,
        action_id: int = None,
        iot_instance_id: str = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.action_id = action_id
        # The rule action ID that you want to query.
        # 
        # You can query the rule action ID by using the following methods:
        # 
        # *   Call the [CreateRuleAction](~~69586~~) operation and view the **ActionId** parameter in the response.
        # *   Call the [ListRuleActions](~~69517~~) operation and view the **Id** parameter in the response.
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_id is not None:
            result['ActionId'] = self.action_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActionId') is not None:
            self.action_id = m.get('ActionId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class GetRuleActionResponseBodyRuleActionInfo(TeaModel):
    def __init__(
        self,
        configuration: str = None,
        error_action_flag: bool = None,
        id: int = None,
        rule_id: int = None,
        type: str = None,
    ):
        # The ID of rule action.
        self.configuration = configuration
        # The type of the rule action. Valid values:
        # 
        # *   **REPUBLISH**: forwards data to another topic.
        # *   **OTS**: stores data to Tablestore.
        # *   **MNS**: sends data to Message Service (MNS).
        # *   **FC**: sends data to Function Compute.
        # *   **RDS**: Save to cloud databases.
        # *   **AMQP**: forwards data to an AMQP consumer group.
        self.error_action_flag = error_action_flag
        # The ID of the rule based on which the rule action is performed.
        self.id = id
        self.rule_id = rule_id
        # The configurations of the rule action.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.configuration is not None:
            result['Configuration'] = self.configuration
        if self.error_action_flag is not None:
            result['ErrorActionFlag'] = self.error_action_flag
        if self.id is not None:
            result['Id'] = self.id
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Configuration') is not None:
            self.configuration = m.get('Configuration')
        if m.get('ErrorActionFlag') is not None:
            self.error_action_flag = m.get('ErrorActionFlag')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetRuleActionResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        rule_action_info: GetRuleActionResponseBodyRuleActionInfo = None,
        success: bool = None,
    ):
        # The error message returned if the call fails.
        self.code = code
        # The ID of the request.
        self.error_message = error_message
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.request_id = request_id
        # Indicates whether the rule action forwarded error operation data that failed to be forwarded to the destination cloud service. A data forwarding failure indicates that forwarding retries also failed.
        # 
        # *   **true**: forwards error operation data.
        # *   **false**: forwards normal data instead of error operation data.
        self.rule_action_info = rule_action_info
        # The rule action information returned if the call was successful. For more information, see the following parameters.
        self.success = success

    def validate(self):
        if self.rule_action_info:
            self.rule_action_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.rule_action_info is not None:
            result['RuleActionInfo'] = self.rule_action_info.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RuleActionInfo') is not None:
            temp_model = GetRuleActionResponseBodyRuleActionInfo()
            self.rule_action_info = temp_model.from_map(m['RuleActionInfo'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetRuleActionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetRuleActionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetRuleActionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetSceneRuleRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        rule_id: str = None,
    ):
        self.iot_instance_id = iot_instance_id
        self.rule_id = rule_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        return self


class GetSceneRuleResponseBodyData(TeaModel):
    def __init__(
        self,
        gmt_create: int = None,
        gmt_modified: int = None,
        rule_content: str = None,
        rule_description: str = None,
        rule_name: str = None,
        rule_status: int = None,
    ):
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.rule_content = rule_content
        self.rule_description = rule_description
        self.rule_name = rule_name
        self.rule_status = rule_status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.rule_content is not None:
            result['RuleContent'] = self.rule_content
        if self.rule_description is not None:
            result['RuleDescription'] = self.rule_description
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.rule_status is not None:
            result['RuleStatus'] = self.rule_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('RuleContent') is not None:
            self.rule_content = m.get('RuleContent')
        if m.get('RuleDescription') is not None:
            self.rule_description = m.get('RuleDescription')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('RuleStatus') is not None:
            self.rule_status = m.get('RuleStatus')
        return self


class GetSceneRuleResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetSceneRuleResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetSceneRuleResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetSceneRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetSceneRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetSceneRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetShareSpeechModelAudioRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        share_task_id: str = None,
        speech_model_code_list: List[str] = None,
    ):
        self.iot_instance_id = iot_instance_id
        self.share_task_id = share_task_id
        self.speech_model_code_list = speech_model_code_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.share_task_id is not None:
            result['ShareTaskId'] = self.share_task_id
        if self.speech_model_code_list is not None:
            result['SpeechModelCodeList'] = self.speech_model_code_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ShareTaskId') is not None:
            self.share_task_id = m.get('ShareTaskId')
        if m.get('SpeechModelCodeList') is not None:
            self.speech_model_code_list = m.get('SpeechModelCodeList')
        return self


class GetShareSpeechModelAudioResponseBodyData(TeaModel):
    def __init__(
        self,
        data: List[str] = None,
    ):
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('data') is not None:
            self.data = m.get('data')
        return self


class GetShareSpeechModelAudioResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetShareSpeechModelAudioResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetShareSpeechModelAudioResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetShareSpeechModelAudioResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetShareSpeechModelAudioResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetShareSpeechModelAudioResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetShareTaskByDeviceOpenRequest(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        iot_id: str = None,
        iot_instance_id: str = None,
        product_key: str = None,
    ):
        self.device_name = device_name
        self.iot_id = iot_id
        self.iot_instance_id = iot_instance_id
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class GetShareTaskByDeviceOpenResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetShareTaskByDeviceOpenResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetShareTaskByDeviceOpenResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetShareTaskByDeviceOpenResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetSoundCodeAudioRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        sound_code_list: List[str] = None,
    ):
        self.iot_instance_id = iot_instance_id
        self.sound_code_list = sound_code_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.sound_code_list is not None:
            result['SoundCodeList'] = self.sound_code_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('SoundCodeList') is not None:
            self.sound_code_list = m.get('SoundCodeList')
        return self


class GetSoundCodeAudioResponseBodyData(TeaModel):
    def __init__(
        self,
        items: List[str] = None,
    ):
        self.items = items

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.items is not None:
            result['Items'] = self.items
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Items') is not None:
            self.items = m.get('Items')
        return self


class GetSoundCodeAudioResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetSoundCodeAudioResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetSoundCodeAudioResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetSoundCodeAudioResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetSoundCodeAudioResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetSoundCodeAudioResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetSoundCodeScheduleRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        schedule_code: str = None,
    ):
        self.iot_instance_id = iot_instance_id
        self.schedule_code = schedule_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.schedule_code is not None:
            result['ScheduleCode'] = self.schedule_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ScheduleCode') is not None:
            self.schedule_code = m.get('ScheduleCode')
        return self


class GetSoundCodeScheduleResponseBodyData(TeaModel):
    def __init__(
        self,
        description: str = None,
        end_date: str = None,
        end_time: str = None,
        gmt_create: int = None,
        name: str = None,
        open_type: str = None,
        schedule_code: str = None,
        start_date: str = None,
        start_time: str = None,
        status: str = None,
    ):
        self.description = description
        self.end_date = end_date
        self.end_time = end_time
        self.gmt_create = gmt_create
        self.name = name
        self.open_type = open_type
        self.schedule_code = schedule_code
        self.start_date = start_date
        self.start_time = start_time
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.end_date is not None:
            result['EndDate'] = self.end_date
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.name is not None:
            result['Name'] = self.name
        if self.open_type is not None:
            result['OpenType'] = self.open_type
        if self.schedule_code is not None:
            result['ScheduleCode'] = self.schedule_code
        if self.start_date is not None:
            result['StartDate'] = self.start_date
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EndDate') is not None:
            self.end_date = m.get('EndDate')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OpenType') is not None:
            self.open_type = m.get('OpenType')
        if m.get('ScheduleCode') is not None:
            self.schedule_code = m.get('ScheduleCode')
        if m.get('StartDate') is not None:
            self.start_date = m.get('StartDate')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class GetSoundCodeScheduleResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetSoundCodeScheduleResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetSoundCodeScheduleResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetSoundCodeScheduleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetSoundCodeScheduleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetSoundCodeScheduleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetSpeechDeviceDetailRequest(TeaModel):
    def __init__(
        self,
        iot_id: str = None,
        iot_instance_id: str = None,
    ):
        self.iot_id = iot_id
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class GetSpeechDeviceDetailResponseBodyData(TeaModel):
    def __init__(
        self,
        available_space: float = None,
        device_name: str = None,
        iot_id: str = None,
        product_key: str = None,
        speech_list_update_time: int = None,
        status: str = None,
        total_space: float = None,
    ):
        self.available_space = available_space
        self.device_name = device_name
        self.iot_id = iot_id
        self.product_key = product_key
        self.speech_list_update_time = speech_list_update_time
        self.status = status
        self.total_space = total_space

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.available_space is not None:
            result['AvailableSpace'] = self.available_space
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.speech_list_update_time is not None:
            result['SpeechListUpdateTime'] = self.speech_list_update_time
        if self.status is not None:
            result['Status'] = self.status
        if self.total_space is not None:
            result['TotalSpace'] = self.total_space
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvailableSpace') is not None:
            self.available_space = m.get('AvailableSpace')
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('SpeechListUpdateTime') is not None:
            self.speech_list_update_time = m.get('SpeechListUpdateTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TotalSpace') is not None:
            self.total_space = m.get('TotalSpace')
        return self


class GetSpeechDeviceDetailResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetSpeechDeviceDetailResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetSpeechDeviceDetailResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetSpeechDeviceDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetSpeechDeviceDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetSpeechDeviceDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetSpeechLicenseDeviceStatisticsRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
    ):
        # The instance ID. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
        # 
        # >  If your instance has an ID, you must specify this parameter. Otherwise, the request fails. If no Overview page exists or no instance ID is displayed, you do not need to specify this parameter.
        # 
        # For more information, see the [Overview](~~356505~~) topic of IoT instances.
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class GetSpeechLicenseDeviceStatisticsResponseBodyData(TeaModel):
    def __init__(
        self,
        available_quota: int = None,
        expired_quota: int = None,
        expiring_quota: int = None,
    ):
        # The number of available licenses.
        self.available_quota = available_quota
        # The number of expired licenses.
        self.expired_quota = expired_quota
        # The number of licenses that are about to expire.
        self.expiring_quota = expiring_quota

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.available_quota is not None:
            result['AvailableQuota'] = self.available_quota
        if self.expired_quota is not None:
            result['ExpiredQuota'] = self.expired_quota
        if self.expiring_quota is not None:
            result['ExpiringQuota'] = self.expiring_quota
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvailableQuota') is not None:
            self.available_quota = m.get('AvailableQuota')
        if m.get('ExpiredQuota') is not None:
            self.expired_quota = m.get('ExpiredQuota')
        if m.get('ExpiringQuota') is not None:
            self.expiring_quota = m.get('ExpiringQuota')
        return self


class GetSpeechLicenseDeviceStatisticsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetSpeechLicenseDeviceStatisticsResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The response parameters.
        self.data = data
        # The error message returned if the request fails.
        self.error_message = error_message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetSpeechLicenseDeviceStatisticsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetSpeechLicenseDeviceStatisticsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetSpeechLicenseDeviceStatisticsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetSpeechLicenseDeviceStatisticsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetSpeechVoiceResponseBodyDataItemsVoiceListItems(TeaModel):
    def __init__(
        self,
        label: str = None,
        value: str = None,
    ):
        self.label = label
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.label is not None:
            result['Label'] = self.label
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class GetSpeechVoiceResponseBodyDataItemsVoiceList(TeaModel):
    def __init__(
        self,
        items: List[GetSpeechVoiceResponseBodyDataItemsVoiceListItems] = None,
    ):
        self.items = items

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Items'] = []
        if self.items is not None:
            for k in self.items:
                result['Items'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('Items') is not None:
            for k in m.get('Items'):
                temp_model = GetSpeechVoiceResponseBodyDataItemsVoiceListItems()
                self.items.append(temp_model.from_map(k))
        return self


class GetSpeechVoiceResponseBodyDataItems(TeaModel):
    def __init__(
        self,
        label: str = None,
        value: str = None,
        voice_list: GetSpeechVoiceResponseBodyDataItemsVoiceList = None,
    ):
        self.label = label
        self.value = value
        self.voice_list = voice_list

    def validate(self):
        if self.voice_list:
            self.voice_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.label is not None:
            result['Label'] = self.label
        if self.value is not None:
            result['Value'] = self.value
        if self.voice_list is not None:
            result['VoiceList'] = self.voice_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        if m.get('VoiceList') is not None:
            temp_model = GetSpeechVoiceResponseBodyDataItemsVoiceList()
            self.voice_list = temp_model.from_map(m['VoiceList'])
        return self


class GetSpeechVoiceResponseBodyData(TeaModel):
    def __init__(
        self,
        items: List[GetSpeechVoiceResponseBodyDataItems] = None,
    ):
        self.items = items

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Items'] = []
        if self.items is not None:
            for k in self.items:
                result['Items'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('Items') is not None:
            for k in m.get('Items'):
                temp_model = GetSpeechVoiceResponseBodyDataItems()
                self.items.append(temp_model.from_map(k))
        return self


class GetSpeechVoiceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetSpeechVoiceResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetSpeechVoiceResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetSpeechVoiceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetSpeechVoiceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetSpeechVoiceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetStudioAppTokenOpenRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        iot_instance_id: str = None,
        project_id: str = None,
    ):
        self.app_id = app_id
        self.iot_instance_id = iot_instance_id
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class GetStudioAppTokenOpenResponseBodyData(TeaModel):
    def __init__(
        self,
        biz_id: str = None,
        biz_type: str = None,
        is_enable: str = None,
        token: str = None,
        type: str = None,
    ):
        self.biz_id = biz_id
        self.biz_type = biz_type
        self.is_enable = is_enable
        self.token = token
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_id is not None:
            result['BizId'] = self.biz_id
        if self.biz_type is not None:
            result['BizType'] = self.biz_type
        if self.is_enable is not None:
            result['IsEnable'] = self.is_enable
        if self.token is not None:
            result['Token'] = self.token
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BizId') is not None:
            self.biz_id = m.get('BizId')
        if m.get('BizType') is not None:
            self.biz_type = m.get('BizType')
        if m.get('IsEnable') is not None:
            self.is_enable = m.get('IsEnable')
        if m.get('Token') is not None:
            self.token = m.get('Token')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetStudioAppTokenOpenResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetStudioAppTokenOpenResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetStudioAppTokenOpenResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetStudioAppTokenOpenResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetStudioAppTokenOpenResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetStudioAppTokenOpenResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetThingModelStatusInnerRequest(TeaModel):
    def __init__(
        self,
        ins_id: str = None,
        iot_instance_id: str = None,
        product_key: str = None,
    ):
        self.ins_id = ins_id
        self.iot_instance_id = iot_instance_id
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ins_id is not None:
            result['InsId'] = self.ins_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InsId') is not None:
            self.ins_id = m.get('InsId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class GetThingModelStatusInnerResponseBodyData(TeaModel):
    def __init__(
        self,
        info: str = None,
        instance_id: str = None,
        modified_time: int = None,
        out_time: int = None,
        product_key: str = None,
        rbac_tenant_id: str = None,
        status: int = None,
    ):
        self.info = info
        self.instance_id = instance_id
        self.modified_time = modified_time
        self.out_time = out_time
        self.product_key = product_key
        self.rbac_tenant_id = rbac_tenant_id
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.info is not None:
            result['Info'] = self.info
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.out_time is not None:
            result['OutTime'] = self.out_time
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.rbac_tenant_id is not None:
            result['RbacTenantId'] = self.rbac_tenant_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Info') is not None:
            self.info = m.get('Info')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('OutTime') is not None:
            self.out_time = m.get('OutTime')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('RbacTenantId') is not None:
            self.rbac_tenant_id = m.get('RbacTenantId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class GetThingModelStatusInnerResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        data: GetThingModelStatusInnerResponseBodyData = None,
        localized_msg: str = None,
        message: str = None,
        request_id: str = None,
    ):
        self.code = code
        self.data = data
        self.localized_msg = localized_msg
        self.message = message
        self.request_id = request_id

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.localized_msg is not None:
            result['LocalizedMsg'] = self.localized_msg
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetThingModelStatusInnerResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('LocalizedMsg') is not None:
            self.localized_msg = m.get('LocalizedMsg')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetThingModelStatusInnerResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetThingModelStatusInnerResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetThingModelStatusInnerResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetThingModelTslRequest(TeaModel):
    def __init__(
        self,
        function_block_id: str = None,
        iot_instance_id: str = None,
        model_version: str = None,
        product_key: str = None,
        simple: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.function_block_id = function_block_id
        # The ProductKey of the product.
        # 
        # You can view the ProductKey on the Product Details page of the IoT Platform console. You can also obtain the ProductKey by calling the [QueryProductList](~~69271~~) operation.
        self.iot_instance_id = iot_instance_id
        # Specifies whether to retrieve a simplified TSL model.
        # 
        # *   **true**: retrieves a simplified TSL model.
        # 
        #     A simplified TSL model includes only the **identifier** and **dataType** attributes of properties, services, events, and related input or output parameters. Simplified TSL models can be used by device developers for reference.
        # 
        # *   **false**: retrieves the complete TSL model.
        # 
        #     A complete TSL model includes all the parameters and values of properties, services, and events. Complete TSL models can be used by cloud application developers for reference.
        # 
        # Default value: false.
        self.model_version = model_version
        # The version number of the TSL model to be queried.
        # 
        # If you do not specify this parameter, IoT Platform returns the draft TSL model that is unpublished.
        self.product_key = product_key
        # The identifier of the custom TSL module. Each identifier is unique in a product.
        # 
        # If you do not specify this parameter, the default module is queried.
        self.simple = simple

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.function_block_id is not None:
            result['FunctionBlockId'] = self.function_block_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.model_version is not None:
            result['ModelVersion'] = self.model_version
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.simple is not None:
            result['Simple'] = self.simple
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FunctionBlockId') is not None:
            self.function_block_id = m.get('FunctionBlockId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ModelVersion') is not None:
            self.model_version = m.get('ModelVersion')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('Simple') is not None:
            self.simple = m.get('Simple')
        return self


class GetThingModelTslResponseBodyData(TeaModel):
    def __init__(
        self,
        tsl_str: str = None,
        tsl_uri: str = None,
    ):
        self.tsl_str = tsl_str
        # The string of the TSL model.
        self.tsl_uri = tsl_uri

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tsl_str is not None:
            result['TslStr'] = self.tsl_str
        if self.tsl_uri is not None:
            result['TslUri'] = self.tsl_uri
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TslStr') is not None:
            self.tsl_str = m.get('TslStr')
        if m.get('TslUri') is not None:
            self.tsl_uri = m.get('TslUri')
        return self


class GetThingModelTslResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetThingModelTslResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error message returned if the call fails.
        self.code = code
        # The URI that is used to store the TSL data in Object Storage Service (OSS). The URI is valid for 60 minutes.
        self.data = data
        # The ID of the request.
        self.error_message = error_message
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.request_id = request_id
        # The TSL data returned if the call is successful.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetThingModelTslResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetThingModelTslResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetThingModelTslResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetThingModelTslResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetThingModelTslPublishedRequest(TeaModel):
    def __init__(
        self,
        function_block_id: str = None,
        iot_instance_id: str = None,
        model_version: str = None,
        product_key: str = None,
        resource_group_id: str = None,
        simple: bool = None,
    ):
        # The identifier of the custom TSL module. Each identifier is unique in a product.
        # 
        # If you do not specify this parameter, the default module is queried.
        self.function_block_id = function_block_id
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The version number of the TSL model.
        # 
        # You can call the [ListThingModelVersion](~~150318~~) operation to view the version numbers of the TSL model for a product.
        # 
        # If you do not specify this parameter, the last published TSL model version is returned.
        self.model_version = model_version
        # The **ProductKey** of the product.
        self.product_key = product_key
        # The ID of the resource group.
        # 
        # >  You cannot specify this parameter.
        self.resource_group_id = resource_group_id
        # Specifies whether to retrieve a simplified TSL model.
        # 
        # *   true: retrieves a simplified TSL model. A simplified TSL model includes only the **identifier** and **dataType** attributes of properties, services, events, and related input or output parameters. Simplified TSL models can be used by device developers for reference.
        # *   false: retrieves the complete TSL model. A complete TSL model includes all the parameters and values of properties, services, and events. Complete TSL models can be used by cloud application developers for reference.
        # 
        # Default value: false.
        self.simple = simple

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.function_block_id is not None:
            result['FunctionBlockId'] = self.function_block_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.model_version is not None:
            result['ModelVersion'] = self.model_version
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.simple is not None:
            result['Simple'] = self.simple
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FunctionBlockId') is not None:
            self.function_block_id = m.get('FunctionBlockId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ModelVersion') is not None:
            self.model_version = m.get('ModelVersion')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('Simple') is not None:
            self.simple = m.get('Simple')
        return self


class GetThingModelTslPublishedResponseBodyData(TeaModel):
    def __init__(
        self,
        tsl_str: str = None,
        tsl_uri: str = None,
    ):
        # The string of the TSL model.
        self.tsl_str = tsl_str
        # The URI that is used to store the TSL data in Object Storage Service (OSS). The URI is valid for 60 minutes.
        self.tsl_uri = tsl_uri

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tsl_str is not None:
            result['TslStr'] = self.tsl_str
        if self.tsl_uri is not None:
            result['TslUri'] = self.tsl_uri
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TslStr') is not None:
            self.tsl_str = m.get('TslStr')
        if m.get('TslUri') is not None:
            self.tsl_uri = m.get('TslUri')
        return self


class GetThingModelTslPublishedResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetThingModelTslPublishedResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The returned data.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetThingModelTslPublishedResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetThingModelTslPublishedResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetThingModelTslPublishedResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetThingModelTslPublishedResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetThingScriptRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        product_key: str = None,
    ):
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The **ProductKey** of the product.
        # 
        # You can view the **ProductKey** on the Product Details page of the IoT Platform console. You can also obtain the ProductKey by calling the [QueryProductList](~~69271~~) operation.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class GetThingScriptResponseBodyData(TeaModel):
    def __init__(
        self,
        script_type: str = None,
        script_url: str = None,
    ):
        # The type of the script. Valid values:
        # 
        # *   JavaScript
        # *   Python\_27: Python 2.7
        # *   PHP\_72: PHP 7.2
        self.script_type = script_type
        # The URL of the script payload.
        self.script_url = script_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.script_type is not None:
            result['ScriptType'] = self.script_type
        if self.script_url is not None:
            result['ScriptUrl'] = self.script_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ScriptType') is not None:
            self.script_type = m.get('ScriptType')
        if m.get('ScriptUrl') is not None:
            self.script_url = m.get('ScriptUrl')
        return self


class GetThingScriptResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetThingScriptResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The data returned if the call is successful.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetThingScriptResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetThingScriptResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetThingScriptResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetThingScriptResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetThingTemplateRequest(TeaModel):
    def __init__(
        self,
        category_key: str = None,
        iot_instance_id: str = None,
        resource_group_id: str = None,
    ):
        # The error message returned if the call fails.
        self.category_key = category_key
        # The identifier of the category that you want to query.
        # 
        # You can call the [ListThingTemplates](~~150316~~) operation and view all category keys in the response.
        self.iot_instance_id = iot_instance_id
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category_key is not None:
            result['CategoryKey'] = self.category_key
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CategoryKey') is not None:
            self.category_key = m.get('CategoryKey')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        return self


class GetThingTemplateResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        thing_model_json: str = None,
    ):
        # The ID of the request.
        self.code = code
        # The TSL features returned if the call is successful. Format:
        # 
        # ```
        # 
        # {
        #   "properties": [], //The list of properties
        #   "services": [], //The list of services
        #   "events": [], //The list of events
        # }
        #                                 
        # ```
        # 
        # For more information, see [TSL formats](~~73727~~).
        self.error_message = error_message
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.request_id = request_id
        self.success = success
        self.thing_model_json = thing_model_json

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.thing_model_json is not None:
            result['ThingModelJSON'] = self.thing_model_json
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('ThingModelJSON') is not None:
            self.thing_model_json = m.get('ThingModelJSON')
        return self


class GetThingTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetThingTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetThingTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetThingTopoRequest(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        iot_id: str = None,
        iot_instance_id: str = None,
        page_no: int = None,
        page_size: int = None,
        product_key: str = None,
    ):
        # The name of the gateway device.
        # 
        # >  If you specify this parameter, you must also specify the **ProductKey** parameter.
        self.device_name = device_name
        # The ID of the gateway device. The ID is the unique identifier that is issued by IoT Platform to the gateway device.
        # 
        # >  If you specify this parameter, you do not need to specify the **ProductKey** or **DeviceName** parameter. The **IotId** parameter specifies a unique identifier for the device, and corresponds to a combination of the **ProductKey** and **DeviceName** parameters. If you specify the **IotId** parameter and a combination of the **ProductKey** and **DeviceName** parameters at the same time, the **IotId** parameter takes precedence.
        self.iot_id = iot_id
        # The ID of the Internet of Things (IoT) service instance. This parameter is not required for public instances. However, this parameter is required for enterprise-edition instances.
        self.iot_instance_id = iot_instance_id
        # The number of the page to return.
        self.page_no = page_no
        # The number of entries to return on each page. Maximum value: 50.
        self.page_size = page_size
        # The ProductKey of the product to which the gateway device belongs.
        # 
        # >  If you specify this parameter, you must also specify the **DeviceName** parameter.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class GetThingTopoResponseBodyDataListDeviceInfo(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        iot_id: str = None,
        product_key: str = None,
    ):
        # The DeviceName of the sub-device.
        self.device_name = device_name
        # The ID of the sub-device. The ID is the unique identifier that is issued by IoT Platform to the sub-device.
        self.iot_id = iot_id
        # The ProductKey of the product to which the sub-device belongs.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class GetThingTopoResponseBodyDataList(TeaModel):
    def __init__(
        self,
        device_info: List[GetThingTopoResponseBodyDataListDeviceInfo] = None,
    ):
        self.device_info = device_info

    def validate(self):
        if self.device_info:
            for k in self.device_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['deviceInfo'] = []
        if self.device_info is not None:
            for k in self.device_info:
                result['deviceInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.device_info = []
        if m.get('deviceInfo') is not None:
            for k in m.get('deviceInfo'):
                temp_model = GetThingTopoResponseBodyDataListDeviceInfo()
                self.device_info.append(temp_model.from_map(k))
        return self


class GetThingTopoResponseBodyData(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        list: GetThingTopoResponseBodyDataList = None,
        page_count: int = None,
        page_size: int = None,
        total: int = None,
    ):
        # The page number of the returned page.
        self.current_page = current_page
        # The details of the sub-device. The details of the sub-device are included in the **deviceInfo** parameter.
        self.list = list
        # The total number of pages returned.
        self.page_count = page_count
        # The number of entries returned on each page.
        self.page_size = page_size
        # The total number of entries returned.
        self.total = total

    def validate(self):
        if self.list:
            self.list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.list is not None:
            result['List'] = self.list.to_map()
        if self.page_count is not None:
            result['PageCount'] = self.page_count
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('List') is not None:
            temp_model = GetThingTopoResponseBodyDataList()
            self.list = temp_model.from_map(m['List'])
        if m.get('PageCount') is not None:
            self.page_count = m.get('PageCount')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class GetThingTopoResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GetThingTopoResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The data returned if the call succeeds. For more information, see the following parameters.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call succeeds.
        # 
        # *   **true**: The call succeeds.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GetThingTopoResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GetThingTopoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetThingTopoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetThingTopoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GisQueryDeviceLocationRequestThingList(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        product_key: str = None,
    ):
        self.device_name = device_name
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class GisQueryDeviceLocationRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        thing_list: List[GisQueryDeviceLocationRequestThingList] = None,
    ):
        self.iot_instance_id = iot_instance_id
        self.thing_list = thing_list

    def validate(self):
        if self.thing_list:
            for k in self.thing_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        result['ThingList'] = []
        if self.thing_list is not None:
            for k in self.thing_list:
                result['ThingList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        self.thing_list = []
        if m.get('ThingList') is not None:
            for k in m.get('ThingList'):
                temp_model = GisQueryDeviceLocationRequestThingList()
                self.thing_list.append(temp_model.from_map(k))
        return self


class GisQueryDeviceLocationResponseBodyData(TeaModel):
    def __init__(
        self,
        adcode: int = None,
        city: str = None,
        coordinate_system: int = None,
        country: str = None,
        device_name: str = None,
        ip: str = None,
        latitude: float = None,
        longitude: float = None,
        product_key: str = None,
        province: str = None,
    ):
        self.adcode = adcode
        self.city = city
        self.coordinate_system = coordinate_system
        self.country = country
        self.device_name = device_name
        self.ip = ip
        self.latitude = latitude
        self.longitude = longitude
        self.product_key = product_key
        self.province = province

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.adcode is not None:
            result['Adcode'] = self.adcode
        if self.city is not None:
            result['City'] = self.city
        if self.coordinate_system is not None:
            result['CoordinateSystem'] = self.coordinate_system
        if self.country is not None:
            result['Country'] = self.country
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.ip is not None:
            result['Ip'] = self.ip
        if self.latitude is not None:
            result['Latitude'] = self.latitude
        if self.longitude is not None:
            result['Longitude'] = self.longitude
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.province is not None:
            result['Province'] = self.province
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Adcode') is not None:
            self.adcode = m.get('Adcode')
        if m.get('City') is not None:
            self.city = m.get('City')
        if m.get('CoordinateSystem') is not None:
            self.coordinate_system = m.get('CoordinateSystem')
        if m.get('Country') is not None:
            self.country = m.get('Country')
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('Ip') is not None:
            self.ip = m.get('Ip')
        if m.get('Latitude') is not None:
            self.latitude = m.get('Latitude')
        if m.get('Longitude') is not None:
            self.longitude = m.get('Longitude')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('Province') is not None:
            self.province = m.get('Province')
        return self


class GisQueryDeviceLocationResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[GisQueryDeviceLocationResponseBodyData] = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = GisQueryDeviceLocationResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GisQueryDeviceLocationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GisQueryDeviceLocationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GisQueryDeviceLocationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GisSearchDeviceTraceRequest(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        end_time: int = None,
        iot_instance_id: str = None,
        map_match: int = None,
        product_key: str = None,
        start_time: int = None,
    ):
        self.device_name = device_name
        self.end_time = end_time
        self.iot_instance_id = iot_instance_id
        self.map_match = map_match
        self.product_key = product_key
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.map_match is not None:
            result['MapMatch'] = self.map_match
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('MapMatch') is not None:
            self.map_match = m.get('MapMatch')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class GisSearchDeviceTraceResponseBodyDataPoints(TeaModel):
    def __init__(
        self,
        locate_time: int = None,
        location: str = None,
    ):
        self.locate_time = locate_time
        self.location = location

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.locate_time is not None:
            result['LocateTime'] = self.locate_time
        if self.location is not None:
            result['Location'] = self.location
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LocateTime') is not None:
            self.locate_time = m.get('LocateTime')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        return self


class GisSearchDeviceTraceResponseBodyData(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        points: List[GisSearchDeviceTraceResponseBodyDataPoints] = None,
        product_key: str = None,
    ):
        self.device_name = device_name
        self.points = points
        self.product_key = product_key

    def validate(self):
        if self.points:
            for k in self.points:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        result['Points'] = []
        if self.points is not None:
            for k in self.points:
                result['Points'].append(k.to_map() if k else None)
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        self.points = []
        if m.get('Points') is not None:
            for k in m.get('Points'):
                temp_model = GisSearchDeviceTraceResponseBodyDataPoints()
                self.points.append(temp_model.from_map(k))
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class GisSearchDeviceTraceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: GisSearchDeviceTraceResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = GisSearchDeviceTraceResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class GisSearchDeviceTraceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GisSearchDeviceTraceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GisSearchDeviceTraceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ImportDTDataRequestItems(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        params: str = None,
    ):
        self.device_name = device_name
        self.params = params

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.params is not None:
            result['Params'] = self.params
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('Params') is not None:
            self.params = m.get('Params')
        return self


class ImportDTDataRequest(TeaModel):
    def __init__(
        self,
        dtinstance_id: str = None,
        iot_instance_id: str = None,
        items: List[ImportDTDataRequestItems] = None,
        product_key: str = None,
    ):
        self.dtinstance_id = dtinstance_id
        self.iot_instance_id = iot_instance_id
        self.items = items
        self.product_key = product_key

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dtinstance_id is not None:
            result['DTInstanceId'] = self.dtinstance_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        result['Items'] = []
        if self.items is not None:
            for k in self.items:
                result['Items'].append(k.to_map() if k else None)
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DTInstanceId') is not None:
            self.dtinstance_id = m.get('DTInstanceId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        self.items = []
        if m.get('Items') is not None:
            for k in m.get('Items'):
                temp_model = ImportDTDataRequestItems()
                self.items.append(temp_model.from_map(k))
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class ImportDTDataResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ImportDTDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ImportDTDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ImportDTDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ImportDeviceRequest(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        device_secret: str = None,
        iot_instance_id: str = None,
        nickname: str = None,
        product_key: str = None,
        sn: str = None,
    ):
        # The DeviceName of the device.
        # 
        # The DeviceName must be 4 to 32 characters in length, and can contain letters, digits, hyphens (-), underscores (\_), at signs (@), periods (.), and colons (:).
        # 
        # The DeviceName must be unique in the product.
        self.device_name = device_name
        # The DeviceSecret of the device.
        # 
        # The DeviceSecret must be 1 to 32 characters in length, and can contain letters, digits, hyphens (-), underscores (\_), at signs (@), periods (.), and colons (:).
        self.device_secret = device_secret
        # The instance ID. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
        # 
        # >  If your instance has an ID, you must specify this parameter. Otherwise, the request fails. If no Overview page exists or no instance ID is displayed, you do not need to specify this parameter.
        # 
        # For more information, see [Overview](~~356505~~) of IoT instances.
        self.iot_instance_id = iot_instance_id
        # The alias of the device.
        # 
        # The alias must be 1 to 64 characters in length, and can contain letters, digits, and underscores (\_).
        # 
        # > If you do not specify this parameter, IoT Platform does not generate an alias for the device.
        self.nickname = nickname
        # The **ProductKey** of the gateway product to which the device belongs.
        self.product_key = product_key
        # The serial number (SN) of the device.
        # 
        # The SN must be 1 to 64 characters in length, and can contain letters, digits, and underscores (\_).
        # 
        # > If you do not specify this parameter, IoT Platform does not generate an SN for the device.
        self.sn = sn

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.device_secret is not None:
            result['DeviceSecret'] = self.device_secret
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.nickname is not None:
            result['Nickname'] = self.nickname
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.sn is not None:
            result['Sn'] = self.sn
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('DeviceSecret') is not None:
            self.device_secret = m.get('DeviceSecret')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('Nickname') is not None:
            self.nickname = m.get('Nickname')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('Sn') is not None:
            self.sn = m.get('Sn')
        return self


class ImportDeviceResponseBodyData(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        device_secret: str = None,
        iot_id: str = None,
        nickname: str = None,
        product_key: str = None,
        sn: str = None,
    ):
        # The DeviceName of the device.
        # 
        # >  Keep the information confidential.
        self.device_name = device_name
        # The DeviceSecret of the device.
        # 
        # >  Keep the information confidential.
        self.device_secret = device_secret
        # The ID of the device. The ID is a unique identifier that is issued by IoT Platform to the device.
        # 
        # >  Keep the information confidential.
        self.iot_id = iot_id
        # The alias of the device.
        # 
        # > If you did not specify an alias for the device, the response parameter is empty.
        self.nickname = nickname
        # The **ProductKey** of the product to which the device belongs.
        self.product_key = product_key
        # The SN of the device.
        # 
        # > If you did not specify an SN for the device, the response parameter is empty.
        self.sn = sn

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.device_secret is not None:
            result['DeviceSecret'] = self.device_secret
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.nickname is not None:
            result['Nickname'] = self.nickname
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.sn is not None:
            result['Sn'] = self.sn
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('DeviceSecret') is not None:
            self.device_secret = m.get('DeviceSecret')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('Nickname') is not None:
            self.nickname = m.get('Nickname')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('Sn') is not None:
            self.sn = m.get('Sn')
        return self


class ImportDeviceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ImportDeviceResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The device information returned if the request is successful.
        self.data = data
        # The error message returned if the request fails.
        self.error_message = error_message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful.
        # 
        # *   **true**\
        # *   **false**\
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ImportDeviceResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ImportDeviceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ImportDeviceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ImportDeviceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ImportThingModelTslRequest(TeaModel):
    def __init__(
        self,
        function_block_id: str = None,
        function_block_name: str = None,
        iot_instance_id: str = None,
        product_key: str = None,
        resource_group_id: str = None,
        tsl_str: str = None,
        tsl_url: str = None,
    ):
        # The identifier of the custom TSL module. Each identifier is unique in a product. The identifier must be 1 to 30 characters in length, and can contain letters, digits, and underscores (\_).
        # 
        # This parameter must be used in combination with the **FunctionBlockName** parameter. If you do not specify this parameter, the system imports the default module.
        self.function_block_id = function_block_id
        # The name of the custom module. The name must be 4 to 30 characters in length, and can contain letters, digits, and underscores (\_).
        # 
        # This parameter must be used in combination with the **FunctionBlockId** parameter. If you do not specify this parameter, the system imports the default module.
        self.function_block_name = function_block_name
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The ProductKey of the product.
        # 
        # You can view the ProductKey on the Product Details page of the IoT Platform console. You can also obtain the ProductKey by calling the [QueryProductList](~~69271~~) operation.
        self.product_key = product_key
        # The ID of the resource group.
        # 
        # >  You cannot specify this parameter.
        self.resource_group_id = resource_group_id
        # The TSL model to be edited. The value is a JSON string. The TSL model defines the properties, services, and events of the product.
        # 
        # The value of the **TslStr** parameter must conform to the standard TSL data format. For more information, see [TSL data format](~~73727~~).
        # 
        # >  To import a TSL model, you must specify the **TslStr** parameter.
        self.tsl_str = tsl_str
        # The URI that is used to store the TSL data in Object Storage Service (OSS).
        # 
        # >  This parameter does not take effect. To import a TSL model, you must specify the **TslStr** parameter.
        self.tsl_url = tsl_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.function_block_id is not None:
            result['FunctionBlockId'] = self.function_block_id
        if self.function_block_name is not None:
            result['FunctionBlockName'] = self.function_block_name
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.tsl_str is not None:
            result['TslStr'] = self.tsl_str
        if self.tsl_url is not None:
            result['TslUrl'] = self.tsl_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FunctionBlockId') is not None:
            self.function_block_id = m.get('FunctionBlockId')
        if m.get('FunctionBlockName') is not None:
            self.function_block_name = m.get('FunctionBlockName')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('TslStr') is not None:
            self.tsl_str = m.get('TslStr')
        if m.get('TslUrl') is not None:
            self.tsl_url = m.get('TslUrl')
        return self


class ImportThingModelTslResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ImportThingModelTslResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ImportThingModelTslResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ImportThingModelTslResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class InvokeDataAPIServiceRequestParam(TeaModel):
    def __init__(
        self,
        list_param_type: str = None,
        list_param_value: List[str] = None,
        param_name: str = None,
        param_type: str = None,
        param_value: str = None,
    ):
        self.list_param_type = list_param_type
        self.list_param_value = list_param_value
        self.param_name = param_name
        self.param_type = param_type
        self.param_value = param_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.list_param_type is not None:
            result['ListParamType'] = self.list_param_type
        if self.list_param_value is not None:
            result['ListParamValue'] = self.list_param_value
        if self.param_name is not None:
            result['ParamName'] = self.param_name
        if self.param_type is not None:
            result['ParamType'] = self.param_type
        if self.param_value is not None:
            result['ParamValue'] = self.param_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ListParamType') is not None:
            self.list_param_type = m.get('ListParamType')
        if m.get('ListParamValue') is not None:
            self.list_param_value = m.get('ListParamValue')
        if m.get('ParamName') is not None:
            self.param_name = m.get('ParamName')
        if m.get('ParamType') is not None:
            self.param_type = m.get('ParamType')
        if m.get('ParamValue') is not None:
            self.param_value = m.get('ParamValue')
        return self


class InvokeDataAPIServiceRequest(TeaModel):
    def __init__(
        self,
        api_srn: str = None,
        iot_instance_id: str = None,
        param: List[InvokeDataAPIServiceRequestParam] = None,
    ):
        self.api_srn = api_srn
        self.iot_instance_id = iot_instance_id
        self.param = param

    def validate(self):
        if self.param:
            for k in self.param:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.api_srn is not None:
            result['ApiSrn'] = self.api_srn
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        result['Param'] = []
        if self.param is not None:
            for k in self.param:
                result['Param'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApiSrn') is not None:
            self.api_srn = m.get('ApiSrn')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        self.param = []
        if m.get('Param') is not None:
            for k in m.get('Param'):
                temp_model = InvokeDataAPIServiceRequestParam()
                self.param.append(temp_model.from_map(k))
        return self


class InvokeDataAPIServiceResponseBodyDataFieldNameList(TeaModel):
    def __init__(
        self,
        field_name_list: List[str] = None,
    ):
        self.field_name_list = field_name_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.field_name_list is not None:
            result['FieldNameList'] = self.field_name_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FieldNameList') is not None:
            self.field_name_list = m.get('FieldNameList')
        return self


class InvokeDataAPIServiceResponseBodyDataResultList(TeaModel):
    def __init__(
        self,
        result_list: List[Dict[str, Any]] = None,
    ):
        self.result_list = result_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.result_list is not None:
            result['ResultList'] = self.result_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ResultList') is not None:
            self.result_list = m.get('ResultList')
        return self


class InvokeDataAPIServiceResponseBodyData(TeaModel):
    def __init__(
        self,
        api_srn: str = None,
        field_name_list: InvokeDataAPIServiceResponseBodyDataFieldNameList = None,
        page_no: int = None,
        page_size: int = None,
        result_list: InvokeDataAPIServiceResponseBodyDataResultList = None,
        total_size: int = None,
    ):
        self.api_srn = api_srn
        self.field_name_list = field_name_list
        self.page_no = page_no
        self.page_size = page_size
        self.result_list = result_list
        self.total_size = total_size

    def validate(self):
        if self.field_name_list:
            self.field_name_list.validate()
        if self.result_list:
            self.result_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.api_srn is not None:
            result['ApiSrn'] = self.api_srn
        if self.field_name_list is not None:
            result['FieldNameList'] = self.field_name_list.to_map()
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.result_list is not None:
            result['ResultList'] = self.result_list.to_map()
        if self.total_size is not None:
            result['TotalSize'] = self.total_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApiSrn') is not None:
            self.api_srn = m.get('ApiSrn')
        if m.get('FieldNameList') is not None:
            temp_model = InvokeDataAPIServiceResponseBodyDataFieldNameList()
            self.field_name_list = temp_model.from_map(m['FieldNameList'])
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ResultList') is not None:
            temp_model = InvokeDataAPIServiceResponseBodyDataResultList()
            self.result_list = temp_model.from_map(m['ResultList'])
        if m.get('TotalSize') is not None:
            self.total_size = m.get('TotalSize')
        return self


class InvokeDataAPIServiceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: InvokeDataAPIServiceResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = InvokeDataAPIServiceResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class InvokeDataAPIServiceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: InvokeDataAPIServiceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = InvokeDataAPIServiceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class InvokeThingServiceRequest(TeaModel):
    def __init__(
        self,
        args: str = None,
        device_name: str = None,
        identifier: str = None,
        iot_id: str = None,
        iot_instance_id: str = None,
        product_key: str = None,
        qos: int = None,
    ):
        # The input parameter of the service. The value is a JSON string. Example: **Args={"param1": 1}**.
        # 
        # If this parameter is left empty, set the value to **Args={}**.
        # 
        # > If the TSL data is of the float or double type, the parameter values that correspond to the TSL data contain at least one decimal place. Examples: 10.0 and 11.1.
        self.args = args
        # The DeviceName of the device to which the required service belongs.
        # 
        # > If you configure this parameter, you must specify a value for the **ProductKey** parameter.
        self.device_name = device_name
        # The identifier of the service.
        # 
        # You can use one of the following methods to view the **identifier** of the service:
        # 
        # *   Log on to the [IoT Platform console](https://iot.console.aliyun.com/). On the **Define Feature** tab of the product to which the device belongs, view the identifier.
        # *   Call the [QueryThingModel](~~150321~~) operation and view the identifier in the TSL information that is returned.
        # 
        # >  If a service named testService belongs to a custom module named testFb, you can set this parameter to ******testFb:testService******. The custom module is not the default module.
        self.identifier = identifier
        # The ID of the device. The ID is a unique identifier that is issued by IoT Platform to the device.
        # 
        # >The IotId parameter specifies a globally unique identifier (GUID) for the device. The value of the **IotId** parameter corresponds to a combination of the values of the **ProductKey** and **DeviceName** parameters. If you specify a value for this parameter, you do not need to configure the **ProductKey** or **DeviceName** parameter. If you specify values for the **IotId**,**ProductKey**, and **DeviceName** parameters, the value of the **IotId** parameter takes precedence.
        self.iot_id = iot_id
        # The ID of the elastic container instance. On the **Overview** page in the IoT Platform console, you can view the ID of the instance.****\
        # 
        # >*   If your instance has an ID, you must specify the ID for the parameter. Otherwise, the call fails.********\
        # >*   If no **Overview** page or **ID** is generated for your instance, you do not need to configure this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The ProductKey of the product to which the device belongs.
        # 
        # >If you configure this parameter, you must specify a value for the **DeviceName** parameter.
        self.product_key = product_key
        self.qos = qos

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.args is not None:
            result['Args'] = self.args
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.identifier is not None:
            result['Identifier'] = self.identifier
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.qos is not None:
            result['Qos'] = self.qos
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Args') is not None:
            self.args = m.get('Args')
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('Identifier') is not None:
            self.identifier = m.get('Identifier')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('Qos') is not None:
            self.qos = m.get('Qos')
        return self


class InvokeThingServiceResponseBodyData(TeaModel):
    def __init__(
        self,
        message_id: str = None,
        result: str = None,
    ):
        # The ID of the message. IoT Platform sends the message to the device to call the service.
        self.message_id = message_id
        # The result of the synchronous call.
        # 
        # If you asynchronously call the service, this parameter is not returned.
        self.result = result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.message_id is not None:
            result['MessageId'] = self.message_id
        if self.result is not None:
            result['Result'] = self.result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MessageId') is not None:
            self.message_id = m.get('MessageId')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        return self


class InvokeThingServiceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: InvokeThingServiceResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The data returned if the call is successful.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful. Valid values:
        # 
        # *   **true**: The call was successful. However, this value does not indicate that the service is implemented. To obtain the implementation result, view the logs of the device.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = InvokeThingServiceResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class InvokeThingServiceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: InvokeThingServiceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = InvokeThingServiceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class InvokeThingsServiceRequest(TeaModel):
    def __init__(
        self,
        args: str = None,
        device_name: List[str] = None,
        identifier: str = None,
        iot_instance_id: str = None,
        product_key: str = None,
        qos: int = None,
    ):
        # The input parameter of the service. The value is a JSON string. Example: **Args={"param1": 1}**.
        # 
        # If this parameter is left empty, set the value to **Args={}**.
        # 
        # >If the TSL data is of the float or double type, the parameter values that correspond to the TSL data contain at least one decimal place. Examples: 10.0 and 11.1.
        self.args = args
        self.device_name = device_name
        # The identifier of the service.
        # 
        # You can use one of the following methods to view the **identifier** of the service.
        # 
        # *   Log on to the IoT Platform console. On the **Define Feature** tab of the product to which the device belongs, you can view the identifier.
        # *   Call the [QueryThingModel](~~150321~~) operation and view the identifier in the TSL information that is returned.
        # 
        # >  If a service named testService belongs to a custom module named testFb, you can set this parameter to ******testFb:testService******. The custom module is not the default module.
        self.identifier = identifier
        # The ID of the instance. You can view the ID of the instance on the **Overview** page in the IoT Platform console.****\
        # 
        # >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.****\
        # >*   If no **Overview** page or **ID** is generated for your instance, you do not need to configure this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The **ProductKey** of the product to which the device belongs.
        self.product_key = product_key
        self.qos = qos

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.args is not None:
            result['Args'] = self.args
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.identifier is not None:
            result['Identifier'] = self.identifier
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.qos is not None:
            result['Qos'] = self.qos
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Args') is not None:
            self.args = m.get('Args')
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('Identifier') is not None:
            self.identifier = m.get('Identifier')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('Qos') is not None:
            self.qos = m.get('Qos')
        return self


class InvokeThingsServiceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful. However, this value does not indicate that the service is implemented. To obtain the implementation result, view the logs of the device.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class InvokeThingsServiceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: InvokeThingsServiceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = InvokeThingsServiceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAnalyticsDataRequestCondition(TeaModel):
    def __init__(
        self,
        between_end: str = None,
        between_start: str = None,
        field_name: str = None,
        operate: str = None,
        value: str = None,
    ):
        self.between_end = between_end
        self.between_start = between_start
        self.field_name = field_name
        self.operate = operate
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.between_end is not None:
            result['BetweenEnd'] = self.between_end
        if self.between_start is not None:
            result['BetweenStart'] = self.between_start
        if self.field_name is not None:
            result['FieldName'] = self.field_name
        if self.operate is not None:
            result['Operate'] = self.operate
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BetweenEnd') is not None:
            self.between_end = m.get('BetweenEnd')
        if m.get('BetweenStart') is not None:
            self.between_start = m.get('BetweenStart')
        if m.get('FieldName') is not None:
            self.field_name = m.get('FieldName')
        if m.get('Operate') is not None:
            self.operate = m.get('Operate')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListAnalyticsDataRequest(TeaModel):
    def __init__(
        self,
        api_path: str = None,
        condition: List[ListAnalyticsDataRequestCondition] = None,
        iot_instance_id: str = None,
        iso_id: str = None,
        page_num: int = None,
        page_size: int = None,
    ):
        self.api_path = api_path
        self.condition = condition
        self.iot_instance_id = iot_instance_id
        self.iso_id = iso_id
        self.page_num = page_num
        self.page_size = page_size

    def validate(self):
        if self.condition:
            for k in self.condition:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.api_path is not None:
            result['ApiPath'] = self.api_path
        result['Condition'] = []
        if self.condition is not None:
            for k in self.condition:
                result['Condition'].append(k.to_map() if k else None)
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.iso_id is not None:
            result['IsoId'] = self.iso_id
        if self.page_num is not None:
            result['PageNum'] = self.page_num
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApiPath') is not None:
            self.api_path = m.get('ApiPath')
        self.condition = []
        if m.get('Condition') is not None:
            for k in m.get('Condition'):
                temp_model = ListAnalyticsDataRequestCondition()
                self.condition.append(temp_model.from_map(k))
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('IsoId') is not None:
            self.iso_id = m.get('IsoId')
        if m.get('PageNum') is not None:
            self.page_num = m.get('PageNum')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class ListAnalyticsDataResponseBodyData(TeaModel):
    def __init__(
        self,
        count: int = None,
        has_next: bool = None,
        page_num: int = None,
        page_size: int = None,
        result_json: str = None,
    ):
        self.count = count
        self.has_next = has_next
        self.page_num = page_num
        self.page_size = page_size
        self.result_json = result_json

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.has_next is not None:
            result['HasNext'] = self.has_next
        if self.page_num is not None:
            result['PageNum'] = self.page_num
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.result_json is not None:
            result['ResultJson'] = self.result_json
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('HasNext') is not None:
            self.has_next = m.get('HasNext')
        if m.get('PageNum') is not None:
            self.page_num = m.get('PageNum')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ResultJson') is not None:
            self.result_json = m.get('ResultJson')
        return self


class ListAnalyticsDataResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListAnalyticsDataResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListAnalyticsDataResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListAnalyticsDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAnalyticsDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAnalyticsDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDataSourceItemRequest(TeaModel):
    def __init__(
        self,
        data_source_id: int = None,
        iot_instance_id: str = None,
        page: int = None,
        page_size: int = None,
        search_name: str = None,
    ):
        # The data source ID.
        # 
        # You can call the [ListParserDataSource](~~432676~~) operation to obtain the IDs of all data sources of the instance.
        self.data_source_id = data_source_id
        # The instance ID. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
        # 
        # >  If your instance has an ID, you must specify this parameter. Otherwise, the request fails. If no Overview page exists or no instance ID is displayed, you do not need to specify this parameter.
        # 
        # For more information, see the [Overview](~~356505~~) topic of IoT instances.
        self.iot_instance_id = iot_instance_id
        self.page = page
        self.page_size = page_size
        self.search_name = search_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_source_id is not None:
            result['DataSourceId'] = self.data_source_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.page is not None:
            result['Page'] = self.page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataSourceId') is not None:
            self.data_source_id = m.get('DataSourceId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        return self


class ListDataSourceItemResponseBodyDataSourceItemsDataSourceItem(TeaModel):
    def __init__(
        self,
        data_source_item_id: int = None,
        device_name: str = None,
        product_key: str = None,
        scope_type: str = None,
        topic: str = None,
    ):
        # The ID of the topic of the data source.
        self.data_source_item_id = data_source_item_id
        self.device_name = device_name
        self.product_key = product_key
        self.scope_type = scope_type
        # The name of the topic of the data source.
        self.topic = topic

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_source_item_id is not None:
            result['DataSourceItemId'] = self.data_source_item_id
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.scope_type is not None:
            result['ScopeType'] = self.scope_type
        if self.topic is not None:
            result['Topic'] = self.topic
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataSourceItemId') is not None:
            self.data_source_item_id = m.get('DataSourceItemId')
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('ScopeType') is not None:
            self.scope_type = m.get('ScopeType')
        if m.get('Topic') is not None:
            self.topic = m.get('Topic')
        return self


class ListDataSourceItemResponseBodyDataSourceItems(TeaModel):
    def __init__(
        self,
        data_source_item: List[ListDataSourceItemResponseBodyDataSourceItemsDataSourceItem] = None,
    ):
        self.data_source_item = data_source_item

    def validate(self):
        if self.data_source_item:
            for k in self.data_source_item:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['dataSourceItem'] = []
        if self.data_source_item is not None:
            for k in self.data_source_item:
                result['dataSourceItem'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data_source_item = []
        if m.get('dataSourceItem') is not None:
            for k in m.get('dataSourceItem'):
                temp_model = ListDataSourceItemResponseBodyDataSourceItemsDataSourceItem()
                self.data_source_item.append(temp_model.from_map(k))
        return self


class ListDataSourceItemResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data_source_items: ListDataSourceItemResponseBodyDataSourceItems = None,
        error_message: str = None,
        page: int = None,
        page_size: int = None,
        request_id: str = None,
        success: bool = None,
        total: int = None,
    ):
        # The error code returned if the request fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The information about the topics that are returned.
        self.data_source_items = data_source_items
        # The error message returned if the request fails.
        self.error_message = error_message
        # The page number.
        self.page = page
        # The number of entries per page.
        self.page_size = page_size
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success
        # The total number of entries returned.
        self.total = total

    def validate(self):
        if self.data_source_items:
            self.data_source_items.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data_source_items is not None:
            result['DataSourceItems'] = self.data_source_items.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.page is not None:
            result['Page'] = self.page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('DataSourceItems') is not None:
            temp_model = ListDataSourceItemResponseBodyDataSourceItems()
            self.data_source_items = temp_model.from_map(m['DataSourceItems'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class ListDataSourceItemResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDataSourceItemResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDataSourceItemResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDestinationRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        page: int = None,
        page_size: int = None,
        search_name: str = None,
        types: List[str] = None,
    ):
        self.iot_instance_id = iot_instance_id
        self.page = page
        self.page_size = page_size
        self.search_name = search_name
        # The actions of forwarding data to data destinations. Data is processed by using a parser script before the data is forwarded. Valid values:
        # 
        # *   **REPUBLISH**: forwards topic data to an IoT Platform communication topic.
        # *   **AMQP**: forwards topic data to an Advanced Message Queuing Protocol (AMQP) consumer group.
        # *   **DATAHUB**: forwards topic data to Alibaba Cloud DataHub for stream data processing.
        # *   **ONS**: forwards topic data to Message Queue for Apache RocketMQ for message distribution.
        # *   **MNS**: forwards topic data to Message Service (MNS) for message transmission.
        # *   **FC**: forwards topic data to Function Compute for event computing.
        # *   **OTS**: forwards topic data to Tablestore for NoSQL data storage.
        self.types = types

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.page is not None:
            result['Page'] = self.page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        if self.types is not None:
            result['Types'] = self.types
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        if m.get('Types') is not None:
            self.types = m.get('Types')
        return self


class ListDestinationResponseBodyDestinationsDestinations(TeaModel):
    def __init__(
        self,
        configuration: str = None,
        description: str = None,
        destination_id: int = None,
        is_failover: bool = None,
        name: str = None,
        status: str = None,
        type: str = None,
        utc_created: str = None,
    ):
        # The configuration data of the data destination.
        self.configuration = configuration
        # The description of the data destination.
        self.description = description
        # The ID of the data destination.
        self.destination_id = destination_id
        # Indicates whether the data destination is configured to receive error operation data. Error operation data is the data that failed to be forwarded for two consecutive times.
        # 
        # *   **true**: The data destination is configured to receive error operation data.
        # *   **false**: The data destination is configured to receive regular data instead of error operation data.
        # 
        # Default value: **false**.
        self.is_failover = is_failover
        # The name of the data destination.
        self.name = name
        self.status = status
        # The action of forwarding data to the data destination.
        self.type = type
        # The time when the data destination was created. The time is displayed in UTC. The time follows the ISO 8601 standard in the `yyyy-MM-dd\"T\"HH:mm:ss.SSS\"Z\"` format.
        self.utc_created = utc_created

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.configuration is not None:
            result['Configuration'] = self.configuration
        if self.description is not None:
            result['Description'] = self.description
        if self.destination_id is not None:
            result['DestinationId'] = self.destination_id
        if self.is_failover is not None:
            result['IsFailover'] = self.is_failover
        if self.name is not None:
            result['Name'] = self.name
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        if self.utc_created is not None:
            result['UtcCreated'] = self.utc_created
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Configuration') is not None:
            self.configuration = m.get('Configuration')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DestinationId') is not None:
            self.destination_id = m.get('DestinationId')
        if m.get('IsFailover') is not None:
            self.is_failover = m.get('IsFailover')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UtcCreated') is not None:
            self.utc_created = m.get('UtcCreated')
        return self


class ListDestinationResponseBodyDestinations(TeaModel):
    def __init__(
        self,
        destinations: List[ListDestinationResponseBodyDestinationsDestinations] = None,
    ):
        self.destinations = destinations

    def validate(self):
        if self.destinations:
            for k in self.destinations:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['destinations'] = []
        if self.destinations is not None:
            for k in self.destinations:
                result['destinations'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.destinations = []
        if m.get('destinations') is not None:
            for k in m.get('destinations'):
                temp_model = ListDestinationResponseBodyDestinationsDestinations()
                self.destinations.append(temp_model.from_map(k))
        return self


class ListDestinationResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        destinations: ListDestinationResponseBodyDestinations = None,
        error_message: str = None,
        page: int = None,
        page_size: int = None,
        request_id: str = None,
        success: bool = None,
        total: int = None,
    ):
        # The error code returned if the request fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The data destinations.
        self.destinations = destinations
        # The error message returned if the request fails.
        self.error_message = error_message
        # The page number.
        self.page = page
        # The number of entries per page.
        self.page_size = page_size
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success
        # The total number of entries returned.
        self.total = total

    def validate(self):
        if self.destinations:
            self.destinations.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.destinations is not None:
            result['Destinations'] = self.destinations.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.page is not None:
            result['Page'] = self.page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Destinations') is not None:
            temp_model = ListDestinationResponseBodyDestinations()
            self.destinations = temp_model.from_map(m['Destinations'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class ListDestinationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDestinationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDestinationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDeviceDistributeJobRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        job_id: str = None,
        next_token: str = None,
        page_size: int = None,
        product_key: str = None,
        status: int = None,
        target_uid: str = None,
    ):
        # The number of the page to return. Default value: 1.
        # 
        # The **NextToken** or **CurrentPage** parameter specifies a condition for displaying the results. You can specify one of the two parameters. If you specify both parameters at the same time, the **NextToken parameter** is used.
        # 
        # For information about the **NextToken** parameter, see the description of the **NextToken** parameter.
        self.current_page = current_page
        # The ID of the distribution task. The ID is globally unique.
        self.job_id = job_id
        # The token that is used to retrieve subsequent pages of the query results. The first time you perform a query operation, you do not need to specify this parameter.
        # 
        # The **NextToken** or **CurrentPage** parameter specifies a condition for displaying the results. You can specify one of the two parameters. If you specify both parameters at the same time, the **NextToken** parameter is used.
        # 
        # 
        # 
        # **Important**\
        # 
        # The offset in the number of results is obtained by using the following formula: **PageSize** × (**CurrentPage** - 1).
        # 
        # If the offset is greater than 10,000, you must use the token that is returned in the previous query as the value of the **NextToken** parameter to obtain the value of the **Data** parameter. Otherwise, the current request is terminated and the value of the **Data** parameter cannot be returned.
        self.next_token = next_token
        # The number of entries to return on each page. Valid values: 1 to 200.
        self.page_size = page_size
        # The **ProductKey** of the product to which the device belongs.
        self.product_key = product_key
        # The status of the device distribution task.
        # 
        # *   **0**: The task is being initialized.
        # *   **1**: The task is running.
        # *   **2**: The task is completed. The status indicates that the distribution task is complete but does not indicate that all products and devices are distributed. To obtain distribution results, call the [QueryDeviceDistributeDetail](~~199533~~) operation.
        # *   **3**: The task is unexpectedly interrupted.
        self.status = status
        # The ID of the Alibaba Cloud account to which the devices are distributed.
        self.target_uid = target_uid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.status is not None:
            result['Status'] = self.status
        if self.target_uid is not None:
            result['TargetUid'] = self.target_uid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TargetUid') is not None:
            self.target_uid = m.get('TargetUid')
        return self


class ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigsTargetInstanceConfigs(TeaModel):
    def __init__(
        self,
        target_instance_id: str = None,
        target_instance_name: str = None,
        target_region: str = None,
    ):
        # The ID of the destination instance.
        self.target_instance_id = target_instance_id
        # The name of the destination instance.
        self.target_instance_name = target_instance_name
        # The region where the destination instance resides.
        self.target_region = target_region

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.target_instance_id is not None:
            result['TargetInstanceId'] = self.target_instance_id
        if self.target_instance_name is not None:
            result['TargetInstanceName'] = self.target_instance_name
        if self.target_region is not None:
            result['TargetRegion'] = self.target_region
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TargetInstanceId') is not None:
            self.target_instance_id = m.get('TargetInstanceId')
        if m.get('TargetInstanceName') is not None:
            self.target_instance_name = m.get('TargetInstanceName')
        if m.get('TargetRegion') is not None:
            self.target_region = m.get('TargetRegion')
        return self


class ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigs(TeaModel):
    def __init__(
        self,
        target_instance_configs: List[ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigsTargetInstanceConfigs] = None,
    ):
        self.target_instance_configs = target_instance_configs

    def validate(self):
        if self.target_instance_configs:
            for k in self.target_instance_configs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['targetInstanceConfigs'] = []
        if self.target_instance_configs is not None:
            for k in self.target_instance_configs:
                result['targetInstanceConfigs'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.target_instance_configs = []
        if m.get('targetInstanceConfigs') is not None:
            for k in m.get('targetInstanceConfigs'):
                temp_model = ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigsTargetInstanceConfigs()
                self.target_instance_configs.append(temp_model.from_map(k))
        return self


class ListDeviceDistributeJobResponseBodyDataJobInfoItems(TeaModel):
    def __init__(
        self,
        gmt_create: int = None,
        job_id: str = None,
        product_key: str = None,
        source_instance_id: str = None,
        source_instance_name: str = None,
        source_region: str = None,
        source_uid: str = None,
        status: int = None,
        strategy: int = None,
        target_instance_configs: ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigs = None,
        target_uid: str = None,
        total: int = None,
    ):
        # The time when the task was created.
        self.gmt_create = gmt_create
        # The ID of the task.
        self.job_id = job_id
        # The **ProductKey** of the product to which the device belongs.
        self.product_key = product_key
        # The ID of the source instance.
        self.source_instance_id = source_instance_id
        # The name of the source instance.
        self.source_instance_name = source_instance_name
        # The region where the source instance resides.
        self.source_region = source_region
        # The ID of the source Alibaba Cloud account.
        self.source_uid = source_uid
        # The status of the task.
        # 
        # *   **0**: The task is being initialized.
        # *   **1**: The task is running.
        # *   **2**: The task is completed. The status indicates that the distribution task is complete but does not indicate that all products and devices are distributed. To obtain distribution results, call the [QueryDeviceDistributeDetail](~~199533~~) operation.
        # *   **3**: The task is unexpectedly interrupted.
        self.status = status
        # The distribution policy.
        # 
        # *   **0**: distributes devices to specified instances in a specified region. This is the default value.
        # *   **1**: configures instance IDs in multiple regions and distributes devices to the nearest regions based on the IP addresses of the devices.
        self.strategy = strategy
        # The IDs of the destination instances.
        # 
        # *   If the value of the **Strategy** parameter is **1**, multiple instance IDs exist.
        # *   If the value of the **Strategy** parameter is **0**, only one instance ID exists.
        self.target_instance_configs = target_instance_configs
        # The ID of the destination Alibaba Cloud account.
        self.target_uid = target_uid
        # The total number of devices in the distribution task.
        self.total = total

    def validate(self):
        if self.target_instance_configs:
            self.target_instance_configs.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.source_instance_id is not None:
            result['SourceInstanceId'] = self.source_instance_id
        if self.source_instance_name is not None:
            result['SourceInstanceName'] = self.source_instance_name
        if self.source_region is not None:
            result['SourceRegion'] = self.source_region
        if self.source_uid is not None:
            result['SourceUid'] = self.source_uid
        if self.status is not None:
            result['Status'] = self.status
        if self.strategy is not None:
            result['Strategy'] = self.strategy
        if self.target_instance_configs is not None:
            result['TargetInstanceConfigs'] = self.target_instance_configs.to_map()
        if self.target_uid is not None:
            result['TargetUid'] = self.target_uid
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('SourceInstanceId') is not None:
            self.source_instance_id = m.get('SourceInstanceId')
        if m.get('SourceInstanceName') is not None:
            self.source_instance_name = m.get('SourceInstanceName')
        if m.get('SourceRegion') is not None:
            self.source_region = m.get('SourceRegion')
        if m.get('SourceUid') is not None:
            self.source_uid = m.get('SourceUid')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Strategy') is not None:
            self.strategy = m.get('Strategy')
        if m.get('TargetInstanceConfigs') is not None:
            temp_model = ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigs()
            self.target_instance_configs = temp_model.from_map(m['TargetInstanceConfigs'])
        if m.get('TargetUid') is not None:
            self.target_uid = m.get('TargetUid')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class ListDeviceDistributeJobResponseBodyDataJobInfo(TeaModel):
    def __init__(
        self,
        items: List[ListDeviceDistributeJobResponseBodyDataJobInfoItems] = None,
    ):
        self.items = items

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = ListDeviceDistributeJobResponseBodyDataJobInfoItems()
                self.items.append(temp_model.from_map(k))
        return self


class ListDeviceDistributeJobResponseBodyData(TeaModel):
    def __init__(
        self,
        job_info: ListDeviceDistributeJobResponseBodyDataJobInfo = None,
        next_token: str = None,
        total: int = None,
    ):
        # The information about the task.
        self.job_info = job_info
        # The token that is used to retrieve the subsequent pages of the query results. The value of this parameter can be used in the next query to obtain the subsequent pages of results. 
        # 
        # If the return value is empty, no subsequent page exists.
        self.next_token = next_token
        # The total number of device distribution tasks.
        self.total = total

    def validate(self):
        if self.job_info:
            self.job_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_info is not None:
            result['JobInfo'] = self.job_info.to_map()
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobInfo') is not None:
            temp_model = ListDeviceDistributeJobResponseBodyDataJobInfo()
            self.job_info = temp_model.from_map(m['JobInfo'])
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class ListDeviceDistributeJobResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListDeviceDistributeJobResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code that is returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The distribution tasks that are returned if the call is successful. For more information, see the **JobInfo** parameter.
        self.data = data
        # The error message that is returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful. Valid values:
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListDeviceDistributeJobResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListDeviceDistributeJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDeviceDistributeJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDeviceDistributeJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDistributedDeviceRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        device_name: str = None,
        page_size: int = None,
        product_key: str = None,
        source_instance_id: str = None,
        target_uid: str = None,
    ):
        # The number of the page to return. Default value: 1.
        self.current_page = current_page
        # The DeviceName of the device.
        self.device_name = device_name
        # The number of entries to return on each page. Maximum value: 200.
        self.page_size = page_size
        # The **ProductKey** of the product to which the device belongs.
        self.product_key = product_key
        # The ID of the source instance to which the device belongs.
        # 
        # *   The IDs of public instances in different regions:
        # 
        #     *   China (Shanghai): iotx-oxssharez200.
        #     *   Japan (Tokyo): iotx-oxssharez300.
        #     *   Singapore (Singapore): iotx-oxssharez400.
        #     *   US (Silicon Valley): iotx-oxssharez500.
        #     *   US (Virginia): iotx-oxssharez600.
        #     *   Germany (Frankfurt): iotx-oxssharez700.
        # 
        # *   The IDs of Enterprise Edition instances:
        # 
        #     1\. Log on to the IoT Platform console. Select a region from the drop-down list in the upper-left corner of the top navigation bar.
        # 
        #     2\. On the **Overview** page, click the instance name. On the **Instance Details** page, view the instance ID in the **Basic Information** section.
        self.source_instance_id = source_instance_id
        # The ID of the Alibaba Cloud account. You can log on to the IoT Platform console, click the profile picture, and then view **Account ID** on the **Security Settings** page.
        self.target_uid = target_uid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.source_instance_id is not None:
            result['SourceInstanceId'] = self.source_instance_id
        if self.target_uid is not None:
            result['TargetUid'] = self.target_uid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('SourceInstanceId') is not None:
            self.source_instance_id = m.get('SourceInstanceId')
        if m.get('TargetUid') is not None:
            self.target_uid = m.get('TargetUid')
        return self


class ListDistributedDeviceResponseBodyDataInfoItems(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        product_key: str = None,
        source_instance_id: str = None,
        source_instance_name: str = None,
        source_region: str = None,
        source_uid: str = None,
        target_aliyun_id: str = None,
        target_instance_id: str = None,
        target_instance_name: str = None,
        target_region: str = None,
        target_uid: str = None,
    ):
        # The DeviceName of the device.
        self.device_name = device_name
        # The time when the distribution task was created.
        self.gmt_create = gmt_create
        # The time when the distribution task was modified.
        self.gmt_modified = gmt_modified
        # The **ProductKey** of the product to which the device belongs.
        self.product_key = product_key
        # The ID of the source instance.
        self.source_instance_id = source_instance_id
        # The name of the source instance.
        self.source_instance_name = source_instance_name
        # The source region in which the device resides.
        self.source_region = source_region
        # The ID of the Alibaba Cloud account that distributes the device.
        # 
        # You can only distribute devices across regions and instances by using the same Alibaba cloud account. The value of this parameter is the same as the value of the **TargetUid** parameter.
        self.source_uid = source_uid
        # The Alibaba Cloud account to which the device is distributed.
        self.target_aliyun_id = target_aliyun_id
        # The ID of the destination instance.
        self.target_instance_id = target_instance_id
        # The name of the destination instance.
        self.target_instance_name = target_instance_name
        # The destination region to which the device is distributed.
        self.target_region = target_region
        # The Alibaba Cloud account to which the device is distributed.
        # 
        # You can only distribute devices across regions and instances by using the same Alibaba cloud account. The value of this parameter is the same as the value of the **TargetUid** parameter.
        self.target_uid = target_uid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.source_instance_id is not None:
            result['SourceInstanceId'] = self.source_instance_id
        if self.source_instance_name is not None:
            result['SourceInstanceName'] = self.source_instance_name
        if self.source_region is not None:
            result['SourceRegion'] = self.source_region
        if self.source_uid is not None:
            result['SourceUid'] = self.source_uid
        if self.target_aliyun_id is not None:
            result['TargetAliyunId'] = self.target_aliyun_id
        if self.target_instance_id is not None:
            result['TargetInstanceId'] = self.target_instance_id
        if self.target_instance_name is not None:
            result['TargetInstanceName'] = self.target_instance_name
        if self.target_region is not None:
            result['TargetRegion'] = self.target_region
        if self.target_uid is not None:
            result['TargetUid'] = self.target_uid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('SourceInstanceId') is not None:
            self.source_instance_id = m.get('SourceInstanceId')
        if m.get('SourceInstanceName') is not None:
            self.source_instance_name = m.get('SourceInstanceName')
        if m.get('SourceRegion') is not None:
            self.source_region = m.get('SourceRegion')
        if m.get('SourceUid') is not None:
            self.source_uid = m.get('SourceUid')
        if m.get('TargetAliyunId') is not None:
            self.target_aliyun_id = m.get('TargetAliyunId')
        if m.get('TargetInstanceId') is not None:
            self.target_instance_id = m.get('TargetInstanceId')
        if m.get('TargetInstanceName') is not None:
            self.target_instance_name = m.get('TargetInstanceName')
        if m.get('TargetRegion') is not None:
            self.target_region = m.get('TargetRegion')
        if m.get('TargetUid') is not None:
            self.target_uid = m.get('TargetUid')
        return self


class ListDistributedDeviceResponseBodyDataInfo(TeaModel):
    def __init__(
        self,
        items: List[ListDistributedDeviceResponseBodyDataInfoItems] = None,
    ):
        self.items = items

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = ListDistributedDeviceResponseBodyDataInfoItems()
                self.items.append(temp_model.from_map(k))
        return self


class ListDistributedDeviceResponseBodyData(TeaModel):
    def __init__(
        self,
        info: ListDistributedDeviceResponseBodyDataInfo = None,
        total: int = None,
    ):
        # The information about the device.
        self.info = info
        # The total number of returned devices.
        self.total = total

    def validate(self):
        if self.info:
            self.info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.info is not None:
            result['Info'] = self.info.to_map()
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Info') is not None:
            temp_model = ListDistributedDeviceResponseBodyDataInfo()
            self.info = temp_model.from_map(m['Info'])
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class ListDistributedDeviceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListDistributedDeviceResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The products returned if the call is successful. For more information, see **Info**.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListDistributedDeviceResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListDistributedDeviceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDistributedDeviceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDistributedDeviceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDistributedProductRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        page_size: int = None,
        product_key: str = None,
        source_instance_id: str = None,
        target_instance_id: str = None,
        target_uid: str = None,
    ):
        # The number of the page to return. Default value: 1.
        self.current_page = current_page
        # The number of entries to return on each page. Maximum value: 200.
        self.page_size = page_size
        # The **ProductKey** of the product.
        self.product_key = product_key
        # The ID of the source instance to which the product belongs.
        # 
        # *   The IDs of public instances in different regions:
        # 
        #     *   China (Shanghai): iotx-oxssharez200.
        #     *   Japan (Tokyo): iotx-oxssharez300.
        #     *   Singapore (Singapore): iotx-oxssharez400.
        #     *   US (Silicon Valley): iotx-oxssharez500.
        #     *   US (Virginia): iotx-oxssharez600.
        #     *   Germany (Frankfurt): iotx-oxssharez700.
        # 
        # *   To view the ID of an Enterprise Edition instance, perform the following steps:
        # 
        #     1\. Log on to the [IoT Platform console](https://iot.console.aliyun.com/). In the top navigation bar, select the region where the instance resides from the drop-down list.
        # 
        #     2\. On the **Overview** page, view the **ID** of the instance.
        self.source_instance_id = source_instance_id
        # The ID of the destination instance to which the product is distributed. For more information about instance IDs, see the description of the **SourceInstanceId** parameter.
        self.target_instance_id = target_instance_id
        # The ID of the Alibaba Cloud account to which the product belongs. You can log on to the IoT Platform console, click the profile picture, and then view the **account ID** on the **Security Settings** page.
        self.target_uid = target_uid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.source_instance_id is not None:
            result['SourceInstanceId'] = self.source_instance_id
        if self.target_instance_id is not None:
            result['TargetInstanceId'] = self.target_instance_id
        if self.target_uid is not None:
            result['TargetUid'] = self.target_uid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('SourceInstanceId') is not None:
            self.source_instance_id = m.get('SourceInstanceId')
        if m.get('TargetInstanceId') is not None:
            self.target_instance_id = m.get('TargetInstanceId')
        if m.get('TargetUid') is not None:
            self.target_uid = m.get('TargetUid')
        return self


class ListDistributedProductResponseBodyDataInfoItems(TeaModel):
    def __init__(
        self,
        gmt_create: int = None,
        product_key: str = None,
        source_instance_id: str = None,
        source_instance_name: str = None,
        source_region: str = None,
        source_uid: str = None,
        target_aliyun_id: str = None,
        target_instance_id: str = None,
        target_instance_name: str = None,
        target_region: str = None,
        target_uid: str = None,
    ):
        # The time when the distribution task was created.
        self.gmt_create = gmt_create
        # The **ProductKey** of the product.
        self.product_key = product_key
        # The ID of the source instance to which the product belongs.
        self.source_instance_id = source_instance_id
        # The name of the source instance to which the product belongs.
        self.source_instance_name = source_instance_name
        # The source region to which the product belongs.
        self.source_region = source_region
        # The ID of the Alibaba Cloud account that is used to distribute the product. You can distribute products across regions and instances only within the same Alibaba cloud account. The value of this parameter is the same as the value of the **TargetUid** parameter.
        self.source_uid = source_uid
        # The name of the Alibaba Cloud account to which the product is distributed.
        self.target_aliyun_id = target_aliyun_id
        # The ID of the destination instance to which the product is distributed.
        self.target_instance_id = target_instance_id
        # The name of the destination instance to which the product is distributed.
        self.target_instance_name = target_instance_name
        # The destination region to which the product is distributed.
        self.target_region = target_region
        # The ID of the Alibaba Cloud account to which the product is distributed.
        # 
        # You can distribute devices across regions and instances only within the same Alibaba cloud account. The value of this parameter is the same as the value of the **TargetUid** parameter.
        self.target_uid = target_uid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.source_instance_id is not None:
            result['SourceInstanceId'] = self.source_instance_id
        if self.source_instance_name is not None:
            result['SourceInstanceName'] = self.source_instance_name
        if self.source_region is not None:
            result['SourceRegion'] = self.source_region
        if self.source_uid is not None:
            result['SourceUid'] = self.source_uid
        if self.target_aliyun_id is not None:
            result['TargetAliyunId'] = self.target_aliyun_id
        if self.target_instance_id is not None:
            result['TargetInstanceId'] = self.target_instance_id
        if self.target_instance_name is not None:
            result['TargetInstanceName'] = self.target_instance_name
        if self.target_region is not None:
            result['TargetRegion'] = self.target_region
        if self.target_uid is not None:
            result['TargetUid'] = self.target_uid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('SourceInstanceId') is not None:
            self.source_instance_id = m.get('SourceInstanceId')
        if m.get('SourceInstanceName') is not None:
            self.source_instance_name = m.get('SourceInstanceName')
        if m.get('SourceRegion') is not None:
            self.source_region = m.get('SourceRegion')
        if m.get('SourceUid') is not None:
            self.source_uid = m.get('SourceUid')
        if m.get('TargetAliyunId') is not None:
            self.target_aliyun_id = m.get('TargetAliyunId')
        if m.get('TargetInstanceId') is not None:
            self.target_instance_id = m.get('TargetInstanceId')
        if m.get('TargetInstanceName') is not None:
            self.target_instance_name = m.get('TargetInstanceName')
        if m.get('TargetRegion') is not None:
            self.target_region = m.get('TargetRegion')
        if m.get('TargetUid') is not None:
            self.target_uid = m.get('TargetUid')
        return self


class ListDistributedProductResponseBodyDataInfo(TeaModel):
    def __init__(
        self,
        items: List[ListDistributedProductResponseBodyDataInfoItems] = None,
    ):
        self.items = items

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = ListDistributedProductResponseBodyDataInfoItems()
                self.items.append(temp_model.from_map(k))
        return self


class ListDistributedProductResponseBodyData(TeaModel):
    def __init__(
        self,
        info: ListDistributedProductResponseBodyDataInfo = None,
        total: int = None,
    ):
        # The information about the product.
        self.info = info
        # The total number of returned products.
        self.total = total

    def validate(self):
        if self.info:
            self.info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.info is not None:
            result['Info'] = self.info.to_map()
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Info') is not None:
            temp_model = ListDistributedProductResponseBodyDataInfo()
            self.info = temp_model.from_map(m['Info'])
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class ListDistributedProductResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListDistributedProductResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The products returned if the call is successful. For more information, see the "**Info**" section of this topic.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful. Valid values:
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListDistributedProductResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListDistributedProductResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListDistributedProductResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDistributedProductResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListJobRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        iot_instance_id: str = None,
        page_size: int = None,
        status: str = None,
    ):
        self.current_page = current_page
        self.iot_instance_id = iot_instance_id
        self.page_size = page_size
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListJobResponseBodyDataData(TeaModel):
    def __init__(
        self,
        description: str = None,
        job_id: str = None,
        job_name: str = None,
        scheduled_time: int = None,
        status: str = None,
        type: str = None,
        utc_create: str = None,
        utc_modified: str = None,
    ):
        self.description = description
        self.job_id = job_id
        self.job_name = job_name
        self.scheduled_time = scheduled_time
        self.status = status
        self.type = type
        self.utc_create = utc_create
        self.utc_modified = utc_modified

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.job_name is not None:
            result['JobName'] = self.job_name
        if self.scheduled_time is not None:
            result['ScheduledTime'] = self.scheduled_time
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        if self.utc_create is not None:
            result['UtcCreate'] = self.utc_create
        if self.utc_modified is not None:
            result['UtcModified'] = self.utc_modified
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('JobName') is not None:
            self.job_name = m.get('JobName')
        if m.get('ScheduledTime') is not None:
            self.scheduled_time = m.get('ScheduledTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UtcCreate') is not None:
            self.utc_create = m.get('UtcCreate')
        if m.get('UtcModified') is not None:
            self.utc_modified = m.get('UtcModified')
        return self


class ListJobResponseBodyData(TeaModel):
    def __init__(
        self,
        data: List[ListJobResponseBodyDataData] = None,
    ):
        self.data = data

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = ListJobResponseBodyDataData()
                self.data.append(temp_model.from_map(k))
        return self


class ListJobResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListJobResponseBodyData = None,
        error_message: str = None,
        page: int = None,
        page_size: int = None,
        request_id: str = None,
        success: bool = None,
        total: int = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.page = page
        self.page_size = page_size
        self.request_id = request_id
        self.success = success
        self.total = total

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.page is not None:
            result['Page'] = self.page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListJobResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class ListJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListOTAFirmwareRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        dest_version: str = None,
        iot_instance_id: str = None,
        page_size: int = None,
        product_key: str = None,
    ):
        # The number of the page to return. Pages start from page 1.
        self.current_page = current_page
        # The version number of the OTA update package. If you specify this parameter, only the OTA update package of the specified version number is returned.
        self.dest_version = dest_version
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The number of entries to return on each page. Maximum value: 100.
        self.page_size = page_size
        # The **ProductKey** of the product to which the OTA update package belongs.
        # 
        # If you specify this parameter, IoT Platform returns the OTA update packages of the specified product. If you do not specify this parameter, IoT Platform returns the OTA update packages of the current Alibaba Cloud account.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.dest_version is not None:
            result['DestVersion'] = self.dest_version
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('DestVersion') is not None:
            self.dest_version = m.get('DestVersion')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo(TeaModel):
    def __init__(
        self,
        dest_version: str = None,
        firmware_desc: str = None,
        firmware_id: str = None,
        firmware_name: str = None,
        firmware_sign: str = None,
        firmware_size: int = None,
        module_name: str = None,
        product_key: str = None,
        product_name: str = None,
        sign_method: str = None,
        src_version: str = None,
        status: int = None,
        type: int = None,
        utc_create: str = None,
        utc_modified: str = None,
    ):
        # The version number of the OTA update package.
        self.dest_version = dest_version
        # The description of the OTA update package.
        self.firmware_desc = firmware_desc
        # The unique ID of the OTA update package.
        self.firmware_id = firmware_id
        # The name of the OTA update package.
        self.firmware_name = firmware_name
        # The signature of the OTA update package.
        self.firmware_sign = firmware_sign
        # The size of the update package. Unit: bytes.
        self.firmware_size = firmware_size
        # The name of the module.
        self.module_name = module_name
        # The ProductKey of the product to which the OTA update package belongs.
        self.product_key = product_key
        # The name of the product to which the OTA update package belongs.
        self.product_name = product_name
        # The signature method of the OTA update package.
        self.sign_method = sign_method
        # The version number of the original update package to be updated.
        # 
        # >  The return value is null if you perform a full update.
        self.src_version = src_version
        # The status of the OTA update package. Valid values:
        # 
        # *   **0**: unverified
        # *   **1**: verified
        # *   **2**: verifying
        # *   **3**: failed to be verified
        self.status = status
        # The type of the OTA update package. Valid values:
        # 
        # *   **0**: complete firmware
        # *   **1**: differential firmware
        self.type = type
        # The time when the update package was created. The time is displayed in UTC.
        self.utc_create = utc_create
        # The time when the update task was last modified. The time is displayed in UTC.
        self.utc_modified = utc_modified

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dest_version is not None:
            result['DestVersion'] = self.dest_version
        if self.firmware_desc is not None:
            result['FirmwareDesc'] = self.firmware_desc
        if self.firmware_id is not None:
            result['FirmwareId'] = self.firmware_id
        if self.firmware_name is not None:
            result['FirmwareName'] = self.firmware_name
        if self.firmware_sign is not None:
            result['FirmwareSign'] = self.firmware_sign
        if self.firmware_size is not None:
            result['FirmwareSize'] = self.firmware_size
        if self.module_name is not None:
            result['ModuleName'] = self.module_name
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.product_name is not None:
            result['ProductName'] = self.product_name
        if self.sign_method is not None:
            result['SignMethod'] = self.sign_method
        if self.src_version is not None:
            result['SrcVersion'] = self.src_version
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        if self.utc_create is not None:
            result['UtcCreate'] = self.utc_create
        if self.utc_modified is not None:
            result['UtcModified'] = self.utc_modified
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DestVersion') is not None:
            self.dest_version = m.get('DestVersion')
        if m.get('FirmwareDesc') is not None:
            self.firmware_desc = m.get('FirmwareDesc')
        if m.get('FirmwareId') is not None:
            self.firmware_id = m.get('FirmwareId')
        if m.get('FirmwareName') is not None:
            self.firmware_name = m.get('FirmwareName')
        if m.get('FirmwareSign') is not None:
            self.firmware_sign = m.get('FirmwareSign')
        if m.get('FirmwareSize') is not None:
            self.firmware_size = m.get('FirmwareSize')
        if m.get('ModuleName') is not None:
            self.module_name = m.get('ModuleName')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('ProductName') is not None:
            self.product_name = m.get('ProductName')
        if m.get('SignMethod') is not None:
            self.sign_method = m.get('SignMethod')
        if m.get('SrcVersion') is not None:
            self.src_version = m.get('SrcVersion')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UtcCreate') is not None:
            self.utc_create = m.get('UtcCreate')
        if m.get('UtcModified') is not None:
            self.utc_modified = m.get('UtcModified')
        return self


class ListOTAFirmwareResponseBodyFirmwareInfo(TeaModel):
    def __init__(
        self,
        simple_firmware_info: List[ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo] = None,
    ):
        self.simple_firmware_info = simple_firmware_info

    def validate(self):
        if self.simple_firmware_info:
            for k in self.simple_firmware_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SimpleFirmwareInfo'] = []
        if self.simple_firmware_info is not None:
            for k in self.simple_firmware_info:
                result['SimpleFirmwareInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.simple_firmware_info = []
        if m.get('SimpleFirmwareInfo') is not None:
            for k in m.get('SimpleFirmwareInfo'):
                temp_model = ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo()
                self.simple_firmware_info.append(temp_model.from_map(k))
        return self


class ListOTAFirmwareResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        current_page: int = None,
        error_message: str = None,
        firmware_info: ListOTAFirmwareResponseBodyFirmwareInfo = None,
        page_count: int = None,
        page_size: int = None,
        request_id: str = None,
        success: bool = None,
        total: int = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The number of the returned page.
        self.current_page = current_page
        # The error message returned if the call fails.
        self.error_message = error_message
        # The OTA update packages returned if the call is successful. For more information, see SimpleFirmwareInfo.
        self.firmware_info = firmware_info
        # The total number of pages.
        self.page_count = page_count
        # The number of entries returned per page.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success
        # The total number of OTA update packages.
        self.total = total

    def validate(self):
        if self.firmware_info:
            self.firmware_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.firmware_info is not None:
            result['FirmwareInfo'] = self.firmware_info.to_map()
        if self.page_count is not None:
            result['PageCount'] = self.page_count
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('FirmwareInfo') is not None:
            temp_model = ListOTAFirmwareResponseBodyFirmwareInfo()
            self.firmware_info = temp_model.from_map(m['FirmwareInfo'])
        if m.get('PageCount') is not None:
            self.page_count = m.get('PageCount')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class ListOTAFirmwareResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListOTAFirmwareResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListOTAFirmwareResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListOTAJobByDeviceRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        device_name: str = None,
        firmware_id: str = None,
        iot_instance_id: str = None,
        page_size: int = None,
        product_key: str = None,
    ):
        # The number of the page to return. Pages start from page 1.
        self.current_page = current_page
        # The DeviceName of the device.
        self.device_name = device_name
        # The ID of the update package. The ID is the unique identifier for the update package.
        # 
        # An update package ID is returned when you call the [CreateOTAFirmware](~~147311~~) operation to create the update package. You can call the [ListOTAFirmware](~~147450~~) operation and view the update package ID in the response.
        self.firmware_id = firmware_id
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The number of entries to return on each page. Maximum value: 100.
        self.page_size = page_size
        # The ProductKey of the product to which the device belongs.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.firmware_id is not None:
            result['FirmwareId'] = self.firmware_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('FirmwareId') is not None:
            self.firmware_id = m.get('FirmwareId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The key of each tag.
        self.key = key
        # The value of the tag.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTags(TeaModel):
    def __init__(
        self,
        ota_tag_dto: List[ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO] = None,
    ):
        self.ota_tag_dto = ota_tag_dto

    def validate(self):
        if self.ota_tag_dto:
            for k in self.ota_tag_dto:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['OtaTagDTO'] = []
        if self.ota_tag_dto is not None:
            for k in self.ota_tag_dto:
                result['OtaTagDTO'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.ota_tag_dto = []
        if m.get('OtaTagDTO') is not None:
            for k in m.get('OtaTagDTO'):
                temp_model = ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO()
                self.ota_tag_dto.append(temp_model.from_map(k))
        return self


class ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfo(TeaModel):
    def __init__(
        self,
        firmware_id: str = None,
        job_id: str = None,
        job_status: str = None,
        job_type: str = None,
        product_key: str = None,
        selection_type: str = None,
        tags: ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTags = None,
        target_selection: str = None,
        utc_create: str = None,
        utc_end_time: str = None,
        utc_modified: str = None,
        utc_start_time: str = None,
    ):
        # The ID of the update package.
        self.firmware_id = firmware_id
        # The ID of the update batch.
        self.job_id = job_id
        # The status of the update batch. Valid values:
        # 
        # *   **IN_PROGRESS**: The update batch is running.
        # *   **COMPLETE**: The update batch is completed.
        # *   **CANCELED**: The update batch is canceled.
        self.job_status = job_status
        # The type of the task. Valid values:
        # 
        # *   **VERFIY_FIRMWARE**: update package verification.
        # *   **UPGRADE_FIRMWARE**: batch update.
        self.job_type = job_type
        # The ProductKey of the product to which the update package belongs.
        self.product_key = product_key
        # The update policy of the update batch. Valid values:
        # 
        # *   DYNAMIC: dynamic update. This value is returned if you call the [CreateOTADynamicUpgradeJob](~~147887~~) API operation to create an update batch.
        # *   STATIC: static update. This value is returned if you call the [CreateOTAStaticUpgradeJob](~~147496~~) API operation to create an update batch.
        self.selection_type = selection_type
        # The tags of the update batch.
        self.tags = tags
        # The scope of the update. Valid values: 
        # 
        # - **ALL**: updates all devices.
        # - **SPECIFIC**: updates specified devices.
        # - **GRAY**: performs a phased update.
        # 
        # >  The value ALL is returned if you call the [CreateOTADynamicUpgradeJob](/help/en/iot-platform/latest/av6dui) API operation to create an update batch.
        self.target_selection = target_selection
        # The time when the update batch was created. The time is displayed in UTC.
        self.utc_create = utc_create
        # The end time of the update batch. The time is displayed in UTC.
        # 
        # >  This parameter is returned only after the update batch is completed.
        self.utc_end_time = utc_end_time
        # The time when the task was last modified. The time is in UTC.
        self.utc_modified = utc_modified
        # The start time of the update batch. The time is in the UTC format.
        self.utc_start_time = utc_start_time

    def validate(self):
        if self.tags:
            self.tags.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.firmware_id is not None:
            result['FirmwareId'] = self.firmware_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.job_status is not None:
            result['JobStatus'] = self.job_status
        if self.job_type is not None:
            result['JobType'] = self.job_type
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.selection_type is not None:
            result['SelectionType'] = self.selection_type
        if self.tags is not None:
            result['Tags'] = self.tags.to_map()
        if self.target_selection is not None:
            result['TargetSelection'] = self.target_selection
        if self.utc_create is not None:
            result['UtcCreate'] = self.utc_create
        if self.utc_end_time is not None:
            result['UtcEndTime'] = self.utc_end_time
        if self.utc_modified is not None:
            result['UtcModified'] = self.utc_modified
        if self.utc_start_time is not None:
            result['UtcStartTime'] = self.utc_start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FirmwareId') is not None:
            self.firmware_id = m.get('FirmwareId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('JobStatus') is not None:
            self.job_status = m.get('JobStatus')
        if m.get('JobType') is not None:
            self.job_type = m.get('JobType')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('SelectionType') is not None:
            self.selection_type = m.get('SelectionType')
        if m.get('Tags') is not None:
            temp_model = ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTags()
            self.tags = temp_model.from_map(m['Tags'])
        if m.get('TargetSelection') is not None:
            self.target_selection = m.get('TargetSelection')
        if m.get('UtcCreate') is not None:
            self.utc_create = m.get('UtcCreate')
        if m.get('UtcEndTime') is not None:
            self.utc_end_time = m.get('UtcEndTime')
        if m.get('UtcModified') is not None:
            self.utc_modified = m.get('UtcModified')
        if m.get('UtcStartTime') is not None:
            self.utc_start_time = m.get('UtcStartTime')
        return self


class ListOTAJobByDeviceResponseBodyData(TeaModel):
    def __init__(
        self,
        simple_otajob_info: List[ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfo] = None,
    ):
        self.simple_otajob_info = simple_otajob_info

    def validate(self):
        if self.simple_otajob_info:
            for k in self.simple_otajob_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SimpleOTAJobInfo'] = []
        if self.simple_otajob_info is not None:
            for k in self.simple_otajob_info:
                result['SimpleOTAJobInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.simple_otajob_info = []
        if m.get('SimpleOTAJobInfo') is not None:
            for k in m.get('SimpleOTAJobInfo'):
                temp_model = ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfo()
                self.simple_otajob_info.append(temp_model.from_map(k))
        return self


class ListOTAJobByDeviceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        current_page: int = None,
        data: ListOTAJobByDeviceResponseBodyData = None,
        error_message: str = None,
        page_count: int = None,
        page_size: int = None,
        request_id: str = None,
        success: bool = None,
        total: int = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The number of the returned page.
        self.current_page = current_page
        # The update batch information returned if the call is successful. For more information, see the following **SimpleOTAJobInfo** parameter.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The total number of pages.
        self.page_count = page_count
        # The number of entries returned per page.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success
        # The total number of update packages returned.
        self.total = total

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.page_count is not None:
            result['PageCount'] = self.page_count
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Data') is not None:
            temp_model = ListOTAJobByDeviceResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('PageCount') is not None:
            self.page_count = m.get('PageCount')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class ListOTAJobByDeviceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListOTAJobByDeviceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListOTAJobByDeviceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListOTAJobByFirmwareRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        firmware_id: str = None,
        iot_instance_id: str = None,
        page_size: int = None,
    ):
        # The number of the page to return. Pages start from page 1.
        self.current_page = current_page
        # The ID of the update package.
        # 
        # An update package ID is returned when you call the [CreateOTAFirmware](~~147311~~) operation to create the update package.
        # 
        # You can call the [ListOTAFirmware](~~147450~~) operation and view the update package ID in the response.
        self.firmware_id = firmware_id
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The number of entries to return on each page. Maximum value: 200.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.firmware_id is not None:
            result['FirmwareId'] = self.firmware_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('FirmwareId') is not None:
            self.firmware_id = m.get('FirmwareId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The key of each tag.
        self.key = key
        # The value of the tag.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTags(TeaModel):
    def __init__(
        self,
        ota_tag_dto: List[ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO] = None,
    ):
        self.ota_tag_dto = ota_tag_dto

    def validate(self):
        if self.ota_tag_dto:
            for k in self.ota_tag_dto:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['OtaTagDTO'] = []
        if self.ota_tag_dto is not None:
            for k in self.ota_tag_dto:
                result['OtaTagDTO'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.ota_tag_dto = []
        if m.get('OtaTagDTO') is not None:
            for k in m.get('OtaTagDTO'):
                temp_model = ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO()
                self.ota_tag_dto.append(temp_model.from_map(k))
        return self


class ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfo(TeaModel):
    def __init__(
        self,
        firmware_id: str = None,
        job_id: str = None,
        job_status: str = None,
        job_type: str = None,
        product_key: str = None,
        selection_type: str = None,
        tags: ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTags = None,
        target_selection: str = None,
        utc_create: str = None,
        utc_end_time: str = None,
        utc_modified: str = None,
        utc_start_time: str = None,
    ):
        # The ID of the update package.
        self.firmware_id = firmware_id
        # The ID of the update batch.
        self.job_id = job_id
        # The status of the update batch.
        # 
        # *   **PLANNED**: The update batch is being planned. The batch is created, but the scheduled time has not arrived. This parameter is returned only if you perform a static update.
        # *   **IN_PROGRESS**: The update batch is running.
        # *   **COMPLETE**: The update batch is completed.
        # *   **CANCELED**: The update batch is canceled.
        self.job_status = job_status
        # The type of the batch. Valid values:
        # 
        # *   **VERFIY_FIRMWARE**: update package verification.
        # *   **UPGRADE_FIRMWARE**: batch update.
        self.job_type = job_type
        # The ProductKey of the product to which the update package belongs.
        self.product_key = product_key
        # The update policy of the update batch. Valid values:
        # 
        # *   **DYNAMIC**: dynamic update. This value is returned if you call the [CreateOTADynamicUpgradeJob](~~147887~~) API operation to create an update batch.
        # *   **STATIC**: static update. This value is returned if you call the [CreateOTAStaticUpgradeJob](~~147496~~) API operation to create an update batch.
        self.selection_type = selection_type
        # The tags of the update batch.
        self.tags = tags
        # The scope of the update batch. Valid values: 
        # 
        # - **ALL**: updates all devices.
        # - **SPECIFIC**: updates specified devices.
        # - **GRAY**: performs a phased update.
        # 
        # >  The value ALL is returned if you call the [CreateOTADynamicUpgradeJob](/help/en/iot-platform/latest/av6dui) API operation to create an update batch.
        self.target_selection = target_selection
        # The time when the update batch was created. The time is displayed in UTC.
        self.utc_create = utc_create
        # The end time of the update batch. The time is displayed in UTC.
        # 
        # This parameter is returned only after the update batch is completed.
        self.utc_end_time = utc_end_time
        # The time when the update batch was last modified. The time is displayed in UTC.
        self.utc_modified = utc_modified
        # The start time of the update batch. The time is displayed in UTC.
        self.utc_start_time = utc_start_time

    def validate(self):
        if self.tags:
            self.tags.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.firmware_id is not None:
            result['FirmwareId'] = self.firmware_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.job_status is not None:
            result['JobStatus'] = self.job_status
        if self.job_type is not None:
            result['JobType'] = self.job_type
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.selection_type is not None:
            result['SelectionType'] = self.selection_type
        if self.tags is not None:
            result['Tags'] = self.tags.to_map()
        if self.target_selection is not None:
            result['TargetSelection'] = self.target_selection
        if self.utc_create is not None:
            result['UtcCreate'] = self.utc_create
        if self.utc_end_time is not None:
            result['UtcEndTime'] = self.utc_end_time
        if self.utc_modified is not None:
            result['UtcModified'] = self.utc_modified
        if self.utc_start_time is not None:
            result['UtcStartTime'] = self.utc_start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FirmwareId') is not None:
            self.firmware_id = m.get('FirmwareId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('JobStatus') is not None:
            self.job_status = m.get('JobStatus')
        if m.get('JobType') is not None:
            self.job_type = m.get('JobType')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('SelectionType') is not None:
            self.selection_type = m.get('SelectionType')
        if m.get('Tags') is not None:
            temp_model = ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTags()
            self.tags = temp_model.from_map(m['Tags'])
        if m.get('TargetSelection') is not None:
            self.target_selection = m.get('TargetSelection')
        if m.get('UtcCreate') is not None:
            self.utc_create = m.get('UtcCreate')
        if m.get('UtcEndTime') is not None:
            self.utc_end_time = m.get('UtcEndTime')
        if m.get('UtcModified') is not None:
            self.utc_modified = m.get('UtcModified')
        if m.get('UtcStartTime') is not None:
            self.utc_start_time = m.get('UtcStartTime')
        return self


class ListOTAJobByFirmwareResponseBodyData(TeaModel):
    def __init__(
        self,
        simple_otajob_info: List[ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfo] = None,
    ):
        self.simple_otajob_info = simple_otajob_info

    def validate(self):
        if self.simple_otajob_info:
            for k in self.simple_otajob_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SimpleOTAJobInfo'] = []
        if self.simple_otajob_info is not None:
            for k in self.simple_otajob_info:
                result['SimpleOTAJobInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.simple_otajob_info = []
        if m.get('SimpleOTAJobInfo') is not None:
            for k in m.get('SimpleOTAJobInfo'):
                temp_model = ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfo()
                self.simple_otajob_info.append(temp_model.from_map(k))
        return self


class ListOTAJobByFirmwareResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        current_page: int = None,
        data: ListOTAJobByFirmwareResponseBodyData = None,
        error_message: str = None,
        page_count: int = None,
        page_size: int = None,
        request_id: str = None,
        success: bool = None,
        total: int = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The number of the returned page.
        self.current_page = current_page
        # The update batch information returned if the call is successful. For more information, see **SimpleOTATaskInfo**.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The total number of pages.
        self.page_count = page_count
        # The number of entries returned per page.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success
        # The total number of update jobs returned.
        self.total = total

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.page_count is not None:
            result['PageCount'] = self.page_count
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Data') is not None:
            temp_model = ListOTAJobByFirmwareResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('PageCount') is not None:
            self.page_count = m.get('PageCount')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class ListOTAJobByFirmwareResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListOTAJobByFirmwareResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListOTAJobByFirmwareResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListOTAModuleByProductRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        product_key: str = None,
    ):
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The ProductKey of the product.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class ListOTAModuleByProductResponseBodyData(TeaModel):
    def __init__(
        self,
        alias_name: str = None,
        desc: str = None,
        gmt_create: str = None,
        gmt_modified: str = None,
        module_name: str = None,
        product_key: str = None,
    ):
        # The alias of the OTA module.
        self.alias_name = alias_name
        # The description of the OTA module.
        self.desc = desc
        # The time when the OTA module was created. The time is displayed in UTC.
        self.gmt_create = gmt_create
        # The last time when the OTA module was updated. The time is displayed in UTC.
        self.gmt_modified = gmt_modified
        # The name of the OTA module.
        self.module_name = module_name
        # The ProductKey of the product.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias_name is not None:
            result['AliasName'] = self.alias_name
        if self.desc is not None:
            result['Desc'] = self.desc
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.module_name is not None:
            result['ModuleName'] = self.module_name
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliasName') is not None:
            self.alias_name = m.get('AliasName')
        if m.get('Desc') is not None:
            self.desc = m.get('Desc')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('ModuleName') is not None:
            self.module_name = m.get('ModuleName')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class ListOTAModuleByProductResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[ListOTAModuleByProductResponseBodyData] = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The OTA modules returned if the call is successful.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListOTAModuleByProductResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListOTAModuleByProductResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListOTAModuleByProductResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListOTAModuleByProductResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListOTAModuleVersionsByDeviceRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        device_name: str = None,
        iot_id: str = None,
        iot_instance_id: str = None,
        page_size: int = None,
        product_key: str = None,
    ):
        # The number of the page to return. Default value: 1.
        self.current_page = current_page
        # The DeviceName of the device to be queried.
        # 
        # >  If you specify this parameter, you must also specify the **ProductKey** parameter.
        self.device_name = device_name
        # The ID of the device. The device ID is issued by IoT Platform.
        # 
        # >  If you specify this parameter, you do not need to specify **ProductKey** or **DeviceName**. The **IotId** parameter specifies a globally unique identifier (GUID) of the device, which corresponds to a combination of **ProductKey** and **DeviceName**. If you specify both **IotId** and the combination of **ProductKey** and **DeviceName**, **IotId** takes precedence.
        self.iot_id = iot_id
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The number of entries to return on each page. A maximum of 200 entries can be displayed on each page.
        self.page_size = page_size
        # The **ProductKey** of the product to which the device belongs.
        # 
        # >  If you specify this parameter, you must also specify the **DeviceName** parameter.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class ListOTAModuleVersionsByDeviceResponseBodyDataSimpleOTAModuleInfo(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        iot_id: str = None,
        module_name: str = None,
        module_version: str = None,
        product_key: str = None,
    ):
        # The DeviceName of the device.
        self.device_name = device_name
        # The ID of the device.
        self.iot_id = iot_id
        # The name of the OTA module.
        self.module_name = module_name
        # The module version that was submitted by the device.
        self.module_version = module_version
        # The **ProductKey** of the product to which the device belongs.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.module_name is not None:
            result['ModuleName'] = self.module_name
        if self.module_version is not None:
            result['ModuleVersion'] = self.module_version
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('ModuleName') is not None:
            self.module_name = m.get('ModuleName')
        if m.get('ModuleVersion') is not None:
            self.module_version = m.get('ModuleVersion')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class ListOTAModuleVersionsByDeviceResponseBodyData(TeaModel):
    def __init__(
        self,
        simple_otamodule_info: List[ListOTAModuleVersionsByDeviceResponseBodyDataSimpleOTAModuleInfo] = None,
    ):
        self.simple_otamodule_info = simple_otamodule_info

    def validate(self):
        if self.simple_otamodule_info:
            for k in self.simple_otamodule_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SimpleOTAModuleInfo'] = []
        if self.simple_otamodule_info is not None:
            for k in self.simple_otamodule_info:
                result['SimpleOTAModuleInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.simple_otamodule_info = []
        if m.get('SimpleOTAModuleInfo') is not None:
            for k in m.get('SimpleOTAModuleInfo'):
                temp_model = ListOTAModuleVersionsByDeviceResponseBodyDataSimpleOTAModuleInfo()
                self.simple_otamodule_info.append(temp_model.from_map(k))
        return self


class ListOTAModuleVersionsByDeviceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        current_page: int = None,
        data: ListOTAModuleVersionsByDeviceResponseBodyData = None,
        error_message: str = None,
        page_count: int = None,
        page_size: int = None,
        request_id: str = None,
        success: bool = None,
        total: int = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The current page number.
        self.current_page = current_page
        # The module version information returned if the call is successful. The information was submitted by the device. For more information, see the **SimpleOTAModuleInfo** parameter in this table.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The total number of pages returned.
        self.page_count = page_count
        # The number of module versions returned on each page.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success
        # The total number of module versions that was submitted by the device.
        self.total = total

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.page_count is not None:
            result['PageCount'] = self.page_count
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Data') is not None:
            temp_model = ListOTAModuleVersionsByDeviceResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('PageCount') is not None:
            self.page_count = m.get('PageCount')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class ListOTAModuleVersionsByDeviceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListOTAModuleVersionsByDeviceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListOTAModuleVersionsByDeviceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListOTATaskByJobRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        device_names: List[str] = None,
        iot_instance_id: str = None,
        job_id: str = None,
        page_size: int = None,
        task_status: str = None,
    ):
        # The number of the page to return. Pages start from page 1.
        # 
        # > The product of the value of the **CurrentPage** parameter and the value of the **PageSize** parameter must be less than or equal to 100,000.
        self.current_page = current_page
        self.device_names = device_names
        # The ID of the instance. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.
        # >*   If no **Overview** page or ID is generated for your instance, you do not need to configure this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The ID of the update batch. This ID uniquely identifies the update batch. You can obtain the ID from the value of the **JobId** parameter that is returned after you call the [CreateOTAVerifyJob](~~147480~~), [CreateOTAStaticUpgradeJob](~~147496~~), or [CreateOTADynamicUpgradeJob](~~147887~~) operation. You can also view the batch ID on the **Firmware Details** page of the IoT Platform console.
        self.job_id = job_id
        # The number of entries to return on each page. Maximum value: 100.
        # 
        # 
        # 
        # > The product of the value of the **CurrentPage** parameter and the value of the **PageSize** parameter must be less than or equal to 100,000.
        self.page_size = page_size
        # If you specify a value for this parameter, only the update tasks that are in the specified state are queried. Valid values:
        # 
        # *   **CONFIRM**: The update task is pending confirmation.
        # *   **QUEUED**: The update notification is to be pushed.
        # *   **NOTIFIED**: The update notification is pushed to the device.
        # *   **IN_PROGRESS**: The update task is in progress.
        # *   **SUCCEEDED**: The update is successful.
        # *   **FAILED**: The update failed.
        # *   **CANCELED**: The update batch is canceled.
        # 
        # If you do not specify a value for this parameter, all update tasks of the specified batch are queried.
        self.task_status = task_status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.device_names is not None:
            result['DeviceNames'] = self.device_names
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.task_status is not None:
            result['TaskStatus'] = self.task_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('DeviceNames') is not None:
            self.device_names = m.get('DeviceNames')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TaskStatus') is not None:
            self.task_status = m.get('TaskStatus')
        return self


class ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo(TeaModel):
    def __init__(
        self,
        dest_version: str = None,
        device_name: str = None,
        firmware_id: str = None,
        iot_id: str = None,
        job_id: str = None,
        product_key: str = None,
        product_name: str = None,
        progress: str = None,
        src_version: str = None,
        task_desc: str = None,
        task_id: str = None,
        task_status: str = None,
        timeout: str = None,
        utc_create: str = None,
        utc_modified: str = None,
    ):
        # The version of the destination over-the-air (OTA) update package.
        self.dest_version = dest_version
        # The name of the device.
        self.device_name = device_name
        # The ID of the update package.
        self.firmware_id = firmware_id
        # The ID of the device.
        self.iot_id = iot_id
        # The ID of the update batch.
        self.job_id = job_id
        # The ProductKey of the product to which the device belongs.
        self.product_key = product_key
        # The name of the product to which the device belongs.
        self.product_name = product_name
        # The current update progress.
        self.progress = progress
        # The firmware version before the update.
        self.src_version = src_version
        # The description of the update task. This parameter displays an error message if the device update times out or the update task is canceled.
        self.task_desc = task_desc
        # The ID of the update task.
        self.task_id = task_id
        # The update status of the device.
        # 
        # *   **CONFIRM**: The update task is pending confirmation.
        # *   **QUEUED**: The update notification is to be pushed.
        # *   **NOTIFIED**: The update notification is pushed to the device.
        # *   **IN_PROGRESS**: The update task is in progress.
        # *   **SUCCEEDED**: The update is successful.
        # *   **FAILED**: The update failed.
        # *   **CANCELED**: The update batch is canceled.
        self.task_status = task_status
        # The timeout period of the device update. Unit: minutes.
        # 
        # >  If no timeout period is specified for the update batch, the return value is null.
        self.timeout = timeout
        # The time when the update task was created. The time is displayed in UTC.
        self.utc_create = utc_create
        # The time when the update task was last modified. The time is displayed in UTC.
        self.utc_modified = utc_modified

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dest_version is not None:
            result['DestVersion'] = self.dest_version
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.firmware_id is not None:
            result['FirmwareId'] = self.firmware_id
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.product_name is not None:
            result['ProductName'] = self.product_name
        if self.progress is not None:
            result['Progress'] = self.progress
        if self.src_version is not None:
            result['SrcVersion'] = self.src_version
        if self.task_desc is not None:
            result['TaskDesc'] = self.task_desc
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_status is not None:
            result['TaskStatus'] = self.task_status
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.utc_create is not None:
            result['UtcCreate'] = self.utc_create
        if self.utc_modified is not None:
            result['UtcModified'] = self.utc_modified
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DestVersion') is not None:
            self.dest_version = m.get('DestVersion')
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('FirmwareId') is not None:
            self.firmware_id = m.get('FirmwareId')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('ProductName') is not None:
            self.product_name = m.get('ProductName')
        if m.get('Progress') is not None:
            self.progress = m.get('Progress')
        if m.get('SrcVersion') is not None:
            self.src_version = m.get('SrcVersion')
        if m.get('TaskDesc') is not None:
            self.task_desc = m.get('TaskDesc')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskStatus') is not None:
            self.task_status = m.get('TaskStatus')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('UtcCreate') is not None:
            self.utc_create = m.get('UtcCreate')
        if m.get('UtcModified') is not None:
            self.utc_modified = m.get('UtcModified')
        return self


class ListOTATaskByJobResponseBodyData(TeaModel):
    def __init__(
        self,
        simple_otatask_info: List[ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo] = None,
    ):
        self.simple_otatask_info = simple_otatask_info

    def validate(self):
        if self.simple_otatask_info:
            for k in self.simple_otatask_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SimpleOTATaskInfo'] = []
        if self.simple_otatask_info is not None:
            for k in self.simple_otatask_info:
                result['SimpleOTATaskInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.simple_otatask_info = []
        if m.get('SimpleOTATaskInfo') is not None:
            for k in m.get('SimpleOTATaskInfo'):
                temp_model = ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo()
                self.simple_otatask_info.append(temp_model.from_map(k))
        return self


class ListOTATaskByJobResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        current_page: int = None,
        data: ListOTATaskByJobResponseBodyData = None,
        error_message: str = None,
        page_count: int = None,
        page_size: int = None,
        request_id: str = None,
        success: bool = None,
        total: int = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The number of the returned page.
        self.current_page = current_page
        # The update task information returned if the call is successful. For more information, see **SimpleOTATaskInfo**.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The total number of pages returned.
        self.page_count = page_count
        # The number of entries returned per page.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success
        # The total number of update tasks.
        self.total = total

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.page_count is not None:
            result['PageCount'] = self.page_count
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Data') is not None:
            temp_model = ListOTATaskByJobResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('PageCount') is not None:
            self.page_count = m.get('PageCount')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class ListOTATaskByJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListOTATaskByJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListOTATaskByJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListOTAUnfinishedTaskByDeviceRequest(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        iot_id: str = None,
        iot_instance_id: str = None,
        module_name: str = None,
        product_key: str = None,
        task_status: str = None,
        task_status_list: List[str] = None,
    ):
        # The DeviceName of the device.
        # 
        # > If you specify this parameter, you must also specify the **ProductKey** parameter.
        self.device_name = device_name
        # The ID of the device.
        # 
        # > If you specify this parameter, you do not need to specify **ProductKey** or **DeviceName**. The **IotId** parameter specifies a globally unique identifier (GUID) of the device, which corresponds to a combination of **ProductKey** and **DeviceName**. If you specify both **IotId** and the combination of **ProductKey** and **DeviceName**, **IotId** takes precedence.
        self.iot_id = iot_id
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The name of the OTA module.
        # 
        # *   If you specify this parameter, update tasks of the specified module are queried.
        # *   If you do not specify this parameter, update tasks of all modules are queried.
        self.module_name = module_name
        # The ProductKey of the product to which the device belongs.
        # 
        # > If you specify this parameter, you must also specify the **DeviceName** parameter.
        self.product_key = product_key
        # The status of the update task.
        # 
        # *   **CONFIRM**: The update task is pending confirmation.
        # *   **QUEUED**: The update notification is to be pushed.
        # *   **NOTIFIED**: The update notification is pushed to the device.
        # *   **IN_PROGRESS**: The update task is in progress.
        self.task_status = task_status
        self.task_status_list = task_status_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.module_name is not None:
            result['ModuleName'] = self.module_name
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.task_status is not None:
            result['TaskStatus'] = self.task_status
        if self.task_status_list is not None:
            result['TaskStatusList'] = self.task_status_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ModuleName') is not None:
            self.module_name = m.get('ModuleName')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('TaskStatus') is not None:
            self.task_status = m.get('TaskStatus')
        if m.get('TaskStatusList') is not None:
            self.task_status_list = m.get('TaskStatusList')
        return self


class ListOTAUnfinishedTaskByDeviceResponseBodyDataSimpleOTATaskInfo(TeaModel):
    def __init__(
        self,
        dest_version: str = None,
        device_name: str = None,
        firmware_id: str = None,
        iot_id: str = None,
        job_id: str = None,
        module_name: str = None,
        product_key: str = None,
        product_name: str = None,
        src_version: str = None,
        task_id: str = None,
        task_status: str = None,
        utc_create: str = None,
        utc_modified: str = None,
    ):
        # The firmware version after the update.
        self.dest_version = dest_version
        # The DeviceName of the device.
        self.device_name = device_name
        # The ID of the update package.
        self.firmware_id = firmware_id
        # The ID of the device. The ID is a unique identifier that is issued by IoT Platform to the device.
        self.iot_id = iot_id
        # The ID of the update batch.
        self.job_id = job_id
        # The name of the OTA module.
        self.module_name = module_name
        # The ProductKey of the product to which the device belongs.
        self.product_key = product_key
        # The name of the product to which the device belongs.
        self.product_name = product_name
        # The firmware version before the update.
        self.src_version = src_version
        # The ID of the update task.
        self.task_id = task_id
        # The status of the update task.
        # 
        # *   **CONFIRM**: The update task is pending confirmation.
        # *   **QUEUED**: The update notification is to be pushed.
        # *   **NOTIFIED**: The update notification is pushed to the device.
        # *   **IN_PROGRESS**: The update task is in progress.
        self.task_status = task_status
        # The time when the update task was created. The time is displayed in UTC.
        self.utc_create = utc_create
        # The time when the update task was last modified. The time is displayed in UTC.
        self.utc_modified = utc_modified

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dest_version is not None:
            result['DestVersion'] = self.dest_version
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.firmware_id is not None:
            result['FirmwareId'] = self.firmware_id
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.module_name is not None:
            result['ModuleName'] = self.module_name
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.product_name is not None:
            result['ProductName'] = self.product_name
        if self.src_version is not None:
            result['SrcVersion'] = self.src_version
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_status is not None:
            result['TaskStatus'] = self.task_status
        if self.utc_create is not None:
            result['UtcCreate'] = self.utc_create
        if self.utc_modified is not None:
            result['UtcModified'] = self.utc_modified
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DestVersion') is not None:
            self.dest_version = m.get('DestVersion')
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('FirmwareId') is not None:
            self.firmware_id = m.get('FirmwareId')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('ModuleName') is not None:
            self.module_name = m.get('ModuleName')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('ProductName') is not None:
            self.product_name = m.get('ProductName')
        if m.get('SrcVersion') is not None:
            self.src_version = m.get('SrcVersion')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskStatus') is not None:
            self.task_status = m.get('TaskStatus')
        if m.get('UtcCreate') is not None:
            self.utc_create = m.get('UtcCreate')
        if m.get('UtcModified') is not None:
            self.utc_modified = m.get('UtcModified')
        return self


class ListOTAUnfinishedTaskByDeviceResponseBodyData(TeaModel):
    def __init__(
        self,
        simple_otatask_info: List[ListOTAUnfinishedTaskByDeviceResponseBodyDataSimpleOTATaskInfo] = None,
    ):
        self.simple_otatask_info = simple_otatask_info

    def validate(self):
        if self.simple_otatask_info:
            for k in self.simple_otatask_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SimpleOTATaskInfo'] = []
        if self.simple_otatask_info is not None:
            for k in self.simple_otatask_info:
                result['SimpleOTATaskInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.simple_otatask_info = []
        if m.get('SimpleOTATaskInfo') is not None:
            for k in m.get('SimpleOTATaskInfo'):
                temp_model = ListOTAUnfinishedTaskByDeviceResponseBodyDataSimpleOTATaskInfo()
                self.simple_otatask_info.append(temp_model.from_map(k))
        return self


class ListOTAUnfinishedTaskByDeviceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListOTAUnfinishedTaskByDeviceResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The update task information returned if the call is successful. For more information, see the following **SimpleOTATaskInfo**.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListOTAUnfinishedTaskByDeviceResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListOTAUnfinishedTaskByDeviceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListOTAUnfinishedTaskByDeviceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListOTAUnfinishedTaskByDeviceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListParserRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        iot_instance_id: str = None,
        page_size: int = None,
        search_name: str = None,
    ):
        self.current_page = current_page
        self.iot_instance_id = iot_instance_id
        self.page_size = page_size
        self.search_name = search_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        return self


class ListParserResponseBodyDataParserList(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        parser_id: int = None,
        status: str = None,
        utc_created: str = None,
        utc_modified: str = None,
    ):
        self.description = description
        self.name = name
        self.parser_id = parser_id
        self.status = status
        self.utc_created = utc_created
        self.utc_modified = utc_modified

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.parser_id is not None:
            result['ParserId'] = self.parser_id
        if self.status is not None:
            result['Status'] = self.status
        if self.utc_created is not None:
            result['UtcCreated'] = self.utc_created
        if self.utc_modified is not None:
            result['UtcModified'] = self.utc_modified
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ParserId') is not None:
            self.parser_id = m.get('ParserId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UtcCreated') is not None:
            self.utc_created = m.get('UtcCreated')
        if m.get('UtcModified') is not None:
            self.utc_modified = m.get('UtcModified')
        return self


class ListParserResponseBodyData(TeaModel):
    def __init__(
        self,
        parser_list: List[ListParserResponseBodyDataParserList] = None,
    ):
        self.parser_list = parser_list

    def validate(self):
        if self.parser_list:
            for k in self.parser_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ParserList'] = []
        if self.parser_list is not None:
            for k in self.parser_list:
                result['ParserList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.parser_list = []
        if m.get('ParserList') is not None:
            for k in m.get('ParserList'):
                temp_model = ListParserResponseBodyDataParserList()
                self.parser_list.append(temp_model.from_map(k))
        return self


class ListParserResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListParserResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        total: int = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success
        self.total = total

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListParserResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class ListParserResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListParserResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListParserResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListParserDataSourceRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        page: int = None,
        page_size: int = None,
        search_name: str = None,
    ):
        self.iot_instance_id = iot_instance_id
        self.page = page
        self.page_size = page_size
        self.search_name = search_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.page is not None:
            result['Page'] = self.page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.search_name is not None:
            result['SearchName'] = self.search_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SearchName') is not None:
            self.search_name = m.get('SearchName')
        return self


class ListParserDataSourceResponseBodyDataDataSource(TeaModel):
    def __init__(
        self,
        data_source_id: int = None,
        description: str = None,
        name: str = None,
        utc_created: str = None,
    ):
        self.data_source_id = data_source_id
        self.description = description
        self.name = name
        self.utc_created = utc_created

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_source_id is not None:
            result['DataSourceId'] = self.data_source_id
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.utc_created is not None:
            result['UtcCreated'] = self.utc_created
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataSourceId') is not None:
            self.data_source_id = m.get('DataSourceId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('UtcCreated') is not None:
            self.utc_created = m.get('UtcCreated')
        return self


class ListParserDataSourceResponseBodyData(TeaModel):
    def __init__(
        self,
        data_source: List[ListParserDataSourceResponseBodyDataDataSource] = None,
    ):
        self.data_source = data_source

    def validate(self):
        if self.data_source:
            for k in self.data_source:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DataSource'] = []
        if self.data_source is not None:
            for k in self.data_source:
                result['DataSource'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data_source = []
        if m.get('DataSource') is not None:
            for k in m.get('DataSource'):
                temp_model = ListParserDataSourceResponseBodyDataDataSource()
                self.data_source.append(temp_model.from_map(k))
        return self


class ListParserDataSourceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListParserDataSourceResponseBodyData = None,
        error_message: str = None,
        page: int = None,
        page_size: int = None,
        request_id: str = None,
        success: bool = None,
        total: int = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.page = page
        self.page_size = page_size
        self.request_id = request_id
        self.success = success
        self.total = total

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.page is not None:
            result['Page'] = self.page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListParserDataSourceResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class ListParserDataSourceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListParserDataSourceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListParserDataSourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListParserDestinationRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        is_failover: bool = None,
        parser_id: int = None,
    ):
        self.iot_instance_id = iot_instance_id
        self.is_failover = is_failover
        self.parser_id = parser_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.is_failover is not None:
            result['IsFailover'] = self.is_failover
        if self.parser_id is not None:
            result['ParserId'] = self.parser_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('IsFailover') is not None:
            self.is_failover = m.get('IsFailover')
        if m.get('ParserId') is not None:
            self.parser_id = m.get('ParserId')
        return self


class ListParserDestinationResponseBodyDataDestinations(TeaModel):
    def __init__(
        self,
        configuration: str = None,
        destination_id: int = None,
        is_failover: bool = None,
        name: str = None,
        type: str = None,
        utc_created: str = None,
        utc_modified: str = None,
    ):
        self.configuration = configuration
        self.destination_id = destination_id
        self.is_failover = is_failover
        self.name = name
        self.type = type
        self.utc_created = utc_created
        self.utc_modified = utc_modified

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.configuration is not None:
            result['Configuration'] = self.configuration
        if self.destination_id is not None:
            result['DestinationId'] = self.destination_id
        if self.is_failover is not None:
            result['IsFailover'] = self.is_failover
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        if self.utc_created is not None:
            result['UtcCreated'] = self.utc_created
        if self.utc_modified is not None:
            result['UtcModified'] = self.utc_modified
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Configuration') is not None:
            self.configuration = m.get('Configuration')
        if m.get('DestinationId') is not None:
            self.destination_id = m.get('DestinationId')
        if m.get('IsFailover') is not None:
            self.is_failover = m.get('IsFailover')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UtcCreated') is not None:
            self.utc_created = m.get('UtcCreated')
        if m.get('UtcModified') is not None:
            self.utc_modified = m.get('UtcModified')
        return self


class ListParserDestinationResponseBodyData(TeaModel):
    def __init__(
        self,
        destinations: List[ListParserDestinationResponseBodyDataDestinations] = None,
    ):
        self.destinations = destinations

    def validate(self):
        if self.destinations:
            for k in self.destinations:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['destinations'] = []
        if self.destinations is not None:
            for k in self.destinations:
                result['destinations'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.destinations = []
        if m.get('destinations') is not None:
            for k in m.get('destinations'):
                temp_model = ListParserDestinationResponseBodyDataDestinations()
                self.destinations.append(temp_model.from_map(k))
        return self


class ListParserDestinationResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListParserDestinationResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListParserDestinationResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListParserDestinationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListParserDestinationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListParserDestinationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListPowerStationRequest(TeaModel):
    def __init__(
        self,
        algorithm_instance_uid: str = None,
        iot_instance_id: str = None,
        page_no: int = None,
        page_size: int = None,
        power_station_name: str = None,
    ):
        self.algorithm_instance_uid = algorithm_instance_uid
        self.iot_instance_id = iot_instance_id
        self.page_no = page_no
        self.page_size = page_size
        self.power_station_name = power_station_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.algorithm_instance_uid is not None:
            result['AlgorithmInstanceUid'] = self.algorithm_instance_uid
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.power_station_name is not None:
            result['PowerStationName'] = self.power_station_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlgorithmInstanceUid') is not None:
            self.algorithm_instance_uid = m.get('AlgorithmInstanceUid')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('PowerStationName') is not None:
            self.power_station_name = m.get('PowerStationName')
        return self


class ListPowerStationResponseBodyDataDataList(TeaModel):
    def __init__(
        self,
        algo_instance_uid: str = None,
        description: str = None,
        name: str = None,
        power_station_uid: str = None,
        rated_power: int = None,
    ):
        self.algo_instance_uid = algo_instance_uid
        self.description = description
        self.name = name
        self.power_station_uid = power_station_uid
        self.rated_power = rated_power

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.algo_instance_uid is not None:
            result['AlgoInstanceUid'] = self.algo_instance_uid
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.power_station_uid is not None:
            result['PowerStationUid'] = self.power_station_uid
        if self.rated_power is not None:
            result['RatedPower'] = self.rated_power
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlgoInstanceUid') is not None:
            self.algo_instance_uid = m.get('AlgoInstanceUid')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PowerStationUid') is not None:
            self.power_station_uid = m.get('PowerStationUid')
        if m.get('RatedPower') is not None:
            self.rated_power = m.get('RatedPower')
        return self


class ListPowerStationResponseBodyData(TeaModel):
    def __init__(
        self,
        data_list: List[ListPowerStationResponseBodyDataDataList] = None,
        page_no: int = None,
        page_size: int = None,
        total: int = None,
    ):
        self.data_list = data_list
        self.page_no = page_no
        self.page_size = page_size
        self.total = total

    def validate(self):
        if self.data_list:
            for k in self.data_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DataList'] = []
        if self.data_list is not None:
            for k in self.data_list:
                result['DataList'].append(k.to_map() if k else None)
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data_list = []
        if m.get('DataList') is not None:
            for k in m.get('DataList'):
                temp_model = ListPowerStationResponseBodyDataDataList()
                self.data_list.append(temp_model.from_map(k))
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class ListPowerStationResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListPowerStationResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListPowerStationResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListPowerStationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListPowerStationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListPowerStationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListProductByTagsRequestProductTag(TeaModel):
    def __init__(
        self,
        tag_key: str = None,
        tag_value: str = None,
    ):
        # The keys of the product tags.
        self.tag_key = tag_key
        # The values of the product tags.
        self.tag_value = tag_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        return self


class ListProductByTagsRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        iot_instance_id: str = None,
        page_size: int = None,
        product_tag: List[ListProductByTagsRequestProductTag] = None,
    ):
        # The number of the page to return.
        self.current_page = current_page
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # 
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The number of entries to return on each page. Maximum value: 50.
        self.page_size = page_size
        self.product_tag = product_tag

    def validate(self):
        if self.product_tag:
            for k in self.product_tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        result['ProductTag'] = []
        if self.product_tag is not None:
            for k in self.product_tag:
                result['ProductTag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        self.product_tag = []
        if m.get('ProductTag') is not None:
            for k in m.get('ProductTag'):
                temp_model = ListProductByTagsRequestProductTag()
                self.product_tag.append(temp_model.from_map(k))
        return self


class ListProductByTagsResponseBodyProductInfosProductInfo(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        description: str = None,
        node_type: int = None,
        product_key: str = None,
        product_name: str = None,
    ):
        # The time when the product was created.
        self.create_time = create_time
        # The description of the product.
        self.description = description
        # The node type of the product. Valid values:
        # 
        # *   **0**: device. Sub-devices cannot be attached to a device. A device can connect to IoT Platform directly or as a sub-device of a gateway.
        # *   **1**: gateway. Sub-devices can be attached to a gateway. A gateway can manage sub-devices, maintain the topological relationships with sub-devices, and synchronize the topological relationships to IoT Platform.
        self.node_type = node_type
        # The ProductKey of the product. A ProductKey is a globally unique identifier (GUID) issued by IoT Platform to a new product.
        self.product_key = product_key
        # The name of the product.
        self.product_name = product_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.description is not None:
            result['Description'] = self.description
        if self.node_type is not None:
            result['NodeType'] = self.node_type
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.product_name is not None:
            result['ProductName'] = self.product_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('NodeType') is not None:
            self.node_type = m.get('NodeType')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('ProductName') is not None:
            self.product_name = m.get('ProductName')
        return self


class ListProductByTagsResponseBodyProductInfos(TeaModel):
    def __init__(
        self,
        product_info: List[ListProductByTagsResponseBodyProductInfosProductInfo] = None,
    ):
        self.product_info = product_info

    def validate(self):
        if self.product_info:
            for k in self.product_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ProductInfo'] = []
        if self.product_info is not None:
            for k in self.product_info:
                result['ProductInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.product_info = []
        if m.get('ProductInfo') is not None:
            for k in m.get('ProductInfo'):
                temp_model = ListProductByTagsResponseBodyProductInfosProductInfo()
                self.product_info.append(temp_model.from_map(k))
        return self


class ListProductByTagsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        product_infos: ListProductByTagsResponseBodyProductInfos = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The details of the products returned if the call is successful. The details are included in the **ProductInfo** parameter.
        # 
        # >  The returned product information is sorted in reverse-chronological order based on the time when the products were created.
        self.product_infos = product_infos
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.product_infos:
            self.product_infos.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.product_infos is not None:
            result['ProductInfos'] = self.product_infos.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('ProductInfos') is not None:
            temp_model = ListProductByTagsResponseBodyProductInfos()
            self.product_infos = temp_model.from_map(m['ProductInfos'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListProductByTagsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListProductByTagsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListProductByTagsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListProductTagsRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        product_key: str = None,
    ):
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The ProductKey of the product. A ProductKey is a GUID that is issued by IoT Platform to a product. You can use the IoT Platform console or call the [QueryProductList](~~69271~~) operation to view the information about all products within the current account.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class ListProductTagsResponseBodyDataProductTag(TeaModel):
    def __init__(
        self,
        tag_key: str = None,
        tag_value: str = None,
    ):
        # The key of each tag.
        self.tag_key = tag_key
        # The value of the tag.
        self.tag_value = tag_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        return self


class ListProductTagsResponseBodyData(TeaModel):
    def __init__(
        self,
        product_tag: List[ListProductTagsResponseBodyDataProductTag] = None,
    ):
        self.product_tag = product_tag

    def validate(self):
        if self.product_tag:
            for k in self.product_tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ProductTag'] = []
        if self.product_tag is not None:
            for k in self.product_tag:
                result['ProductTag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.product_tag = []
        if m.get('ProductTag') is not None:
            for k in m.get('ProductTag'):
                temp_model = ListProductTagsResponseBodyDataProductTag()
                self.product_tag.append(temp_model.from_map(k))
        return self


class ListProductTagsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListProductTagsResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The product tags returned if the call succeeds. For more information, see the parameters that are included in the **ProductTag** parameter.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListProductTagsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListProductTagsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListProductTagsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListProductTagsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListRuleRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        iot_instance_id: str = None,
        page_size: int = None,
        resource_group_id: str = None,
    ):
        # The number of the page to return. Maximum value: 1000. Default value: 1.
        self.current_page = current_page
        # The ID of the instance. You can view the ID of the instance on the **Overview** page in the IoT Platform console.****\
        # 
        # >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.****\
        # >*   If no **Overview** page or **ID** is generated for your instance, you do not need to configure this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The number of entries to return on each page. Valid values: 1 to 100. Default value: 10.
        self.page_size = page_size
        # The ID of the resource group to which the rule belongs. You can log on to the [Resource Management](https://resourcemanager.console.aliyun.com/resource-groups) console to view the details of the resource group.
        # 
        # >You can configure this parameter only if you have activated Resource Management.
        # 
        # If you do not configure this parameter, all rules of the Alibaba Cloud account are queried.
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        return self


class ListRuleResponseBodyDataRuleInfo(TeaModel):
    def __init__(
        self,
        create_user_id: int = None,
        created: str = None,
        data_type: str = None,
        id: int = None,
        modified: str = None,
        name: str = None,
        product_key: str = None,
        rule_desc: str = None,
        select: str = None,
        short_topic: str = None,
        status: str = None,
        topic: str = None,
        utc_created: str = None,
        utc_modified: str = None,
        where: str = None,
    ):
        # The ID of the user who created the rule.
        self.create_user_id = create_user_id
        # The time when the rule was created. The time is displayed in UTC-6.
        self.created = created
        # The data type of the rule. Valid values: **JSON** and **BINARY**.
        self.data_type = data_type
        # The ID of the rule.
        self.id = id
        # The time when the rule was last modified. The time is displayed in UTC-6.
        self.modified = modified
        # The name of the rule.
        self.name = name
        # The **ProductKey** of the product to which the rule applies.
        self.product_key = product_key
        # The description of the rule.
        self.rule_desc = rule_desc
        # The content that follows the **Select** keyword in the SQL statement of the rule.
        self.select = select
        # The topic to which the rule applies. The topic does not include the ProductKey level. Format: `${deviceName}/topicShortName`. ${deviceName} indicates the name of the device, and topicShortName indicates the custom name of the topic.
        # 
        # >  For information about how to use a plus sign (`+`) or a number sign (`#`) as a wildcard character in a topic, see [Topic wildcards](~~73731~~).
        self.short_topic = short_topic
        # The status of the rule. Valid values:
        # 
        # *   **RUNNING**: The rule is running.
        # *   **STOP**: The rule is disabled.
        self.status = status
        # The topic to which the rule applies. Format: `${productKey}/${deviceName}/topicShortName`.
        # 
        # >  For information about how to use a plus sign (`+`) or a number sign (`#`) as a wildcard character in a topic, see [Topic wildcards](~~73731~~).
        self.topic = topic
        # The time when the device was created. The time is displayed in UTC.
        self.utc_created = utc_created
        # The time when the rule was last modified.
        self.utc_modified = utc_modified
        # The **Where** query condition in the SQL statement of the rule.
        self.where = where

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_user_id is not None:
            result['CreateUserId'] = self.create_user_id
        if self.created is not None:
            result['Created'] = self.created
        if self.data_type is not None:
            result['DataType'] = self.data_type
        if self.id is not None:
            result['Id'] = self.id
        if self.modified is not None:
            result['Modified'] = self.modified
        if self.name is not None:
            result['Name'] = self.name
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.rule_desc is not None:
            result['RuleDesc'] = self.rule_desc
        if self.select is not None:
            result['Select'] = self.select
        if self.short_topic is not None:
            result['ShortTopic'] = self.short_topic
        if self.status is not None:
            result['Status'] = self.status
        if self.topic is not None:
            result['Topic'] = self.topic
        if self.utc_created is not None:
            result['UtcCreated'] = self.utc_created
        if self.utc_modified is not None:
            result['UtcModified'] = self.utc_modified
        if self.where is not None:
            result['Where'] = self.where
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateUserId') is not None:
            self.create_user_id = m.get('CreateUserId')
        if m.get('Created') is not None:
            self.created = m.get('Created')
        if m.get('DataType') is not None:
            self.data_type = m.get('DataType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Modified') is not None:
            self.modified = m.get('Modified')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('RuleDesc') is not None:
            self.rule_desc = m.get('RuleDesc')
        if m.get('Select') is not None:
            self.select = m.get('Select')
        if m.get('ShortTopic') is not None:
            self.short_topic = m.get('ShortTopic')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Topic') is not None:
            self.topic = m.get('Topic')
        if m.get('UtcCreated') is not None:
            self.utc_created = m.get('UtcCreated')
        if m.get('UtcModified') is not None:
            self.utc_modified = m.get('UtcModified')
        if m.get('Where') is not None:
            self.where = m.get('Where')
        return self


class ListRuleResponseBodyData(TeaModel):
    def __init__(
        self,
        rule_info: List[ListRuleResponseBodyDataRuleInfo] = None,
    ):
        self.rule_info = rule_info

    def validate(self):
        if self.rule_info:
            for k in self.rule_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['RuleInfo'] = []
        if self.rule_info is not None:
            for k in self.rule_info:
                result['RuleInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.rule_info = []
        if m.get('RuleInfo') is not None:
            for k in m.get('RuleInfo'):
                temp_model = ListRuleResponseBodyDataRuleInfo()
                self.rule_info.append(temp_model.from_map(k))
        return self


class ListRuleResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListRuleResponseBodyData = None,
        error_message: str = None,
        page: int = None,
        page_size: int = None,
        request_id: str = None,
        success: bool = None,
        total: int = None,
    ):
        # The error code that is returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The rules returned if the call is successful. For more information, see the "**RuleInfo**" section of this topic.
        # 
        # >  The returned rules are sorted in reverse-chronological order based on the time when the rules were created.
        self.data = data
        # The error message that is returned if the call fails.
        self.error_message = error_message
        # The page number of the returned page.
        self.page = page
        # The number of entries returned per page.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful. Valid values:
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success
        # The total number of pages returned.
        self.total = total

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.page is not None:
            result['Page'] = self.page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListRuleResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class ListRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListRuleActionsRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        rule_id: int = None,
    ):
        # The ID of the instance. On the **Overview** page in the IoT Platform console, you can view the **ID** of the instance.
        # 
        # >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.
        # >*   If the **Overview** page or instance ID is not displayed in the IoT Platform console, you do not need to configure this parameter.
        # 
        # For more information about the instance, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The ID of the rule.
        # 
        # You can log on to the IoT Platform console and go to the details page of the instance that you want to manage. On the instance details page, choose **Rules Engine** > **Data Forwarding** to obtain the rule ID. Alternatively, you can call the [ListRule](~~69486~~) operation to view the value of the **Id** parameter in the response.
        self.rule_id = rule_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        return self


class ListRuleActionsResponseBodyRuleActionListRuleActionInfo(TeaModel):
    def __init__(
        self,
        configuration: str = None,
        error_action_flag: bool = None,
        id: int = None,
        rule_id: int = None,
        status: str = None,
        type: str = None,
    ):
        # The configurations of the data destination.
        self.configuration = configuration
        # Indicates whether the data destination is used to receive the error operation data. The error operation data is data that failed to be forwarded two consecutive times.
        # 
        # *   **true**: This destination is used to receive error operation data.
        # *   **false**: This destination is not used to receive error operation data.
        self.error_action_flag = error_action_flag
        # The ID of the action in which data is forwarded to the destination.
        self.id = id
        # The ID of the rule based on which data is forwarded to the destination.
        self.rule_id = rule_id
        # The status of the data forwarding action. Valid values:
        # 
        # *   **INIT**: The action is being configured.
        # *   **NORMAL**: The configuration is complete, and the action can run properly.
        # *   **INVALID**: The configuration data is invalid, and the action fails to run.
        # *   **SHORTCUT**: An exception occurs and the data forwarding action is stopped.
        self.status = status
        # The type of the action in which data is forwarded to a destination. Valid values:
        # 
        # *   **REPUBLISH**: Data is forwarded to a topic.
        # *   **OTS**: Data is stored in Tablestore.
        # *   **MNS**: Data is forwarded to Message Service (MNS).
        # *   **ONS**: Data is forwarded to Message Queue for Apache RocketMQ.
        # *   **TSDB**: Data is stored in Time Series Database.
        # *   **FC**: Data is forwarded to Function Compute.
        # *   **RDS**: Data is forwarded to ApsaraDB RDS.
        # *   **AMQP**: Data is forwarded to an Advanced Message Queuing Protocol (AMQP) consumer group.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.configuration is not None:
            result['Configuration'] = self.configuration
        if self.error_action_flag is not None:
            result['ErrorActionFlag'] = self.error_action_flag
        if self.id is not None:
            result['Id'] = self.id
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Configuration') is not None:
            self.configuration = m.get('Configuration')
        if m.get('ErrorActionFlag') is not None:
            self.error_action_flag = m.get('ErrorActionFlag')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListRuleActionsResponseBodyRuleActionList(TeaModel):
    def __init__(
        self,
        rule_action_info: List[ListRuleActionsResponseBodyRuleActionListRuleActionInfo] = None,
    ):
        self.rule_action_info = rule_action_info

    def validate(self):
        if self.rule_action_info:
            for k in self.rule_action_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['RuleActionInfo'] = []
        if self.rule_action_info is not None:
            for k in self.rule_action_info:
                result['RuleActionInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.rule_action_info = []
        if m.get('RuleActionInfo') is not None:
            for k in m.get('RuleActionInfo'):
                temp_model = ListRuleActionsResponseBodyRuleActionListRuleActionInfo()
                self.rule_action_info.append(temp_model.from_map(k))
        return self


class ListRuleActionsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        rule_action_list: ListRuleActionsResponseBodyRuleActionList = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information about error codes, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # If the call is successful, all configured data forwarding actions of the specified rule are returned. For more information about the returned data, see the following **RuleActionInfo** parameter.
        self.rule_action_list = rule_action_list
        # Indicates whether the call was successful. 
        # 
        # - **true**: The call was successful.
        # - **false**: The call failed.
        self.success = success

    def validate(self):
        if self.rule_action_list:
            self.rule_action_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.rule_action_list is not None:
            result['RuleActionList'] = self.rule_action_list.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RuleActionList') is not None:
            temp_model = ListRuleActionsResponseBodyRuleActionList()
            self.rule_action_list = temp_model.from_map(m['RuleActionList'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListRuleActionsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListRuleActionsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListRuleActionsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTaskRequest(TeaModel):
    def __init__(
        self,
        device: Dict[str, Any] = None,
        iot_instance_id: str = None,
        job_id: str = None,
        limit: int = None,
        next_token: str = None,
        status: str = None,
    ):
        self.device = device
        self.iot_instance_id = iot_instance_id
        self.job_id = job_id
        self.limit = limit
        self.next_token = next_token
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device is not None:
            result['Device'] = self.device
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.limit is not None:
            result['Limit'] = self.limit
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Device') is not None:
            self.device = m.get('Device')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Limit') is not None:
            self.limit = m.get('Limit')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListTaskShrinkRequest(TeaModel):
    def __init__(
        self,
        device_shrink: str = None,
        iot_instance_id: str = None,
        job_id: str = None,
        limit: int = None,
        next_token: str = None,
        status: str = None,
    ):
        self.device_shrink = device_shrink
        self.iot_instance_id = iot_instance_id
        self.job_id = job_id
        self.limit = limit
        self.next_token = next_token
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_shrink is not None:
            result['Device'] = self.device_shrink
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.limit is not None:
            result['Limit'] = self.limit
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Device') is not None:
            self.device_shrink = m.get('Device')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Limit') is not None:
            self.limit = m.get('Limit')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListTaskResponseBodyDataData(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        iot_id: str = None,
        job_id: str = None,
        job_name: str = None,
        product_key: str = None,
        progress: str = None,
        status: str = None,
        task_id: str = None,
        utc_modified: str = None,
        utc_queue_time: str = None,
    ):
        self.device_name = device_name
        self.iot_id = iot_id
        self.job_id = job_id
        self.job_name = job_name
        self.product_key = product_key
        self.progress = progress
        self.status = status
        self.task_id = task_id
        self.utc_modified = utc_modified
        self.utc_queue_time = utc_queue_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.job_name is not None:
            result['JobName'] = self.job_name
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.progress is not None:
            result['Progress'] = self.progress
        if self.status is not None:
            result['Status'] = self.status
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.utc_modified is not None:
            result['UtcModified'] = self.utc_modified
        if self.utc_queue_time is not None:
            result['UtcQueueTime'] = self.utc_queue_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('JobName') is not None:
            self.job_name = m.get('JobName')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('Progress') is not None:
            self.progress = m.get('Progress')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('UtcModified') is not None:
            self.utc_modified = m.get('UtcModified')
        if m.get('UtcQueueTime') is not None:
            self.utc_queue_time = m.get('UtcQueueTime')
        return self


class ListTaskResponseBodyData(TeaModel):
    def __init__(
        self,
        data: List[ListTaskResponseBodyDataData] = None,
    ):
        self.data = data

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = ListTaskResponseBodyDataData()
                self.data.append(temp_model.from_map(k))
        return self


class ListTaskResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListTaskResponseBodyData = None,
        error_message: str = None,
        next_token: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.next_token = next_token
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListTaskResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListThingModelVersionRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        product_key: str = None,
    ):
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The ProductKey of the product.
        # 
        # You can view the ProductKey on the Product Details page of the IoT Platform console. You can also obtain the ProductKey by calling the [QueryProductList](~~69271~~) operation.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class ListThingModelVersionResponseBodyDataModelVersions(TeaModel):
    def __init__(
        self,
        description: str = None,
        gmt_create: int = None,
        model_version: str = None,
    ):
        # The description of the TSL model version.
        self.description = description
        # The timestamp when the TSL model version was published. The time is displayed in UTC. Unit: milliseconds.
        self.gmt_create = gmt_create
        # The version number of the TSL model.
        self.model_version = model_version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.model_version is not None:
            result['ModelVersion'] = self.model_version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('ModelVersion') is not None:
            self.model_version = m.get('ModelVersion')
        return self


class ListThingModelVersionResponseBodyData(TeaModel):
    def __init__(
        self,
        model_versions: List[ListThingModelVersionResponseBodyDataModelVersions] = None,
    ):
        # The list of TSL model versions. The versions are displayed in descending order based on the release time. The first version is the current version.
        self.model_versions = model_versions

    def validate(self):
        if self.model_versions:
            for k in self.model_versions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ModelVersions'] = []
        if self.model_versions is not None:
            for k in self.model_versions:
                result['ModelVersions'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.model_versions = []
        if m.get('ModelVersions') is not None:
            for k in m.get('ModelVersions'):
                temp_model = ListThingModelVersionResponseBodyDataModelVersions()
                self.model_versions.append(temp_model.from_map(k))
        return self


class ListThingModelVersionResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ListThingModelVersionResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The data returned if the call is successful.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ListThingModelVersionResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListThingModelVersionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListThingModelVersionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListThingModelVersionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListThingTemplatesRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
    ):
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class ListThingTemplatesResponseBodyData(TeaModel):
    def __init__(
        self,
        category_key: str = None,
        category_name: str = None,
    ):
        # The identifier of the category.
        self.category_key = category_key
        # The name of the category.
        self.category_name = category_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category_key is not None:
            result['CategoryKey'] = self.category_key
        if self.category_name is not None:
            result['CategoryName'] = self.category_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CategoryKey') is not None:
            self.category_key = m.get('CategoryKey')
        if m.get('CategoryName') is not None:
            self.category_name = m.get('CategoryName')
        return self


class ListThingTemplatesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[ListThingTemplatesResponseBodyData] = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The list of standard categories returned if the call is successful.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = ListThingTemplatesResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListThingTemplatesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListThingTemplatesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListThingTemplatesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyOTAFirmwareRequest(TeaModel):
    def __init__(
        self,
        firmware_desc: str = None,
        firmware_id: str = None,
        firmware_name: str = None,
        firmware_udi: str = None,
        iot_instance_id: str = None,
        product_key: str = None,
    ):
        self.firmware_desc = firmware_desc
        self.firmware_id = firmware_id
        self.firmware_name = firmware_name
        self.firmware_udi = firmware_udi
        self.iot_instance_id = iot_instance_id
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.firmware_desc is not None:
            result['FirmwareDesc'] = self.firmware_desc
        if self.firmware_id is not None:
            result['FirmwareId'] = self.firmware_id
        if self.firmware_name is not None:
            result['FirmwareName'] = self.firmware_name
        if self.firmware_udi is not None:
            result['FirmwareUdi'] = self.firmware_udi
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FirmwareDesc') is not None:
            self.firmware_desc = m.get('FirmwareDesc')
        if m.get('FirmwareId') is not None:
            self.firmware_id = m.get('FirmwareId')
        if m.get('FirmwareName') is not None:
            self.firmware_name = m.get('FirmwareName')
        if m.get('FirmwareUdi') is not None:
            self.firmware_udi = m.get('FirmwareUdi')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class ModifyOTAFirmwareResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ModifyOTAFirmwareResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyOTAFirmwareResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyOTAFirmwareResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyPowerStationRequest(TeaModel):
    def __init__(
        self,
        algorithm_instance_uid: str = None,
        description: str = None,
        iot_instance_id: str = None,
        power_station_name: str = None,
        power_station_uid: str = None,
        rated_power: int = None,
    ):
        self.algorithm_instance_uid = algorithm_instance_uid
        self.description = description
        self.iot_instance_id = iot_instance_id
        self.power_station_name = power_station_name
        self.power_station_uid = power_station_uid
        self.rated_power = rated_power

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.algorithm_instance_uid is not None:
            result['AlgorithmInstanceUid'] = self.algorithm_instance_uid
        if self.description is not None:
            result['Description'] = self.description
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.power_station_name is not None:
            result['PowerStationName'] = self.power_station_name
        if self.power_station_uid is not None:
            result['PowerStationUid'] = self.power_station_uid
        if self.rated_power is not None:
            result['RatedPower'] = self.rated_power
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlgorithmInstanceUid') is not None:
            self.algorithm_instance_uid = m.get('AlgorithmInstanceUid')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('PowerStationName') is not None:
            self.power_station_name = m.get('PowerStationName')
        if m.get('PowerStationUid') is not None:
            self.power_station_uid = m.get('PowerStationUid')
        if m.get('RatedPower') is not None:
            self.rated_power = m.get('RatedPower')
        return self


class ModifyPowerStationResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ModifyPowerStationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ModifyPowerStationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyPowerStationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class NotifyAddThingTopoRequest(TeaModel):
    def __init__(
        self,
        device_list_str: str = None,
        gw_device_name: str = None,
        gw_iot_id: str = None,
        gw_product_key: str = None,
        iot_instance_id: str = None,
    ):
        # A JSON array of the sub-device identity information. You can use a combination of **ProductKey** and **DeviceName** or only **IotId** to specify a device, such as **\[{"productKey":"a1BwAGxxx","deviceName":"device1"},{"IotId":"Q7uOhxxx"}]**.
        self.device_list_str = device_list_str
        # The DeviceName of the gateway.
        # 
        # >  If you specify this parameter, you must also specify the **ProductKey** parameter.
        self.gw_device_name = gw_device_name
        # The ID of the gateway device. The ID is a unique identifier that is issued by IoT Platform to the device.
        # 
        # >  If you specify this parameter, you do not need to specify **ProductKey** or **DeviceName**. The **IotId** parameter specifies a globally unique identifier (GUID) of the device, which corresponds to a combination of **ProductKey** and **DeviceName**. If you specify both **IotId** and the combination of **ProductKey** and **DeviceName**, **IotId** takes precedence.
        self.gw_iot_id = gw_iot_id
        # The ProductKey of the product to which the gateway belongs.
        # 
        # >  If you specify this parameter, you must also specify the **DeviceName** parameter.
        self.gw_product_key = gw_product_key
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_list_str is not None:
            result['DeviceListStr'] = self.device_list_str
        if self.gw_device_name is not None:
            result['GwDeviceName'] = self.gw_device_name
        if self.gw_iot_id is not None:
            result['GwIotId'] = self.gw_iot_id
        if self.gw_product_key is not None:
            result['GwProductKey'] = self.gw_product_key
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceListStr') is not None:
            self.device_list_str = m.get('DeviceListStr')
        if m.get('GwDeviceName') is not None:
            self.gw_device_name = m.get('GwDeviceName')
        if m.get('GwIotId') is not None:
            self.gw_iot_id = m.get('GwIotId')
        if m.get('GwProductKey') is not None:
            self.gw_product_key = m.get('GwProductKey')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class NotifyAddThingTopoResponseBodyData(TeaModel):
    def __init__(
        self,
        message_id: str = None,
    ):
        # The ID of the message that IoT Platform sends to the gateway. The message is used to notify the gateway to add a topology.
        self.message_id = message_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.message_id is not None:
            result['MessageId'] = self.message_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MessageId') is not None:
            self.message_id = m.get('MessageId')
        return self


class NotifyAddThingTopoResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: NotifyAddThingTopoResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The data returned if the call is successful.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = NotifyAddThingTopoResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class NotifyAddThingTopoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: NotifyAddThingTopoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = NotifyAddThingTopoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class OpenIotServiceRequest(TeaModel):
    def __init__(
        self,
        owner_id: int = None,
    ):
        self.owner_id = owner_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        return self


class OpenIotServiceResponseBody(TeaModel):
    def __init__(
        self,
        order_id: str = None,
        request_id: str = None,
    ):
        self.order_id = order_id
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class OpenIotServiceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: OpenIotServiceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = OpenIotServiceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PackageSoundCodeLabelBatchAudioRequest(TeaModel):
    def __init__(
        self,
        batch_code: str = None,
        iot_instance_id: str = None,
    ):
        self.batch_code = batch_code
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.batch_code is not None:
            result['BatchCode'] = self.batch_code
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BatchCode') is not None:
            self.batch_code = m.get('BatchCode')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class PackageSoundCodeLabelBatchAudioResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class PackageSoundCodeLabelBatchAudioResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: PackageSoundCodeLabelBatchAudioResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PackageSoundCodeLabelBatchAudioResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PageQuerySharedSpeechOpenRequest(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        iot_id: str = None,
        iot_instance_id: str = None,
        page_id: int = None,
        page_size: int = None,
        product_key: str = None,
        share_task_code: str = None,
        status: int = None,
    ):
        # The DeviceName of the device.
        self.device_name = device_name
        # The ID of the device.
        # 
        # > If you specify this parameter, you do not need to specify **ProductKey** and **DeviceName**. **IotId** specifies the GUID of the device. The value of the IotId parameter is a combination of the values of the **ProductKey** and **DeviceName** parameters. If you specify the **IotId**, **ProductKey**, and **DeviceName** parameters, the value of the **IotId** parameter takes precedence.
        self.iot_id = iot_id
        # The instance ID. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
        # 
        # >  If your instance has an ID, you must specify this parameter. Otherwise, the request fails. If no Overview page exists or no instance ID is displayed, you do not need to specify this parameter.
        # 
        # For more information, see the [Overview](~~356505~~) topic of IoT instances.
        self.iot_instance_id = iot_instance_id
        # The page number.
        self.page_id = page_id
        # The number of entries per page. Valid values: 1 to 100.
        self.page_size = page_size
        # The **ProductKey** of the product to which the device belongs.
        self.product_key = product_key
        # The code that is used to share the speeches.
        # 
        # You can obtain the **code** on the **Shared Corpus Management** page of **Speech Sending Voice Broadcasting Service**.
        self.share_task_code = share_task_code
        # The status of the speeches that you want to query. Valid values:
        # 
        # *   **1**: The speeches are pending approval.
        # *   **2**: The speeches are approved.
        # *   **3**: The speeches are rejected.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.page_id is not None:
            result['PageId'] = self.page_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.share_task_code is not None:
            result['ShareTaskCode'] = self.share_task_code
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('PageId') is not None:
            self.page_id = m.get('PageId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('ShareTaskCode') is not None:
            self.share_task_code = m.get('ShareTaskCode')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class PageQuerySharedSpeechOpenResponseBodyDataResultDataData(TeaModel):
    def __init__(
        self,
        audio_format: str = None,
        biz_code: str = None,
        code: str = None,
        speech_rate: int = None,
        status: int = None,
        text: str = None,
        voice: str = None,
        volume: int = None,
    ):
        # The audio format. Valid values: **wav**, **mp3**, and **amr**.
        self.audio_format = audio_format
        # The unique identifier of the speech in the project.
        self.biz_code = biz_code
        # The unique identifier of the template.
        self.code = code
        # The broadcasting speed. Valid values: -500 to 500.
        self.speech_rate = speech_rate
        # The status of the speeches. Valid values:
        # 
        # *   **1**: The speeches are pending approval.
        # *   **2**: The speeches are approved.
        # *   **3**: The speeches are rejected.
        self.status = status
        # The content of the speech.
        self.text = text
        # The sound effect that is used to broadcast speeches.
        self.voice = voice
        # The volume. Valid values: 0 to 100.
        self.volume = volume

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_format is not None:
            result['AudioFormat'] = self.audio_format
        if self.biz_code is not None:
            result['BizCode'] = self.biz_code
        if self.code is not None:
            result['Code'] = self.code
        if self.speech_rate is not None:
            result['SpeechRate'] = self.speech_rate
        if self.status is not None:
            result['Status'] = self.status
        if self.text is not None:
            result['Text'] = self.text
        if self.voice is not None:
            result['Voice'] = self.voice
        if self.volume is not None:
            result['Volume'] = self.volume
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioFormat') is not None:
            self.audio_format = m.get('AudioFormat')
        if m.get('BizCode') is not None:
            self.biz_code = m.get('BizCode')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('SpeechRate') is not None:
            self.speech_rate = m.get('SpeechRate')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Text') is not None:
            self.text = m.get('Text')
        if m.get('Voice') is not None:
            self.voice = m.get('Voice')
        if m.get('Volume') is not None:
            self.volume = m.get('Volume')
        return self


class PageQuerySharedSpeechOpenResponseBodyDataResultData(TeaModel):
    def __init__(
        self,
        data: List[PageQuerySharedSpeechOpenResponseBodyDataResultDataData] = None,
    ):
        self.data = data

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = PageQuerySharedSpeechOpenResponseBodyDataResultDataData()
                self.data.append(temp_model.from_map(k))
        return self


class PageQuerySharedSpeechOpenResponseBodyData(TeaModel):
    def __init__(
        self,
        page_id: int = None,
        page_size: int = None,
        result_data: PageQuerySharedSpeechOpenResponseBodyDataResultData = None,
        total: int = None,
    ):
        # The page number.
        self.page_id = page_id
        # The number of entries per page.
        self.page_size = page_size
        # The information about shared speeches.
        self.result_data = result_data
        # The total number of entries returned.
        self.total = total

    def validate(self):
        if self.result_data:
            self.result_data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_id is not None:
            result['PageId'] = self.page_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.result_data is not None:
            result['ResultData'] = self.result_data.to_map()
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageId') is not None:
            self.page_id = m.get('PageId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ResultData') is not None:
            temp_model = PageQuerySharedSpeechOpenResponseBodyDataResultData()
            self.result_data = temp_model.from_map(m['ResultData'])
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class PageQuerySharedSpeechOpenResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: PageQuerySharedSpeechOpenResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The result returned if the request was successful.
        self.data = data
        # The error message returned if the request fails.
        self.error_message = error_message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful.
        # 
        # *   **true**\
        # *   **false**\
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = PageQuerySharedSpeechOpenResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class PageQuerySharedSpeechOpenResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: PageQuerySharedSpeechOpenResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PageQuerySharedSpeechOpenResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PageQuerySpeechBroadcastHourRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        page_size: int = None,
        page_token: str = None,
        query_date_time_hour: str = None,
        share_task_code: str = None,
    ):
        # The instance ID. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
        # 
        # >  If your instance has an ID, you must specify this parameter. Otherwise, the request fails. If no Overview page exists or no instance ID is displayed, you do not need to specify this parameter.
        # 
        # For more information, see [Overview](~~356505~~) of IoT instances.
        self.iot_instance_id = iot_instance_id
        # The number of entries per page. Default value: 10. Valid values: 1 to 2000.
        self.page_size = page_size
        # The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of **PageToken**.
        # 
        # For example, if you want to query the results on Page n, you must set PageToken to the token that you obtained when you queried the results on Page n - 1.
        self.page_token = page_token
        # The end time of the hour in which you want to query data. Example: 2020090919, which specifies 19:00 on September 9, 2020.
        self.query_date_time_hour = query_date_time_hour
        # The code of the speech sharing task.
        # 
        # You can obtain the **code** on the **Shared Corpus Management** page of **Speech Sending Voice Broadcasting Service**.
        self.share_task_code = share_task_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.page_token is not None:
            result['PageToken'] = self.page_token
        if self.query_date_time_hour is not None:
            result['QueryDateTimeHour'] = self.query_date_time_hour
        if self.share_task_code is not None:
            result['ShareTaskCode'] = self.share_task_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('PageToken') is not None:
            self.page_token = m.get('PageToken')
        if m.get('QueryDateTimeHour') is not None:
            self.query_date_time_hour = m.get('QueryDateTimeHour')
        if m.get('ShareTaskCode') is not None:
            self.share_task_code = m.get('ShareTaskCode')
        return self


class PageQuerySpeechBroadcastHourResponseBodyDataResultDataData(TeaModel):
    def __init__(
        self,
        code: int = None,
        device_name: str = None,
        msg: str = None,
        product_key: str = None,
        share_task_code: str = None,
        speech_id: str = None,
        speechs: str = None,
        start_time: int = None,
    ):
        # Indicates whether the speech was successfully broadcasted. Valid values:
        # 
        # *   **0**: The speech was successfully broadcasted.
        # *   **1**: The speech was repeatedly broadcasted.
        # *   **2**: The speech does not exist.
        self.code = code
        # The DeviceName of the device.
        self.device_name = device_name
        # The message that indicates the speech broadcasting result.
        self.msg = msg
        # The **ProductKey** of the product to which the device belongs.
        self.product_key = product_key
        # The code of the sharing task.
        self.share_task_code = share_task_code
        # The ID of the speech that was broadcasted.
        self.speech_id = speech_id
        # The content of the broadcasted speech. The parameter value is a JSON array.
        self.speechs = speechs
        # The start time of speech broadcasting. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.msg is not None:
            result['Msg'] = self.msg
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.share_task_code is not None:
            result['ShareTaskCode'] = self.share_task_code
        if self.speech_id is not None:
            result['SpeechId'] = self.speech_id
        if self.speechs is not None:
            result['Speechs'] = self.speechs
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('Msg') is not None:
            self.msg = m.get('Msg')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('ShareTaskCode') is not None:
            self.share_task_code = m.get('ShareTaskCode')
        if m.get('SpeechId') is not None:
            self.speech_id = m.get('SpeechId')
        if m.get('Speechs') is not None:
            self.speechs = m.get('Speechs')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class PageQuerySpeechBroadcastHourResponseBodyDataResultData(TeaModel):
    def __init__(
        self,
        data: List[PageQuerySpeechBroadcastHourResponseBodyDataResultDataData] = None,
    ):
        self.data = data

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = PageQuerySpeechBroadcastHourResponseBodyDataResultDataData()
                self.data.append(temp_model.from_map(k))
        return self


class PageQuerySpeechBroadcastHourResponseBodyData(TeaModel):
    def __init__(
        self,
        page_id: int = None,
        page_size: int = None,
        page_token: str = None,
        result_data: PageQuerySpeechBroadcastHourResponseBodyDataResultData = None,
        total: int = None,
    ):
        # The page number.
        self.page_id = page_id
        # The number of entries per page.
        self.page_size = page_size
        # A pagination token. It can be used in the next request to retrieve a new page of results.
        # 
        # If **PageToken** is empty, no next page exists.
        self.page_token = page_token
        # The shared speech broadcasting data returned.
        self.result_data = result_data
        # The total number of entries returned.
        self.total = total

    def validate(self):
        if self.result_data:
            self.result_data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_id is not None:
            result['PageId'] = self.page_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.page_token is not None:
            result['PageToken'] = self.page_token
        if self.result_data is not None:
            result['ResultData'] = self.result_data.to_map()
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('PageId') is not None:
            self.page_id = m.get('PageId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('PageToken') is not None:
            self.page_token = m.get('PageToken')
        if m.get('ResultData') is not None:
            temp_model = PageQuerySpeechBroadcastHourResponseBodyDataResultData()
            self.result_data = temp_model.from_map(m['ResultData'])
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class PageQuerySpeechBroadcastHourResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: PageQuerySpeechBroadcastHourResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The result returned if the call is successful.
        self.data = data
        # The error message returned if the request fails.
        self.error_message = error_message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = PageQuerySpeechBroadcastHourResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class PageQuerySpeechBroadcastHourResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: PageQuerySpeechBroadcastHourResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PageQuerySpeechBroadcastHourResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PrintByTemplateRequest(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        history_print_topic: bool = None,
        iot_id: str = None,
        iot_instance_id: str = None,
        params_json_string: str = None,
        product_key: str = None,
        template_biz_code: str = None,
    ):
        # The DeviceName of the device.
        self.device_name = device_name
        self.history_print_topic = history_print_topic
        # The device ID.
        # 
        # > If you specify this parameter, you do not need to specify the **ProductKey** and **DeviceName** parameters. **IotId** specifies a globally unique identifier (GUID) of the device, which corresponds to a combination of **ProductKey** and **DeviceName**. If you specify the **IotId**, **ProductKey**, and **DeviceName** parameters, the value of the **IotId** parameter takes precedence.
        self.iot_id = iot_id
        # The instance ID.
        # 
        # You do not need to specify this parameter.
        self.iot_instance_id = iot_instance_id
        # The template parameters. You can obtain the template of receipts in the Letter Sending Service console, and configure parameters in the template to create a custom receipt that you want to print.
        self.params_json_string = params_json_string
        # The unique identifier of the product to which the device belongs.
        # 
        # > If you specify the **ProductKey** parameter, you must also specify the **DeviceName** parameter.
        self.product_key = product_key
        # The template identifier. You can obtain the template identifier in the Letter Sending Service console.
        self.template_biz_code = template_biz_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.history_print_topic is not None:
            result['HistoryPrintTopic'] = self.history_print_topic
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.params_json_string is not None:
            result['ParamsJsonString'] = self.params_json_string
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.template_biz_code is not None:
            result['TemplateBizCode'] = self.template_biz_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('HistoryPrintTopic') is not None:
            self.history_print_topic = m.get('HistoryPrintTopic')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ParamsJsonString') is not None:
            self.params_json_string = m.get('ParamsJsonString')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('TemplateBizCode') is not None:
            self.template_biz_code = m.get('TemplateBizCode')
        return self


class PrintByTemplateResponseBodyData(TeaModel):
    def __init__(
        self,
        device_error_code: str = None,
        device_error_message: str = None,
        id: str = None,
        max_retry_count: int = None,
        retry_count: int = None,
        success: bool = None,
    ):
        # The error code returned by the printer. Valid values:
        # 
        # *   2: The printer ran out of paper.
        # *   3: A paper jam occurred in the printer.
        self.device_error_code = device_error_code
        # The error message returned by the printer.
        self.device_error_message = device_error_message
        # The ID of the printing operation.
        self.id = id
        # The maximum number of retries. The value is fixed at 2, which indicates that up to two printing retries are supported.
        # 
        # If the printer responds to the printing command with a failure or timeout error, IoT Platform delivers the printing command to the printer.
        self.max_retry_count = max_retry_count
        # The actual number of retries.
        self.retry_count = retry_count
        # Indicates whether the printing operation was successful.
        # 
        # *   **true**: The printing operation was successful.
        # *   **false**: The printing operation failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_error_code is not None:
            result['DeviceErrorCode'] = self.device_error_code
        if self.device_error_message is not None:
            result['DeviceErrorMessage'] = self.device_error_message
        if self.id is not None:
            result['Id'] = self.id
        if self.max_retry_count is not None:
            result['MaxRetryCount'] = self.max_retry_count
        if self.retry_count is not None:
            result['RetryCount'] = self.retry_count
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceErrorCode') is not None:
            self.device_error_code = m.get('DeviceErrorCode')
        if m.get('DeviceErrorMessage') is not None:
            self.device_error_message = m.get('DeviceErrorMessage')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('MaxRetryCount') is not None:
            self.max_retry_count = m.get('MaxRetryCount')
        if m.get('RetryCount') is not None:
            self.retry_count = m.get('RetryCount')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class PrintByTemplateResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: PrintByTemplateResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The result of the printing operation.
        self.data = data
        # The error message returned if the request fails.
        self.error_message = error_message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = PrintByTemplateResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class PrintByTemplateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: PrintByTemplateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PrintByTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PubRequestUserProp(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The custom property key that is specified when you use MQTT 5.0 for communication.
        # 
        # This parameter must be used together with the **UserProp.N.Value** parameter.
        self.key = key
        # The custom property value that is specified when you use MQTT 5.0 for communication.
        # 
        # This parameter must be used together with the **UserProp.N.Key** parameter.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class PubRequest(TeaModel):
    def __init__(
        self,
        content_type: str = None,
        correlation_data: str = None,
        device_name: str = None,
        iot_instance_id: str = None,
        message_content: str = None,
        message_expiry_interval: int = None,
        payload_format_indicator: int = None,
        product_key: str = None,
        qos: int = None,
        response_topic: str = None,
        retained: bool = None,
        topic_alias: int = None,
        topic_full_name: str = None,
        user_prop: List[PubRequestUserProp] = None,
    ):
        # The content type of the message when you use MQTT 5.0 for communication.
        # 
        # The content type is usually MIME, such as text or plain********.
        self.content_type = content_type
        # The related data in the request/response communication mode when you use MQTT 5.0. You can specify this parameter as needed.
        # 
        # A message recipient can process the request based on the data.
        # 
        # >  You must convert the related data into binary data and perform Base64 encoding to generate a value of the string type.
        self.correlation_data = correlation_data
        # The name of the MQTT cloud gateway.
        # 
        # >When you publish a message to an MQTT cloud gateway, you must specify this parameter.
        self.device_name = device_name
        # The ID of the instance. You can obtain the **ID** of the instance on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must specify this parameter. Otherwise, the call fails.
        # >*   If the **Overview** page or the instance ID is not displayed in the IoT Platform console, ignore this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The body of the message that you want to publish.
        # 
        # To generate a message body, you must convert the raw message into binary data and perform Base64 encoding.
        self.message_content = message_content
        self.message_expiry_interval = message_expiry_interval
        # The payload identifier of the message when you use MQTT 5.0 for communication. Valid values:
        # 
        # *   **0**: The message is unknown byte data.
        # *   **1**: The payload of the message is UTF-8 encoded character data.
        self.payload_format_indicator = payload_format_indicator
        # The **ProductKey** of the product to which the device that receives the message belongs.
        self.product_key = product_key
        # The quality of service (QoS) level of the message. Valid values:
        # 
        # *   **0**: The message is published at most once.
        # *   **1**: The message is published at least once. If a PUBACK response is not returned after you publish a QoS 1 message, the message is pushed to the device again when the device reconnects to IoT Platform.
        # 
        # Default value: **0**.
        # 
        # For more information about message communication, see [Limits](~~30527~~).
        self.qos = qos
        # The response topic in the request/response communication mode when you use MQTT 5.0. For more information, see [MQTT 5.0](~~30540~~).
        self.response_topic = response_topic
        self.retained = retained
        self.topic_alias = topic_alias
        # The custom topic for the device that receives the message.
        # 
        # *   Topic format: `/${productKey}/${deviceName}/user/${TopicShortName}`.
        # *   You must specify the **Subscribe** permission, or **Publish and Subscribe** permissions for the topic.
        # 
        # > Make sure that the device subscribes to the topic before you call the Pub operation. Otherwise, the device cannot receive the message.
        # 
        # You can view the custom topics of a product on the **Topic Categories** tab of the **Product Details** page, or by calling the [QueryProductTopic](~~69647~~) operation. You can view the topics to which the device subscribes on the **Topic List** tab of the **Device Details** page.
        self.topic_full_name = topic_full_name
        self.user_prop = user_prop

    def validate(self):
        if self.user_prop:
            for k in self.user_prop:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content_type is not None:
            result['ContentType'] = self.content_type
        if self.correlation_data is not None:
            result['CorrelationData'] = self.correlation_data
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.message_content is not None:
            result['MessageContent'] = self.message_content
        if self.message_expiry_interval is not None:
            result['MessageExpiryInterval'] = self.message_expiry_interval
        if self.payload_format_indicator is not None:
            result['PayloadFormatIndicator'] = self.payload_format_indicator
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.qos is not None:
            result['Qos'] = self.qos
        if self.response_topic is not None:
            result['ResponseTopic'] = self.response_topic
        if self.retained is not None:
            result['Retained'] = self.retained
        if self.topic_alias is not None:
            result['TopicAlias'] = self.topic_alias
        if self.topic_full_name is not None:
            result['TopicFullName'] = self.topic_full_name
        result['UserProp'] = []
        if self.user_prop is not None:
            for k in self.user_prop:
                result['UserProp'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContentType') is not None:
            self.content_type = m.get('ContentType')
        if m.get('CorrelationData') is not None:
            self.correlation_data = m.get('CorrelationData')
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('MessageContent') is not None:
            self.message_content = m.get('MessageContent')
        if m.get('MessageExpiryInterval') is not None:
            self.message_expiry_interval = m.get('MessageExpiryInterval')
        if m.get('PayloadFormatIndicator') is not None:
            self.payload_format_indicator = m.get('PayloadFormatIndicator')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('Qos') is not None:
            self.qos = m.get('Qos')
        if m.get('ResponseTopic') is not None:
            self.response_topic = m.get('ResponseTopic')
        if m.get('Retained') is not None:
            self.retained = m.get('Retained')
        if m.get('TopicAlias') is not None:
            self.topic_alias = m.get('TopicAlias')
        if m.get('TopicFullName') is not None:
            self.topic_full_name = m.get('TopicFullName')
        self.user_prop = []
        if m.get('UserProp') is not None:
            for k in m.get('UserProp'):
                temp_model = PubRequestUserProp()
                self.user_prop.append(temp_model.from_map(k))
        return self


class PubResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        message_id: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The message ID that is generated by IoT Platform when the message is sent.
        self.message_id = message_id
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.message_id is not None:
            result['MessageId'] = self.message_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('MessageId') is not None:
            self.message_id = m.get('MessageId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class PubResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: PubResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PubResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PubBroadcastRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        message_content: str = None,
        product_key: str = None,
        topic_full_name: str = None,
    ):
        # The ID of the instance. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must specify this parameter. Otherwise, the call fails.
        # >*   If the **Overview** page or an instance ID is not displayed in the IoT Platform console, ignore this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The message body that you want to send. The maximum size of a message is 64 KB.
        # 
        # To generate a message body, you must convert the raw message into binary data and perform Base64 encoding.
        self.message_content = message_content
        # The **ProductKey** of the product to which the devices belong.
        # 
        # A **ProductKey** is the unique identifier of a product in IoT Platform. You can view the information about all products within the current Alibaba Cloud account in the IoT Platform console or by calling the [QueryProductList](~~69271~~) operation.
        self.product_key = product_key
        # The name of the topic. This parameter is optional.
        # 
        # *   If you do not specify this parameter, the message is pushed to all online devices that have the specified **ProductKey**. Devices receive the message from the broadcast topic in the following format: `/sys/${productKey}/${deviceName}/broadcast/request/${MessageId}`. The **MessageId** variable is generated by IoT Platform.
        # *   If you specify this parameter, the message is pushed to the devices that have the specified **ProductKey** and subscribe to the specified topic. You must specify a broadcast topic by using the following syntax: `/broadcast/${productKey}/Custom field`. Replace **${productKey}** with the **ProductKey** of the devices that receive the message. For the custom field, you can specify a value based on your business requirements.
        # 
        # > *   When you develop devices, you need to only write code to define a broadcast topic. You do not need to create a topic in the IoT Platform console.
        # >*   A maximum of 1,000 devices can subscribe to a broadcast topic. If the number of devices exceeds the limit, you can divide the devices into groups. For example, you can divide 5,000 devices into five groups that contain 1,000 devices. In this case, you must call this operation five times and set the value of the custom field to group1, group2, group3, group4, and group5. Then, configure the devices. This way, each group of devices subscribes to the corresponding topic.
        self.topic_full_name = topic_full_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.message_content is not None:
            result['MessageContent'] = self.message_content
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.topic_full_name is not None:
            result['TopicFullName'] = self.topic_full_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('MessageContent') is not None:
            self.message_content = m.get('MessageContent')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('TopicFullName') is not None:
            self.topic_full_name = m.get('TopicFullName')
        return self


class PubBroadcastResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        message_id: int = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the request fails.
        self.error_message = error_message
        # The message ID that is generated by IoT Platform when the message is sent.
        self.message_id = message_id
        # The ID of the request. The ID is a unique identifier of the request.
        self.request_id = request_id
        # Indicates whether the call was successful. Valid values:
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.message_id is not None:
            result['MessageId'] = self.message_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('MessageId') is not None:
            self.message_id = m.get('MessageId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class PubBroadcastResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: PubBroadcastResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PubBroadcastResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PublishScriptRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        parser_id: int = None,
    ):
        self.iot_instance_id = iot_instance_id
        self.parser_id = parser_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.parser_id is not None:
            result['ParserId'] = self.parser_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ParserId') is not None:
            self.parser_id = m.get('ParserId')
        return self


class PublishScriptResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        syntax_error_msg: str = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success
        self.syntax_error_msg = syntax_error_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.syntax_error_msg is not None:
            result['SyntaxErrorMsg'] = self.syntax_error_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('SyntaxErrorMsg') is not None:
            self.syntax_error_msg = m.get('SyntaxErrorMsg')
        return self


class PublishScriptResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: PublishScriptResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PublishScriptResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PublishStudioAppRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        description: str = None,
        iot_instance_id: str = None,
        project_id: str = None,
    ):
        self.app_id = app_id
        self.description = description
        self.iot_instance_id = iot_instance_id
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.description is not None:
            result['Description'] = self.description
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class PublishStudioAppResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: bool = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class PublishStudioAppResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: PublishStudioAppResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PublishStudioAppResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PublishThingModelRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        iot_instance_id: str = None,
        model_version: str = None,
        product_key: str = None,
        resource_group_id: str = None,
    ):
        # The description of the TSL model version.
        self.description = description
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The version number of the TSL model.
        # 
        # The version number must be 1 to 16 characters in length and can contain letters, digits, and periods (.).
        self.model_version = model_version
        # The ProductKey of the product.
        # 
        # You can view the ProductKey on the Product Details page of the IoT Platform console. You can also obtain the ProductKey by calling the [QueryProductList](~~69271~~) operation.
        self.product_key = product_key
        # The ID of the resource group.
        # 
        # >  You cannot specify this parameter.
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.model_version is not None:
            result['ModelVersion'] = self.model_version
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ModelVersion') is not None:
            self.model_version = m.get('ModelVersion')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        return self


class PublishThingModelResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class PublishThingModelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: PublishThingModelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PublishThingModelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PublishThingModelAsyncRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        iot_instance_id: str = None,
        product_key: str = None,
        thing_model_version: str = None,
    ):
        self.description = description
        self.iot_instance_id = iot_instance_id
        self.product_key = product_key
        self.thing_model_version = thing_model_version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.thing_model_version is not None:
            result['ThingModelVersion'] = self.thing_model_version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('ThingModelVersion') is not None:
            self.thing_model_version = m.get('ThingModelVersion')
        return self


class PublishThingModelAsyncResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class PublishThingModelAsyncResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: PublishThingModelAsyncResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PublishThingModelAsyncResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PushSpeechRequest(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        group_id: str = None,
        iot_id: str = None,
        iot_instance_id: str = None,
        product_key: str = None,
        project_code: str = None,
        push_mode: str = None,
        speech_code_list: List[str] = None,
    ):
        self.device_name = device_name
        self.group_id = group_id
        self.iot_id = iot_id
        self.iot_instance_id = iot_instance_id
        self.product_key = product_key
        self.project_code = project_code
        self.push_mode = push_mode
        self.speech_code_list = speech_code_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.project_code is not None:
            result['ProjectCode'] = self.project_code
        if self.push_mode is not None:
            result['PushMode'] = self.push_mode
        if self.speech_code_list is not None:
            result['SpeechCodeList'] = self.speech_code_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('ProjectCode') is not None:
            self.project_code = m.get('ProjectCode')
        if m.get('PushMode') is not None:
            self.push_mode = m.get('PushMode')
        if m.get('SpeechCodeList') is not None:
            self.speech_code_list = m.get('SpeechCodeList')
        return self


class PushSpeechResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class PushSpeechResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: PushSpeechResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PushSpeechResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryBatchRegisterDeviceStatusRequest(TeaModel):
    def __init__(
        self,
        apply_id: int = None,
        iot_instance_id: str = None,
        product_key: str = None,
    ):
        # The application ID. If the call of the [BatchRegisterDeviceWithApplyId](~~69514~~) or [BatchRegisterDevice](~~69473~~) operation is successful, the application ID is returned.
        self.apply_id = apply_id
        # The ID of the instance. You can view the ID of the instance on the **Overview** page in the IoT Platform console.
        # 
        # 
        # **Important**\
        # 
        # *   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.
        # *   If no **Overview** page or ID is generated for your instance, you do not need configure this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The ProductKey of the product to which the device belongs.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.apply_id is not None:
            result['ApplyId'] = self.apply_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApplyId') is not None:
            self.apply_id = m.get('ApplyId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class QueryBatchRegisterDeviceStatusResponseBodyDataInvalidDetailListInvalidDetailList(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        error_msg: str = None,
        nick_name: str = None,
    ):
        self.device_name = device_name
        self.error_msg = error_msg
        self.nick_name = nick_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.error_msg is not None:
            result['ErrorMsg'] = self.error_msg
        if self.nick_name is not None:
            result['NickName'] = self.nick_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('ErrorMsg') is not None:
            self.error_msg = m.get('ErrorMsg')
        if m.get('NickName') is not None:
            self.nick_name = m.get('NickName')
        return self


class QueryBatchRegisterDeviceStatusResponseBodyDataInvalidDetailList(TeaModel):
    def __init__(
        self,
        invalid_detail_list: List[QueryBatchRegisterDeviceStatusResponseBodyDataInvalidDetailListInvalidDetailList] = None,
    ):
        self.invalid_detail_list = invalid_detail_list

    def validate(self):
        if self.invalid_detail_list:
            for k in self.invalid_detail_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['invalidDetailList'] = []
        if self.invalid_detail_list is not None:
            for k in self.invalid_detail_list:
                result['invalidDetailList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.invalid_detail_list = []
        if m.get('invalidDetailList') is not None:
            for k in m.get('invalidDetailList'):
                temp_model = QueryBatchRegisterDeviceStatusResponseBodyDataInvalidDetailListInvalidDetailList()
                self.invalid_detail_list.append(temp_model.from_map(k))
        return self


class QueryBatchRegisterDeviceStatusResponseBodyDataInvalidList(TeaModel):
    def __init__(
        self,
        name: List[str] = None,
    ):
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class QueryBatchRegisterDeviceStatusResponseBodyDataValidList(TeaModel):
    def __init__(
        self,
        name: List[str] = None,
    ):
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class QueryBatchRegisterDeviceStatusResponseBodyData(TeaModel):
    def __init__(
        self,
        invalid_detail_list: QueryBatchRegisterDeviceStatusResponseBodyDataInvalidDetailList = None,
        invalid_list: QueryBatchRegisterDeviceStatusResponseBodyDataInvalidList = None,
        status: str = None,
        valid_list: QueryBatchRegisterDeviceStatusResponseBodyDataValidList = None,
    ):
        self.invalid_detail_list = invalid_detail_list
        # *   If the value of the **Status** parameter is **CHECK_FAILED** or **CREATE_FAILED**, some devices failed to be created and the names of the devices that failed to be created are returned in this parameter.
        # *   If the value of the **Status** parameter is **CHECK_SUCCESS** or **CREATE_SUCCESS**, all devices are created and an empty array is returned in this parameter.
        self.invalid_list = invalid_list
        # The processing status and result. Valid values:
        # 
        # *   **CHECK**: The system is verifying device names.
        # 
        # *   **CHECK_SUCCESS**: All devices in the application form are verified.
        # 
        # *   **CHECK_FAILED**: All devices in the application form failed to be verified.
        # 
        # *   **CREATE**: The system is creating devices.
        # 
        # *   **CREATE_SUCCESS**: All devices in the application form are created.
        # 
        # > If the authentication type of the product to which the devices belong is X.509, all devices and the related X.509 certificates are created.
        # 
        # *   **CREATE_FAILED**: Some devices in the application form failed to be created.
        # 
        # > If a device or X.509 certificate fails to be created in the current batch when the authentication type is X.509, all devices fail to be created.
        self.status = status
        # *   If the value of the **Status** parameter is **CHECK_FAILED** or **CREATE_FAILED**, some devices failed to be created and the names of the created devices are returned in this parameter.
        # *   If the value of the **Status** parameter is **CHECK_SUCCESS** or **CREATE_SUCCESS**, all devices are created and an empty array is returned in this parameter.
        self.valid_list = valid_list

    def validate(self):
        if self.invalid_detail_list:
            self.invalid_detail_list.validate()
        if self.invalid_list:
            self.invalid_list.validate()
        if self.valid_list:
            self.valid_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.invalid_detail_list is not None:
            result['InvalidDetailList'] = self.invalid_detail_list.to_map()
        if self.invalid_list is not None:
            result['InvalidList'] = self.invalid_list.to_map()
        if self.status is not None:
            result['Status'] = self.status
        if self.valid_list is not None:
            result['ValidList'] = self.valid_list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InvalidDetailList') is not None:
            temp_model = QueryBatchRegisterDeviceStatusResponseBodyDataInvalidDetailList()
            self.invalid_detail_list = temp_model.from_map(m['InvalidDetailList'])
        if m.get('InvalidList') is not None:
            temp_model = QueryBatchRegisterDeviceStatusResponseBodyDataInvalidList()
            self.invalid_list = temp_model.from_map(m['InvalidList'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('ValidList') is not None:
            temp_model = QueryBatchRegisterDeviceStatusResponseBodyDataValidList()
            self.valid_list = temp_model.from_map(m['ValidList'])
        return self


class QueryBatchRegisterDeviceStatusResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryBatchRegisterDeviceStatusResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        # 
        # >  X.509 certificates are available only for devices in the China (Shanghai) region. If devices do not reside in the China (Shanghai) region, you cannot generate X.509 certificates for the devices and the iot.device.RegionNotSupportX509 error code is returned.
        self.code = code
        # The status information returned if the call is successful.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryBatchRegisterDeviceStatusResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryBatchRegisterDeviceStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryBatchRegisterDeviceStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryBatchRegisterDeviceStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryCertUrlByApplyIdRequest(TeaModel):
    def __init__(
        self,
        apply_id: int = None,
        iot_instance_id: str = None,
    ):
        # The application ID. You can view the application ID in the result that is returned by the [BatchRegisterDeviceWithApplyId](~~69514~~) or [BatchRegisterDevice](~~69473~~) operation.
        self.apply_id = apply_id
        # The instance ID.
        # 
        # You can obtain the **ID** of the instance on the **Overview** page in the IoT Platform console. If your instance has an ID, you must specify this parameter. Otherwise, the request fails.
        # 
        # > The ID of a public instance may not be displayed on the Overview page. For information about how to obtain the instance ID, see [How do I obtain an instance ID?](~~267533~~)
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.apply_id is not None:
            result['ApplyId'] = self.apply_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApplyId') is not None:
            self.apply_id = m.get('ApplyId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class QueryCertUrlByApplyIdResponseBody(TeaModel):
    def __init__(
        self,
        cert_url: str = None,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The URL from which you can download the X.509 certificates of created devices.
        self.cert_url = cert_url
        # The error code returned if the request fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the request fails.
        self.error_message = error_message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cert_url is not None:
            result['CertUrl'] = self.cert_url
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CertUrl') is not None:
            self.cert_url = m.get('CertUrl')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryCertUrlByApplyIdResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryCertUrlByApplyIdResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryCertUrlByApplyIdResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryClientIdsRequest(TeaModel):
    def __init__(
        self,
        iot_id: str = None,
        iot_instance_id: str = None,
    ):
        # The ID of the device. You can call the [QueryDeviceInfo](~~257184~~) operation to query the **IotId** parameter.
        self.iot_id = iot_id
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class QueryClientIdsResponseBodyDataDynamicRegClientIds(TeaModel):
    def __init__(
        self,
        client_id: str = None,
        create_time: int = None,
    ):
        # The ClientID of the device.
        self.client_id = client_id
        # The time when the ClientID was created.
        self.create_time = create_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_id is not None:
            result['ClientId'] = self.client_id
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClientId') is not None:
            self.client_id = m.get('ClientId')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        return self


class QueryClientIdsResponseBodyData(TeaModel):
    def __init__(
        self,
        dynamic_reg_client_ids: List[QueryClientIdsResponseBodyDataDynamicRegClientIds] = None,
        iot_id: str = None,
    ):
        # The list of ClientIDs.
        self.dynamic_reg_client_ids = dynamic_reg_client_ids
        # The ID of the device.
        self.iot_id = iot_id

    def validate(self):
        if self.dynamic_reg_client_ids:
            for k in self.dynamic_reg_client_ids:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DynamicRegClientIds'] = []
        if self.dynamic_reg_client_ids is not None:
            for k in self.dynamic_reg_client_ids:
                result['DynamicRegClientIds'].append(k.to_map() if k else None)
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.dynamic_reg_client_ids = []
        if m.get('DynamicRegClientIds') is not None:
            for k in m.get('DynamicRegClientIds'):
                temp_model = QueryClientIdsResponseBodyDataDynamicRegClientIds()
                self.dynamic_reg_client_ids.append(temp_model.from_map(k))
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        return self


class QueryClientIdsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryClientIdsResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The ClientIDs returned if the call is successful. For more information, see **DynamicRegClientIds**.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryClientIdsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryClientIdsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryClientIdsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryClientIdsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryConsumerGroupByGroupIdRequest(TeaModel):
    def __init__(
        self,
        group_id: str = None,
        iot_instance_id: str = None,
    ):
        # The ID of the consumer group. After you call the [CreateConsumerGroup](~~170388~~) operation to create a consumer group, the consumer group ID is returned. You can call the [QueryConsumerGroupList](~~170419~~) operation to query the consumer group ID by group name. You can also go to the IoT Platform console,and choose **Rules** > **Server-side Subscription** > **Consumer Groups** to view the consumer group ID.
        self.group_id = group_id
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class QueryConsumerGroupByGroupIdResponseBodyData(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        group_id: str = None,
        group_name: str = None,
    ):
        # The time when the consumer group was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ss.SSSZ format. The time is displayed in UTC and accurate to milliseconds.
        self.create_time = create_time
        # The ID of the consumer group.
        self.group_id = group_id
        # The name of the consumer group.
        self.group_name = group_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        return self


class QueryConsumerGroupByGroupIdResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryConsumerGroupByGroupIdResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The details about the consumer group. This parameter is returned if the call is successful.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryConsumerGroupByGroupIdResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryConsumerGroupByGroupIdResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryConsumerGroupByGroupIdResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryConsumerGroupByGroupIdResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryConsumerGroupListRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        fuzzy: bool = None,
        group_name: str = None,
        iot_instance_id: str = None,
        page_size: int = None,
        sub_biz_code: str = None,
        type: str = None,
    ):
        # The number of the page to return. Pages start from page 1.
        self.current_page = current_page
        # Specifies whether to perform a fuzzy search. Valid values:
        # 
        # *   **true**: performs a fuzzy search. You must specify the **GroupName** parameter.
        # *   **false**: queries all consumer groups of the current account.
        # 
        # Default value: **false**.
        self.fuzzy = fuzzy
        # The name of the consumer group to be queried. This parameter is required if the **Fuzzy** parameter is set to **true**.
        self.group_name = group_name
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The number of entries to return on each page. Valid values: 1 to 1000.
        self.page_size = page_size
        self.sub_biz_code = sub_biz_code
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.fuzzy is not None:
            result['Fuzzy'] = self.fuzzy
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sub_biz_code is not None:
            result['SubBizCode'] = self.sub_biz_code
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Fuzzy') is not None:
            self.fuzzy = m.get('Fuzzy')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SubBizCode') is not None:
            self.sub_biz_code = m.get('SubBizCode')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class QueryConsumerGroupListResponseBodyDataConsumerGroupDTO(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        group_id: str = None,
        group_name: str = None,
    ):
        # The time when the consumer group was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ss.SSSZ format. The time is displayed in UTC and accurate to milliseconds.
        self.create_time = create_time
        # The ID of the consumer group.
        self.group_id = group_id
        # The name of the consumer group.
        self.group_name = group_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        return self


class QueryConsumerGroupListResponseBodyData(TeaModel):
    def __init__(
        self,
        consumer_group_dto: List[QueryConsumerGroupListResponseBodyDataConsumerGroupDTO] = None,
    ):
        self.consumer_group_dto = consumer_group_dto

    def validate(self):
        if self.consumer_group_dto:
            for k in self.consumer_group_dto:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ConsumerGroupDTO'] = []
        if self.consumer_group_dto is not None:
            for k in self.consumer_group_dto:
                result['ConsumerGroupDTO'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.consumer_group_dto = []
        if m.get('ConsumerGroupDTO') is not None:
            for k in m.get('ConsumerGroupDTO'):
                temp_model = QueryConsumerGroupListResponseBodyDataConsumerGroupDTO()
                self.consumer_group_dto.append(temp_model.from_map(k))
        return self


class QueryConsumerGroupListResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        current_page: int = None,
        data: QueryConsumerGroupListResponseBodyData = None,
        error_message: str = None,
        page_count: int = None,
        page_size: int = None,
        request_id: str = None,
        success: bool = None,
        total: int = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The number of the returned page.
        self.current_page = current_page
        # The details about the consumer group. This parameter is returned if the call is successful. For more information, see ConsumerGroupDTO.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The total number of returned pages.
        self.page_count = page_count
        # The number of entries returned per page.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success
        # The total number of entries.
        self.total = total

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.page_count is not None:
            result['PageCount'] = self.page_count
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Data') is not None:
            temp_model = QueryConsumerGroupListResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('PageCount') is not None:
            self.page_count = m.get('PageCount')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class QueryConsumerGroupListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryConsumerGroupListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryConsumerGroupListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryConsumerGroupStatusRequest(TeaModel):
    def __init__(
        self,
        group_id: str = None,
        iot_instance_id: str = None,
    ):
        # The ID of the consumer group. After you call the [CreateConsumerGroup](~~170388~~) operation to create a consumer group, the consumer group ID is returned. You can call the [QueryConsumerGroupList](~~170419~~) operation to query the consumer group ID by group name. You can also go to the IoT Platform console,and choose **Rules** > **Server-side Subscription** > **Consumer Groups** to view the consumer group ID.
        self.group_id = group_id
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class QueryConsumerGroupStatusResponseBodyClientConnectionStatusListConsumerGroupClientConnectionInfo(TeaModel):
    def __init__(
        self,
        accumulated_consume_count_per_minute: int = None,
        client_id: str = None,
        client_ip_port: str = None,
        online_time: int = None,
        real_time_consume_count_per_minute: int = None,
    ):
        # The consumption rate of accumulated messages on a single client of the consumer group. Unit: messages/minute.
        self.accumulated_consume_count_per_minute = accumulated_consume_count_per_minute
        # The ID of the client.
        self.client_id = client_id
        # The IP address and port of the client.
        self.client_ip_port = client_ip_port
        # The last time when the client was online. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
        self.online_time = online_time
        # The consumption rate of real-time messages on a single client of the consumer group. Unit: messages/minute.
        self.real_time_consume_count_per_minute = real_time_consume_count_per_minute

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accumulated_consume_count_per_minute is not None:
            result['AccumulatedConsumeCountPerMinute'] = self.accumulated_consume_count_per_minute
        if self.client_id is not None:
            result['ClientId'] = self.client_id
        if self.client_ip_port is not None:
            result['ClientIpPort'] = self.client_ip_port
        if self.online_time is not None:
            result['OnlineTime'] = self.online_time
        if self.real_time_consume_count_per_minute is not None:
            result['RealTimeConsumeCountPerMinute'] = self.real_time_consume_count_per_minute
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccumulatedConsumeCountPerMinute') is not None:
            self.accumulated_consume_count_per_minute = m.get('AccumulatedConsumeCountPerMinute')
        if m.get('ClientId') is not None:
            self.client_id = m.get('ClientId')
        if m.get('ClientIpPort') is not None:
            self.client_ip_port = m.get('ClientIpPort')
        if m.get('OnlineTime') is not None:
            self.online_time = m.get('OnlineTime')
        if m.get('RealTimeConsumeCountPerMinute') is not None:
            self.real_time_consume_count_per_minute = m.get('RealTimeConsumeCountPerMinute')
        return self


class QueryConsumerGroupStatusResponseBodyClientConnectionStatusList(TeaModel):
    def __init__(
        self,
        consumer_group_client_connection_info: List[QueryConsumerGroupStatusResponseBodyClientConnectionStatusListConsumerGroupClientConnectionInfo] = None,
    ):
        self.consumer_group_client_connection_info = consumer_group_client_connection_info

    def validate(self):
        if self.consumer_group_client_connection_info:
            for k in self.consumer_group_client_connection_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ConsumerGroupClientConnectionInfo'] = []
        if self.consumer_group_client_connection_info is not None:
            for k in self.consumer_group_client_connection_info:
                result['ConsumerGroupClientConnectionInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.consumer_group_client_connection_info = []
        if m.get('ConsumerGroupClientConnectionInfo') is not None:
            for k in m.get('ConsumerGroupClientConnectionInfo'):
                temp_model = QueryConsumerGroupStatusResponseBodyClientConnectionStatusListConsumerGroupClientConnectionInfo()
                self.consumer_group_client_connection_info.append(temp_model.from_map(k))
        return self


class QueryConsumerGroupStatusResponseBody(TeaModel):
    def __init__(
        self,
        accumulated_consume_count_per_minute: int = None,
        accumulation_count: int = None,
        client_connection_status_list: QueryConsumerGroupStatusResponseBodyClientConnectionStatusList = None,
        code: str = None,
        consumer_speed: int = None,
        error_message: str = None,
        last_consumer_time: str = None,
        real_time_consume_count_per_minute: int = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The message consumption rate. Unit: messages/minute.
        self.accumulated_consume_count_per_minute = accumulated_consume_count_per_minute
        # The number of accumulated messages.
        self.accumulation_count = accumulation_count
        # The details about the client. For more information, see **ConsumerGroupClientConnectionInfo**.
        self.client_connection_status_list = client_connection_status_list
        # The error code returned if the call fails. For more information, see [Error codes](/help/en/iot-platform/latest/bce100).
        self.code = code
        # The message consumption rate of the consumer group. Unit: messages/minute.
        self.consumer_speed = consumer_speed
        # The error message returned if the call fails.
        self.error_message = error_message
        # The time when the last message was consumed. The time is in the yyyy-MM-dd\"T\"HH:mm:ss.SSSZ format. The time is displayed in UTC and accurate to milliseconds.
        self.last_consumer_time = last_consumer_time
        # The consumption rate of real-time messages in the consumer group. Unit: messages/minute.
        self.real_time_consume_count_per_minute = real_time_consume_count_per_minute
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.client_connection_status_list:
            self.client_connection_status_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accumulated_consume_count_per_minute is not None:
            result['AccumulatedConsumeCountPerMinute'] = self.accumulated_consume_count_per_minute
        if self.accumulation_count is not None:
            result['AccumulationCount'] = self.accumulation_count
        if self.client_connection_status_list is not None:
            result['ClientConnectionStatusList'] = self.client_connection_status_list.to_map()
        if self.code is not None:
            result['Code'] = self.code
        if self.consumer_speed is not None:
            result['ConsumerSpeed'] = self.consumer_speed
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.last_consumer_time is not None:
            result['LastConsumerTime'] = self.last_consumer_time
        if self.real_time_consume_count_per_minute is not None:
            result['RealTimeConsumeCountPerMinute'] = self.real_time_consume_count_per_minute
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AccumulatedConsumeCountPerMinute') is not None:
            self.accumulated_consume_count_per_minute = m.get('AccumulatedConsumeCountPerMinute')
        if m.get('AccumulationCount') is not None:
            self.accumulation_count = m.get('AccumulationCount')
        if m.get('ClientConnectionStatusList') is not None:
            temp_model = QueryConsumerGroupStatusResponseBodyClientConnectionStatusList()
            self.client_connection_status_list = temp_model.from_map(m['ClientConnectionStatusList'])
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ConsumerSpeed') is not None:
            self.consumer_speed = m.get('ConsumerSpeed')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('LastConsumerTime') is not None:
            self.last_consumer_time = m.get('LastConsumerTime')
        if m.get('RealTimeConsumeCountPerMinute') is not None:
            self.real_time_consume_count_per_minute = m.get('RealTimeConsumeCountPerMinute')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryConsumerGroupStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryConsumerGroupStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryConsumerGroupStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryCustomTimelineTableStatusRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        table_name: str = None,
    ):
        self.iot_instance_id = iot_instance_id
        self.table_name = table_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.table_name is not None:
            result['TableName'] = self.table_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('TableName') is not None:
            self.table_name = m.get('TableName')
        return self


class QueryCustomTimelineTableStatusResponseBodyData(TeaModel):
    def __init__(
        self,
        count: int = None,
        has_next: bool = None,
        page_num: int = None,
        page_size: int = None,
        result_json: str = None,
    ):
        self.count = count
        self.has_next = has_next
        self.page_num = page_num
        self.page_size = page_size
        self.result_json = result_json

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.has_next is not None:
            result['HasNext'] = self.has_next
        if self.page_num is not None:
            result['PageNum'] = self.page_num
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.result_json is not None:
            result['ResultJson'] = self.result_json
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('HasNext') is not None:
            self.has_next = m.get('HasNext')
        if m.get('PageNum') is not None:
            self.page_num = m.get('PageNum')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ResultJson') is not None:
            self.result_json = m.get('ResultJson')
        return self


class QueryCustomTimelineTableStatusResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryCustomTimelineTableStatusResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryCustomTimelineTableStatusResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryCustomTimelineTableStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryCustomTimelineTableStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryCustomTimelineTableStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryDetailSceneRuleLogRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        end_time: int = None,
        iot_instance_id: str = None,
        page_size: int = None,
        rule_id: str = None,
        start_time: int = None,
        trace_id: str = None,
    ):
        self.current_page = current_page
        self.end_time = end_time
        self.iot_instance_id = iot_instance_id
        self.page_size = page_size
        self.rule_id = rule_id
        self.start_time = start_time
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class QueryDetailSceneRuleLogResponseBodyDataLogList(TeaModel):
    def __init__(
        self,
        code: str = None,
        message: str = None,
        pk_dn: str = None,
    ):
        self.code = code
        self.message = message
        self.pk_dn = pk_dn

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.pk_dn is not None:
            result['PkDn'] = self.pk_dn
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PkDn') is not None:
            self.pk_dn = m.get('PkDn')
        return self


class QueryDetailSceneRuleLogResponseBodyData(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        log_list: List[QueryDetailSceneRuleLogResponseBodyDataLogList] = None,
        page_size: int = None,
        total: int = None,
    ):
        self.current_page = current_page
        self.log_list = log_list
        self.page_size = page_size
        self.total = total

    def validate(self):
        if self.log_list:
            for k in self.log_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        result['LogList'] = []
        if self.log_list is not None:
            for k in self.log_list:
                result['LogList'].append(k.to_map() if k else None)
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        self.log_list = []
        if m.get('LogList') is not None:
            for k in m.get('LogList'):
                temp_model = QueryDetailSceneRuleLogResponseBodyDataLogList()
                self.log_list.append(temp_model.from_map(k))
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class QueryDetailSceneRuleLogResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryDetailSceneRuleLogResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryDetailSceneRuleLogResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryDetailSceneRuleLogResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryDetailSceneRuleLogResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryDetailSceneRuleLogResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryDeviceRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        iot_instance_id: str = None,
        next_token: str = None,
        page_size: int = None,
        product_key: str = None,
    ):
        # The number of the page to return. Default value: 1.
        self.current_page = current_page
        # The ID of the instance. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
        # 
        # 
        # >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.
        # >*   If no **Overview** page or **ID** is generated for your instance, you do not need to configure this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The token that is used to retrieve the next page of the query results. The first time you perform a query operation, you do not need to configure this parameter. You must specify the token that is obtained from the previous query for the **NextToken** parameter.
        # 
        # If the product of the value of the **PageSize** parameter and the value of the **CurrentPage** parameter is greater than 10,000, you must configure the **NextToken** parameter. Otherwise, data cannot be returned.
        # 
        # 
        # >If you configure the **NextToken** parameter, the product of the value of the **PageSize** parameter and the value of the **CurrentPage** parameter must be less than 1,000,000. Otherwise, data cannot be returned.
        self.next_token = next_token
        # The number of entries to return on each page. Valid values: 1 to 50. Default value: 10.
        self.page_size = page_size
        # The ProductKey of the product to which the device belongs.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class QueryDeviceResponseBodyDataDeviceInfo(TeaModel):
    def __init__(
        self,
        device_id: str = None,
        device_name: str = None,
        device_secret: str = None,
        device_status: str = None,
        device_type: str = None,
        gmt_create: str = None,
        gmt_modified: str = None,
        iot_id: str = None,
        nickname: str = None,
        product_key: str = None,
        utc_create: str = None,
        utc_modified: str = None,
    ):
        # The ID of the device.
        # 
        # >  This parameter is deprecated. Do not use this parameter to identify a device. You can use the **IotId** parameter or a combination of the **ProductKey** and **DeviceName** parameters to identify a device.
        self.device_id = device_id
        # The name of the device.
        self.device_name = device_name
        # The DeviceSecret of the device.
        self.device_secret = device_secret
        # The status of the device. Valid values:
        # 
        # *   **ONLINE**: The device is online.
        # *   **OFFLINE**: The device is offline.
        # *   **UNACTIVE**: The device is not activated.
        # *   **DISABLE**: The device is deactivated.
        self.device_status = device_status
        # The category of the product to which the device belongs.
        # 
        # >  This parameter is not returned.
        self.device_type = device_type
        # The time when the device was created. The time is in the GMT format.
        self.gmt_create = gmt_create
        # The time when the device information was last updated. The time is in the GMT format.
        self.gmt_modified = gmt_modified
        # The ID of the device. The ID is a unique identifier that is issued by IoT Platform to the device.
        self.iot_id = iot_id
        # The alias of the device.
        self.nickname = nickname
        # The ProductKey of the product to which the device belongs.
        self.product_key = product_key
        # The time when the device was created. The time is displayed in UTC.
        self.utc_create = utc_create
        # The time when the device information was last updated. The time is displayed in UTC.
        self.utc_modified = utc_modified

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.device_secret is not None:
            result['DeviceSecret'] = self.device_secret
        if self.device_status is not None:
            result['DeviceStatus'] = self.device_status
        if self.device_type is not None:
            result['DeviceType'] = self.device_type
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.nickname is not None:
            result['Nickname'] = self.nickname
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.utc_create is not None:
            result['UtcCreate'] = self.utc_create
        if self.utc_modified is not None:
            result['UtcModified'] = self.utc_modified
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('DeviceSecret') is not None:
            self.device_secret = m.get('DeviceSecret')
        if m.get('DeviceStatus') is not None:
            self.device_status = m.get('DeviceStatus')
        if m.get('DeviceType') is not None:
            self.device_type = m.get('DeviceType')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('Nickname') is not None:
            self.nickname = m.get('Nickname')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('UtcCreate') is not None:
            self.utc_create = m.get('UtcCreate')
        if m.get('UtcModified') is not None:
            self.utc_modified = m.get('UtcModified')
        return self


class QueryDeviceResponseBodyData(TeaModel):
    def __init__(
        self,
        device_info: List[QueryDeviceResponseBodyDataDeviceInfo] = None,
    ):
        self.device_info = device_info

    def validate(self):
        if self.device_info:
            for k in self.device_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DeviceInfo'] = []
        if self.device_info is not None:
            for k in self.device_info:
                result['DeviceInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.device_info = []
        if m.get('DeviceInfo') is not None:
            for k in m.get('DeviceInfo'):
                temp_model = QueryDeviceResponseBodyDataDeviceInfo()
                self.device_info.append(temp_model.from_map(k))
        return self


class QueryDeviceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryDeviceResponseBodyData = None,
        error_message: str = None,
        next_token: str = None,
        page: int = None,
        page_count: int = None,
        page_size: int = None,
        request_id: str = None,
        success: bool = None,
        total: int = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The device information returned if the call is successful. The details of the devices are included in the **DeviceInfo** parameter.
        # 
        # >  The returned device information is sorted in reverse chronological order based on the time when the devices were created.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The token that is used to retrieve the subsequent page of the query results. You can specify this parameter in the subsequent query to obtain the next page of results.
        # 
        # If the **NextToken** parameter is empty, no subsequent page exists.
        self.next_token = next_token
        # The page number of the returned page.
        self.page = page
        # The total number of pages returned.
        self.page_count = page_count
        # The number of entries returned per page.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful. Valid values:
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success
        # The total number of devices.
        self.total = total

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.page is not None:
            result['Page'] = self.page
        if self.page_count is not None:
            result['PageCount'] = self.page_count
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryDeviceResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('PageCount') is not None:
            self.page_count = m.get('PageCount')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class QueryDeviceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryDeviceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryDeviceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryDeviceBySQLRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        sql: str = None,
    ):
        # The ID of the instance. You can view the **ID** of the instance on the **Instance Overview** page in the IoT Platform console.
        # 
        # 
        # **Important**\
        # 
        # *   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.****\
        # *   If no **Overview** page or **ID** is generated for your instance, you do not need to configure this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The SQL-like statement that you want to execute to query devices. For more information about specific requirements and examples, see the following section.
        self.sql = sql

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.sql is not None:
            result['SQL'] = self.sql
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('SQL') is not None:
            self.sql = m.get('SQL')
        return self


class QueryDeviceBySQLResponseBodyDataGroups(TeaModel):
    def __init__(
        self,
        group_id: str = None,
    ):
        # The ID of the group.
        self.group_id = group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        return self


class QueryDeviceBySQLResponseBodyDataOTAModules(TeaModel):
    def __init__(
        self,
        firmware_version: str = None,
        module_name: str = None,
    ):
        # The version number of each OTA module.
        self.firmware_version = firmware_version
        # The name of the OTA module.
        self.module_name = module_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.firmware_version is not None:
            result['FirmwareVersion'] = self.firmware_version
        if self.module_name is not None:
            result['ModuleName'] = self.module_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FirmwareVersion') is not None:
            self.firmware_version = m.get('FirmwareVersion')
        if m.get('ModuleName') is not None:
            self.module_name = m.get('ModuleName')
        return self


class QueryDeviceBySQLResponseBodyDataTags(TeaModel):
    def __init__(
        self,
        tag_name: str = None,
        tag_value: str = None,
    ):
        # The tag key.
        self.tag_name = tag_name
        # The tag value.
        self.tag_value = tag_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag_name is not None:
            result['TagName'] = self.tag_name
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TagName') is not None:
            self.tag_name = m.get('TagName')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        return self


class QueryDeviceBySQLResponseBodyData(TeaModel):
    def __init__(
        self,
        active_time: str = None,
        device_name: str = None,
        gmt_create: str = None,
        gmt_modified: str = None,
        groups: List[QueryDeviceBySQLResponseBodyDataGroups] = None,
        iot_id: str = None,
        nickname: str = None,
        otamodules: List[QueryDeviceBySQLResponseBodyDataOTAModules] = None,
        product_key: str = None,
        status: str = None,
        tags: List[QueryDeviceBySQLResponseBodyDataTags] = None,
    ):
        # The time when the device was activated. The time is in the GMT format.
        self.active_time = active_time
        # The name of the device.
        self.device_name = device_name
        # The time when the device was created. The time is in the GMT format.
        self.gmt_create = gmt_create
        # The time when the device information was last updated. The time is in the GMT format.
        self.gmt_modified = gmt_modified
        # The information about the groups to which the device belongs.
        self.groups = groups
        # The ID of the device. The ID is a unique identifier that is issued by IoT Platform to the device.
        self.iot_id = iot_id
        # The alias of the device.
        self.nickname = nickname
        # The information about the firmware of each device module.
        self.otamodules = otamodules
        # The **ProductKey** of the product to which the device belongs.
        self.product_key = product_key
        # The status of the device. Valid values:
        # 
        # *   **ONLINE**: The device is online.
        # *   **OFFLINE**: The device is offline.
        # *   **UNACTIVE**: The device is not activated.
        # *   **DISABLE**: The device is disabled.
        self.status = status
        # The information about device tags.
        self.tags = tags

    def validate(self):
        if self.groups:
            for k in self.groups:
                if k:
                    k.validate()
        if self.otamodules:
            for k in self.otamodules:
                if k:
                    k.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.active_time is not None:
            result['ActiveTime'] = self.active_time
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        result['Groups'] = []
        if self.groups is not None:
            for k in self.groups:
                result['Groups'].append(k.to_map() if k else None)
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.nickname is not None:
            result['Nickname'] = self.nickname
        result['OTAModules'] = []
        if self.otamodules is not None:
            for k in self.otamodules:
                result['OTAModules'].append(k.to_map() if k else None)
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.status is not None:
            result['Status'] = self.status
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActiveTime') is not None:
            self.active_time = m.get('ActiveTime')
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        self.groups = []
        if m.get('Groups') is not None:
            for k in m.get('Groups'):
                temp_model = QueryDeviceBySQLResponseBodyDataGroups()
                self.groups.append(temp_model.from_map(k))
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('Nickname') is not None:
            self.nickname = m.get('Nickname')
        self.otamodules = []
        if m.get('OTAModules') is not None:
            for k in m.get('OTAModules'):
                temp_model = QueryDeviceBySQLResponseBodyDataOTAModules()
                self.otamodules.append(temp_model.from_map(k))
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = QueryDeviceBySQLResponseBodyDataTags()
                self.tags.append(temp_model.from_map(k))
        return self


class QueryDeviceBySQLResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[QueryDeviceBySQLResponseBodyData] = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The device information returned if the call is successful.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful. Valid values:
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success
        # If you specify `SELECT count(*) FROM device` in the SQL-like statement, the number of rows that match the specified conditions is returned.
        self.total_count = total_count

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = QueryDeviceBySQLResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class QueryDeviceBySQLResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryDeviceBySQLResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryDeviceBySQLResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryDeviceByStatusRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        iot_instance_id: str = None,
        page_size: int = None,
        product_key: str = None,
        resource_group_id: str = None,
        status: int = None,
    ):
        # The number of the page to return.
        self.current_page = current_page
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # 
        # **Important**\
        # 
        # *   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # *   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The number of entries to return on each page. Valid values: 1 to 50.
        self.page_size = page_size
        # The ProductKey of the product to which the device belongs.
        self.product_key = product_key
        # The ID of the resource group to which the product belongs. You can view the resource group ID in the IoT Platform console.
        # 
        # >  If you specify this parameter, the system returns devices of the specified status in the resource group. If you do not specify this parameter, the system returns all devices of the specified status in the current account.
        self.resource_group_id = resource_group_id
        # The status of the devices. Valid values:
        # 
        # *   **0**: inactive
        # *   **1**: online
        # *   **3**: offline
        # *   **8**: disabled
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class QueryDeviceByStatusResponseBodyDataSimpleDeviceInfo(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        device_secret: str = None,
        gmt_create: str = None,
        gmt_modified: str = None,
        iot_id: str = None,
        nickname: str = None,
        product_key: str = None,
        status: str = None,
        utc_create: str = None,
        utc_modified: str = None,
    ):
        # The DeviceName of the device.
        self.device_name = device_name
        # The secret of the device.
        self.device_secret = device_secret
        # The time when the device was created. The time is displayed in UTC.
        self.gmt_create = gmt_create
        # The time when the device information was last modified. The time is displayed in UTC.
        self.gmt_modified = gmt_modified
        # The ID of the device.
        self.iot_id = iot_id
        # The alias of the device.
        self.nickname = nickname
        # The ProductKey of the product to which the device belongs.
        self.product_key = product_key
        # The status of the device. Valid values:
        # 
        # *   **UNACTIVE**: The device is not activated.
        # *   **ONLINE**: The device is online.
        # *   **OFFLINE**: The device is offline.
        # *   **DISABLE**: The device is disabled.
        self.status = status
        # The time when the device was created. The time is displayed in UTC.
        self.utc_create = utc_create
        # The time when the device information was last modified. The time is displayed in UTC.
        self.utc_modified = utc_modified

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.device_secret is not None:
            result['DeviceSecret'] = self.device_secret
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.nickname is not None:
            result['Nickname'] = self.nickname
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.status is not None:
            result['Status'] = self.status
        if self.utc_create is not None:
            result['UtcCreate'] = self.utc_create
        if self.utc_modified is not None:
            result['UtcModified'] = self.utc_modified
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('DeviceSecret') is not None:
            self.device_secret = m.get('DeviceSecret')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('Nickname') is not None:
            self.nickname = m.get('Nickname')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UtcCreate') is not None:
            self.utc_create = m.get('UtcCreate')
        if m.get('UtcModified') is not None:
            self.utc_modified = m.get('UtcModified')
        return self


class QueryDeviceByStatusResponseBodyData(TeaModel):
    def __init__(
        self,
        simple_device_info: List[QueryDeviceByStatusResponseBodyDataSimpleDeviceInfo] = None,
    ):
        self.simple_device_info = simple_device_info

    def validate(self):
        if self.simple_device_info:
            for k in self.simple_device_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SimpleDeviceInfo'] = []
        if self.simple_device_info is not None:
            for k in self.simple_device_info:
                result['SimpleDeviceInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.simple_device_info = []
        if m.get('SimpleDeviceInfo') is not None:
            for k in m.get('SimpleDeviceInfo'):
                temp_model = QueryDeviceByStatusResponseBodyDataSimpleDeviceInfo()
                self.simple_device_info.append(temp_model.from_map(k))
        return self


class QueryDeviceByStatusResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryDeviceByStatusResponseBodyData = None,
        error_message: str = None,
        page: int = None,
        page_count: int = None,
        page_size: int = None,
        request_id: str = None,
        success: bool = None,
        total: int = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The device list information returned if the call succeeds. The **SimpleDeviceInfo** parameter includes the details of the devices.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The number of the returned page.
        self.page = page
        # The total number of pages.
        self.page_count = page_count
        # The number of entries returned per page.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success
        # The total number of devices returned.
        self.total = total

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.page is not None:
            result['Page'] = self.page
        if self.page_count is not None:
            result['PageCount'] = self.page_count
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryDeviceByStatusResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('PageCount') is not None:
            self.page_count = m.get('PageCount')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class QueryDeviceByStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryDeviceByStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryDeviceByStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryDeviceByTagsRequestTag(TeaModel):
    def __init__(
        self,
        tag_key: str = None,
        tag_value: str = None,
    ):
        # The key of the device tag.
        self.tag_key = tag_key
        # The value of the device tag.
        self.tag_value = tag_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        return self


class QueryDeviceByTagsRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        iot_instance_id: str = None,
        page_size: int = None,
        tag: List[QueryDeviceByTagsRequestTag] = None,
    ):
        # The number of the page to return. Default value: 1.
        self.current_page = current_page
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The number of entries to return on each page. Maximum value: 50. Default value: 10.
        self.page_size = page_size
        self.tag = tag

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = QueryDeviceByTagsRequestTag()
                self.tag.append(temp_model.from_map(k))
        return self


class QueryDeviceByTagsResponseBodyDataSimpleDeviceInfo(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        iot_id: str = None,
        product_key: str = None,
        product_name: str = None,
    ):
        # The DeviceName of the device.
        self.device_name = device_name
        # The ID of the device. The ID is the unique identifier that is issued by IoT Platform to the device.
        self.iot_id = iot_id
        # The ProductKey of the product to which the device belongs.
        self.product_key = product_key
        # The name of the product.
        self.product_name = product_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.product_name is not None:
            result['ProductName'] = self.product_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('ProductName') is not None:
            self.product_name = m.get('ProductName')
        return self


class QueryDeviceByTagsResponseBodyData(TeaModel):
    def __init__(
        self,
        simple_device_info: List[QueryDeviceByTagsResponseBodyDataSimpleDeviceInfo] = None,
    ):
        self.simple_device_info = simple_device_info

    def validate(self):
        if self.simple_device_info:
            for k in self.simple_device_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SimpleDeviceInfo'] = []
        if self.simple_device_info is not None:
            for k in self.simple_device_info:
                result['SimpleDeviceInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.simple_device_info = []
        if m.get('SimpleDeviceInfo') is not None:
            for k in m.get('SimpleDeviceInfo'):
                temp_model = QueryDeviceByTagsResponseBodyDataSimpleDeviceInfo()
                self.simple_device_info.append(temp_model.from_map(k))
        return self


class QueryDeviceByTagsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryDeviceByTagsResponseBodyData = None,
        error_message: str = None,
        page: int = None,
        page_count: int = None,
        page_size: int = None,
        request_id: str = None,
        success: bool = None,
        total: int = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The device information returned if the call succeeds. The **SimpleDeviceInfo** parameter includes the details of the devices.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The page number of the returned page.
        self.page = page
        # The total number of pages.
        self.page_count = page_count
        # The number of entries returned on each page.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success
        # The total number of records.
        self.total = total

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.page is not None:
            result['Page'] = self.page
        if self.page_count is not None:
            result['PageCount'] = self.page_count
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryDeviceByTagsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('PageCount') is not None:
            self.page_count = m.get('PageCount')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class QueryDeviceByTagsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryDeviceByTagsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryDeviceByTagsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryDeviceCertRequest(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        iot_instance_id: str = None,
        product_key: str = None,
    ):
        self.device_name = device_name
        self.iot_instance_id = iot_instance_id
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class QueryDeviceCertResponseBodyDeviceCertInfo(TeaModel):
    def __init__(
        self,
        cert_sn: str = None,
        certificate: str = None,
        private_key: str = None,
        status: int = None,
    ):
        self.cert_sn = cert_sn
        self.certificate = certificate
        self.private_key = private_key
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cert_sn is not None:
            result['CertSN'] = self.cert_sn
        if self.certificate is not None:
            result['Certificate'] = self.certificate
        if self.private_key is not None:
            result['PrivateKey'] = self.private_key
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CertSN') is not None:
            self.cert_sn = m.get('CertSN')
        if m.get('Certificate') is not None:
            self.certificate = m.get('Certificate')
        if m.get('PrivateKey') is not None:
            self.private_key = m.get('PrivateKey')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class QueryDeviceCertResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        device_cert_info: QueryDeviceCertResponseBodyDeviceCertInfo = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.device_cert_info = device_cert_info
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.device_cert_info:
            self.device_cert_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.device_cert_info is not None:
            result['DeviceCertInfo'] = self.device_cert_info.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('DeviceCertInfo') is not None:
            temp_model = QueryDeviceCertResponseBodyDeviceCertInfo()
            self.device_cert_info = temp_model.from_map(m['DeviceCertInfo'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryDeviceCertResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryDeviceCertResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryDeviceCertResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryDeviceDesiredPropertyRequest(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        function_block_id: str = None,
        identifier: List[str] = None,
        iot_id: str = None,
        iot_instance_id: str = None,
        product_key: str = None,
    ):
        # The DeviceName of the device.
        # 
        # >  If you specify a value for this parameter, you must configure the **ProductKey** parameter.
        self.device_name = device_name
        # The identifier of the custom TSL module. Each identifier is unique in a product.
        # 
        # If you do not configure this parameter, the system queries the data of the default module.
        self.function_block_id = function_block_id
        self.identifier = identifier
        # The ID of the device. The ID is a unique identifier that is issued by IoT Platform to the device.
        # 
        # >  If you specify a value for this parameter, you do not need to configure the **ProductKey** or **DeviceName** parameter. The **IotId** parameter specifies a GUID for the device. The value of the IotId parameter is equivalent to a combination of the values of the **ProductKey** and **DeviceName** parameters. If you specify values for the **IotId**, **ProductKey**, and **DeviceName** parameters, the value of the **IotId** parameter takes precedence.
        self.iot_id = iot_id
        # The ID of the instance. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.
        # >*   If no **Overview** page or ID is generated for your instance, you do not need configure this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The ProductKey of the product to which the device belongs.
        # 
        # >  If you specify a value for this parameter, you must configure the **DeviceName** parameter.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.function_block_id is not None:
            result['FunctionBlockId'] = self.function_block_id
        if self.identifier is not None:
            result['Identifier'] = self.identifier
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('FunctionBlockId') is not None:
            self.function_block_id = m.get('FunctionBlockId')
        if m.get('Identifier') is not None:
            self.identifier = m.get('Identifier')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class QueryDeviceDesiredPropertyResponseBodyDataListDesiredPropertyInfo(TeaModel):
    def __init__(
        self,
        data_type: str = None,
        identifier: str = None,
        name: str = None,
        time: str = None,
        unit: str = None,
        value: str = None,
        version: int = None,
    ):
        # The data type of the property.
        self.data_type = data_type
        # The identifier of the property.
        self.identifier = identifier
        # The name of the property.
        self.name = name
        # The time when the desired value of the property was last modified. Unit: milliseconds.
        self.time = time
        # The unit of the property.
        self.unit = unit
        # The desired value of the property.
        # 
        # >  If you call the [ClearDeviceDesiredProperty](~~477431~~) operation to delete the desired value of the property, the **Value** parameter is not returned.
        self.value = value
        # The version of the desired value.
        self.version = version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_type is not None:
            result['DataType'] = self.data_type
        if self.identifier is not None:
            result['Identifier'] = self.identifier
        if self.name is not None:
            result['Name'] = self.name
        if self.time is not None:
            result['Time'] = self.time
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataType') is not None:
            self.data_type = m.get('DataType')
        if m.get('Identifier') is not None:
            self.identifier = m.get('Identifier')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Time') is not None:
            self.time = m.get('Time')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class QueryDeviceDesiredPropertyResponseBodyDataList(TeaModel):
    def __init__(
        self,
        desired_property_info: List[QueryDeviceDesiredPropertyResponseBodyDataListDesiredPropertyInfo] = None,
    ):
        self.desired_property_info = desired_property_info

    def validate(self):
        if self.desired_property_info:
            for k in self.desired_property_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DesiredPropertyInfo'] = []
        if self.desired_property_info is not None:
            for k in self.desired_property_info:
                result['DesiredPropertyInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.desired_property_info = []
        if m.get('DesiredPropertyInfo') is not None:
            for k in m.get('DesiredPropertyInfo'):
                temp_model = QueryDeviceDesiredPropertyResponseBodyDataListDesiredPropertyInfo()
                self.desired_property_info.append(temp_model.from_map(k))
        return self


class QueryDeviceDesiredPropertyResponseBodyData(TeaModel):
    def __init__(
        self,
        list: QueryDeviceDesiredPropertyResponseBodyDataList = None,
    ):
        # The desired property information returned in the **DesiredPropertyInfo** parameter.
        self.list = list

    def validate(self):
        if self.list:
            self.list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.list is not None:
            result['List'] = self.list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('List') is not None:
            temp_model = QueryDeviceDesiredPropertyResponseBodyDataList()
            self.list = temp_model.from_map(m['List'])
        return self


class QueryDeviceDesiredPropertyResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryDeviceDesiredPropertyResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The data returned in the **List** parameter if the call is successful.
        self.data = data
        # The error message that is returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryDeviceDesiredPropertyResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryDeviceDesiredPropertyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryDeviceDesiredPropertyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryDeviceDesiredPropertyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryDeviceDetailRequest(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        iot_id: str = None,
        iot_instance_id: str = None,
        product_key: str = None,
    ):
        # The DeviceName of the device.
        # 
        # >  If you specify a value for this parameter, you must also specify a value for the **ProductKey** parameter.
        self.device_name = device_name
        # The ID of the device.
        # 
        # >  If you specify a value for this parameter, you do not need to specify a value for the **ProductKey** or **DeviceName** parameter. The **IotId** parameter specifies a globally unique identifier (GUID) for the device. The value of the IotId parameter corresponds to a combination of the values of the **ProductKey** and **DeviceName** parameters. If you specify a value for the **IotId** parameter and values for the **ProductKey** and **DeviceName** parameters, the value of the **IotId** takes precedence.
        self.iot_id = iot_id
        # The ID of the instance. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.
        # >*   If no **Overview** page or ID is generated for your instance, you do not need to configure this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The ProductKey of the product to which the device belongs.
        # 
        # >  If you specify a value for this parameter, you must also specify a value for the **DeviceName** parameter.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class QueryDeviceDetailResponseBodyData(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        device_secret: str = None,
        firmware_version: str = None,
        gmt_active: str = None,
        gmt_create: str = None,
        gmt_online: str = None,
        iot_id: str = None,
        ip_address: str = None,
        nickname: str = None,
        node_type: int = None,
        owner: bool = None,
        product_key: str = None,
        product_name: str = None,
        region: str = None,
        status: str = None,
        utc_active: str = None,
        utc_create: str = None,
        utc_online: str = None,
    ):
        # The DeviceName of the device.
        self.device_name = device_name
        # The DeviceSecret of the device.
        self.device_secret = device_secret
        # The version number of the default OTA module of the device.
        # 
        # If you want to query the version information about other OTA modules, call the [ListOTAModuleVersionsByDevice](~~190622~~) operation. The version information is submitted by the device.
        self.firmware_version = firmware_version
        # The time when the device was activated. The time is in the GMT format.
        self.gmt_active = gmt_active
        # The time when the device was created. The time is in the GMT format.
        self.gmt_create = gmt_create
        # The most recent time when the device was online. The time is in the GMT format.
        self.gmt_online = gmt_online
        # The ID of the device. The ID is the unique identifier that is issued by IoT Platform to the device.
        self.iot_id = iot_id
        # The IP address of the device.
        self.ip_address = ip_address
        # The alias of the device.
        self.nickname = nickname
        # The type of the node. Valid values:
        # 
        # *   **0**: device. Sub-devices cannot be attached to a device. A device can connect to IoT Platform directly or as a sub-device of a gateway.
        # *   **1**: gateway. Sub-devices can be attached to a gateway. A gateway can manage sub-devices, maintain the topological relationships with sub-devices, and synchronize the topological relationships to IoT Platform.
        self.node_type = node_type
        # Indicates whether the operation is called by the owner of the device.
        self.owner = owner
        # The ProductKey of the product to which the device belongs.
        self.product_key = product_key
        # The name of the product to which the device belongs.
        self.product_name = product_name
        # The ID of the region where the device resides. The region is the same as the region where IoT Platform resides. You can view the region in the IoT Platform console.
        self.region = region
        # The device status. Valid values: Valid values:
        # 
        # *   **ONLINE**: The device is online.
        # *   **OFFLINE**: The device is offline.
        # *   **UNACTIVE**: The device is not activated.
        # *   **DISABLE**: The device is disabled.
        self.status = status
        # The time when the device was activated. The time is in the UTC format.
        self.utc_active = utc_active
        # The time when the device was created. The time is in the UTC format.
        self.utc_create = utc_create
        # The most recent time when the device was online. The time is in the UTC format.
        self.utc_online = utc_online

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.device_secret is not None:
            result['DeviceSecret'] = self.device_secret
        if self.firmware_version is not None:
            result['FirmwareVersion'] = self.firmware_version
        if self.gmt_active is not None:
            result['GmtActive'] = self.gmt_active
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_online is not None:
            result['GmtOnline'] = self.gmt_online
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.ip_address is not None:
            result['IpAddress'] = self.ip_address
        if self.nickname is not None:
            result['Nickname'] = self.nickname
        if self.node_type is not None:
            result['NodeType'] = self.node_type
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.product_name is not None:
            result['ProductName'] = self.product_name
        if self.region is not None:
            result['Region'] = self.region
        if self.status is not None:
            result['Status'] = self.status
        if self.utc_active is not None:
            result['UtcActive'] = self.utc_active
        if self.utc_create is not None:
            result['UtcCreate'] = self.utc_create
        if self.utc_online is not None:
            result['UtcOnline'] = self.utc_online
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('DeviceSecret') is not None:
            self.device_secret = m.get('DeviceSecret')
        if m.get('FirmwareVersion') is not None:
            self.firmware_version = m.get('FirmwareVersion')
        if m.get('GmtActive') is not None:
            self.gmt_active = m.get('GmtActive')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtOnline') is not None:
            self.gmt_online = m.get('GmtOnline')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('IpAddress') is not None:
            self.ip_address = m.get('IpAddress')
        if m.get('Nickname') is not None:
            self.nickname = m.get('Nickname')
        if m.get('NodeType') is not None:
            self.node_type = m.get('NodeType')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('ProductName') is not None:
            self.product_name = m.get('ProductName')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UtcActive') is not None:
            self.utc_active = m.get('UtcActive')
        if m.get('UtcCreate') is not None:
            self.utc_create = m.get('UtcCreate')
        if m.get('UtcOnline') is not None:
            self.utc_online = m.get('UtcOnline')
        return self


class QueryDeviceDetailResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryDeviceDetailResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The device details returned if the call is successful.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryDeviceDetailResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryDeviceDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryDeviceDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryDeviceDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryDeviceDistributeDetailRequest(TeaModel):
    def __init__(
        self,
        job_id: str = None,
    ):
        # The ID of the distribution task. The ID globally identifies the task.
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class QueryDeviceDistributeDetailResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        file: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The URL of the file that contains the distribution result. The URL indicates a storage location of the file in Object Storage Service (OSS). The URL is valid for 10 minutes.
        self.file = file
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.file is not None:
            result['File'] = self.file
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('File') is not None:
            self.file = m.get('File')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryDeviceDistributeDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryDeviceDistributeDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryDeviceDistributeDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryDeviceDistributeJobRequest(TeaModel):
    def __init__(
        self,
        job_id: str = None,
    ):
        # The ID of the distribution task. The ID globally identifies the task.
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigsTargetInstanceConfigs(TeaModel):
    def __init__(
        self,
        target_instance_id: str = None,
    ):
        # The ID of the destination instance.
        self.target_instance_id = target_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.target_instance_id is not None:
            result['TargetInstanceId'] = self.target_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TargetInstanceId') is not None:
            self.target_instance_id = m.get('TargetInstanceId')
        return self


class QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigs(TeaModel):
    def __init__(
        self,
        target_instance_configs: List[QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigsTargetInstanceConfigs] = None,
    ):
        self.target_instance_configs = target_instance_configs

    def validate(self):
        if self.target_instance_configs:
            for k in self.target_instance_configs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['targetInstanceConfigs'] = []
        if self.target_instance_configs is not None:
            for k in self.target_instance_configs:
                result['targetInstanceConfigs'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.target_instance_configs = []
        if m.get('targetInstanceConfigs') is not None:
            for k in m.get('targetInstanceConfigs'):
                temp_model = QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigsTargetInstanceConfigs()
                self.target_instance_configs.append(temp_model.from_map(k))
        return self


class QueryDeviceDistributeJobResponseBodyData(TeaModel):
    def __init__(
        self,
        gmt_create: int = None,
        job_id: str = None,
        product_key: str = None,
        source_instance_id: str = None,
        source_uid: str = None,
        status: int = None,
        strategy: int = None,
        target_instance_configs: QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigs = None,
        target_uid: str = None,
        total: int = None,
    ):
        # The time when the task was created.
        self.gmt_create = gmt_create
        # The ID of the distribution task.
        self.job_id = job_id
        # The **ProductKey** of the product to which the device belongs.
        self.product_key = product_key
        # The ID of the source instance.
        self.source_instance_id = source_instance_id
        # The ID of the Alibaba Cloud account.
        self.source_uid = source_uid
        # The status of the distribution task.
        # 
        # *   **0**: The task is being initialized.
        # *   **1**: The task is being implemented.
        # *   **2**: The task is completed. This status only indicates that the distribution task is completed. This status does not indicate that all products and devices are distributed. To obtain distribution results, call the [QueryDeviceDistributeDetail](~~199533~~) operation.
        # *   **3**: The task is unexpectedly interrupted.
        self.status = status
        # The distribution policy.
        # 
        # *   **0**: distributes devices to instances in a specified region.
        # *   **1**: configures instance IDs in multiple regions and distributes devices to the nearest regions based on the IP addresses of the devices.
        self.strategy = strategy
        # The IDs of the destination instances.
        # 
        # *   If the value of the **Strategy** parameter is **1**, multiple instance IDs exist.
        # *   If the value of the **Strategy** parameter is **0**, only one instance ID exists.
        self.target_instance_configs = target_instance_configs
        self.target_uid = target_uid
        # The total number of devices in the distribution task.
        self.total = total

    def validate(self):
        if self.target_instance_configs:
            self.target_instance_configs.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.source_instance_id is not None:
            result['SourceInstanceId'] = self.source_instance_id
        if self.source_uid is not None:
            result['SourceUid'] = self.source_uid
        if self.status is not None:
            result['Status'] = self.status
        if self.strategy is not None:
            result['Strategy'] = self.strategy
        if self.target_instance_configs is not None:
            result['TargetInstanceConfigs'] = self.target_instance_configs.to_map()
        if self.target_uid is not None:
            result['TargetUid'] = self.target_uid
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('SourceInstanceId') is not None:
            self.source_instance_id = m.get('SourceInstanceId')
        if m.get('SourceUid') is not None:
            self.source_uid = m.get('SourceUid')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Strategy') is not None:
            self.strategy = m.get('Strategy')
        if m.get('TargetInstanceConfigs') is not None:
            temp_model = QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigs()
            self.target_instance_configs = temp_model.from_map(m['TargetInstanceConfigs'])
        if m.get('TargetUid') is not None:
            self.target_uid = m.get('TargetUid')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class QueryDeviceDistributeJobResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryDeviceDistributeJobResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The task information returned if the call is successful.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryDeviceDistributeJobResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryDeviceDistributeJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryDeviceDistributeJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryDeviceDistributeJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryDeviceEventDataRequest(TeaModel):
    def __init__(
        self,
        asc: int = None,
        device_name: str = None,
        end_time: int = None,
        event_type: str = None,
        identifier: str = None,
        iot_id: str = None,
        iot_instance_id: str = None,
        page_size: int = None,
        product_key: str = None,
        start_time: int = None,
    ):
        # The order in which you want to sort the returned event records. Valid values:
        # 
        # *   **0**: in reverse chronological order. This is the default value.
        # *   **1**: in chronological order.
        # 
        # >  If you do not configure this parameter, the default value **0** is used. The system sorts the returned event records in reverse chronological order.
        self.asc = asc
        # The DeviceName of the device.
        # 
        # >  If you specify a value for this parameter, you must also specify a value for the **ProductKey** parameter.
        self.device_name = device_name
        # The end of the time range to query. The value is a 13-digit timestamp in milliseconds. Example: 1516541900303.
        self.end_time = end_time
        # The type of the event that you want to query. Valid values:
        # 
        # *   **info**: Information.
        # *   **alert**: Alert.
        # *   **error**: Error.
        self.event_type = event_type
        # The identifier of the event that you want to query. You can view the event identifier on the Define Feature tab of the Product Details page in the IoT Platform console. You can also call the [QueryThingModel](~~150321~~) operation and view the event identifier in the returned TSL data.
        # 
        # >  If the PowerOff event belongs to a custom module named testFb, this parameter is set to **testFb:PowerOff**.
        # 
        # If you do not specify this parameter, the system queries all event data of the default module and custom modules.
        self.identifier = identifier
        # The ID of the device. The ID is a unique identifier that is issued by IoT Platform to the device.
        # 
        # >  If you specify a value for this parameter, you do not need to specify a value for the **ProductKey** or **DeviceName** parameter. The **IotId** parameter specifies a globally unique identifier (GUID) for the device. The value of the IotId parameter corresponds to a combination of the values of the **ProductKey** and **DeviceName** parameters. If you specify a value for the **IotId** parameter and values for the **ProductKey** and **DeviceName** parameters, the value of the **IotId** parameter takes precedence.
        self.iot_id = iot_id
        # The ID of the instance. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must specify this parameter. Otherwise, the call fails.
        # >*   If the **Overview** page does not appear in the IoT Platform console or no ID is generated for your instance, you do not need to specify this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The number of entries to return on each page. Valid values: 1 to 50. Default value: 10.
        self.page_size = page_size
        # The ProductKey of the product to which the device belongs.
        # 
        # >  If you specify this parameter, you must also specify the **DeviceName** parameter.
        self.product_key = product_key
        # The beginning of the time range to query. The value is a 13-digit timestamp in milliseconds. Example: 1516538300303.
        # 
        # >  You can query the event data only of the most recent 30 days.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asc is not None:
            result['Asc'] = self.asc
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.event_type is not None:
            result['EventType'] = self.event_type
        if self.identifier is not None:
            result['Identifier'] = self.identifier
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Asc') is not None:
            self.asc = m.get('Asc')
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('EventType') is not None:
            self.event_type = m.get('EventType')
        if m.get('Identifier') is not None:
            self.identifier = m.get('Identifier')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class QueryDeviceEventDataResponseBodyDataListEventInfo(TeaModel):
    def __init__(
        self,
        event_type: str = None,
        identifier: str = None,
        name: str = None,
        output_data: str = None,
        time: str = None,
    ):
        # The type of the event. Valid values:
        # 
        # *   **info**: information.
        # *   **alert**: alert.
        # *   **error**: error.
        self.event_type = event_type
        # The identifier of the event.
        self.identifier = identifier
        # The name of the event.
        self.name = name
        # The output parameter of the event. The value is a string in the MAP format.
        self.output_data = output_data
        # The time when the event occurred. The value is a timestamp in milliseconds.
        self.time = time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.event_type is not None:
            result['EventType'] = self.event_type
        if self.identifier is not None:
            result['Identifier'] = self.identifier
        if self.name is not None:
            result['Name'] = self.name
        if self.output_data is not None:
            result['OutputData'] = self.output_data
        if self.time is not None:
            result['Time'] = self.time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EventType') is not None:
            self.event_type = m.get('EventType')
        if m.get('Identifier') is not None:
            self.identifier = m.get('Identifier')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OutputData') is not None:
            self.output_data = m.get('OutputData')
        if m.get('Time') is not None:
            self.time = m.get('Time')
        return self


class QueryDeviceEventDataResponseBodyDataList(TeaModel):
    def __init__(
        self,
        event_info: List[QueryDeviceEventDataResponseBodyDataListEventInfo] = None,
    ):
        self.event_info = event_info

    def validate(self):
        if self.event_info:
            for k in self.event_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['EventInfo'] = []
        if self.event_info is not None:
            for k in self.event_info:
                result['EventInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.event_info = []
        if m.get('EventInfo') is not None:
            for k in m.get('EventInfo'):
                temp_model = QueryDeviceEventDataResponseBodyDataListEventInfo()
                self.event_info.append(temp_model.from_map(k))
        return self


class QueryDeviceEventDataResponseBodyData(TeaModel):
    def __init__(
        self,
        list: QueryDeviceEventDataResponseBodyDataList = None,
        next_time: int = None,
        next_valid: bool = None,
    ):
        # The array of events. Each element represents an event.
        self.list = list
        # The start time of the event records on the next page. The value is a timestamp in milliseconds.  
        # 
        # - If the **Asc** parameter is set to 0, you can specify this value for the **EndTime** parameter when you call this operation again to query the next page of event records.
        # - If the **Asc** parameter is set to 1, you can specify this value for the **StartTime** parameter when you call this operation again to query the next page of event records.
        self.next_time = next_time
        # Indicates whether the next page exists.
        # 
        # *   **true**: The next page exists. The value of the **NextTime** parameter is returned. For more information, see the description of the **NextTime** parameter in this topic.
        # *   **false**: The next page does not exist.
        self.next_valid = next_valid

    def validate(self):
        if self.list:
            self.list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.list is not None:
            result['List'] = self.list.to_map()
        if self.next_time is not None:
            result['NextTime'] = self.next_time
        if self.next_valid is not None:
            result['NextValid'] = self.next_valid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('List') is not None:
            temp_model = QueryDeviceEventDataResponseBodyDataList()
            self.list = temp_model.from_map(m['List'])
        if m.get('NextTime') is not None:
            self.next_time = m.get('NextTime')
        if m.get('NextValid') is not None:
            self.next_valid = m.get('NextValid')
        return self


class QueryDeviceEventDataResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryDeviceEventDataResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The event records returned if the call succeeds.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryDeviceEventDataResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryDeviceEventDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryDeviceEventDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryDeviceEventDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryDeviceFileRequest(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        file_id: str = None,
        iot_id: str = None,
        iot_instance_id: str = None,
        product_key: str = None,
    ):
        # The name of the device.
        # 
        # >  If you specify this parameter, you must also specify the **ProductKey** parameter.
        self.device_name = device_name
        # The ID of the file. You can call the [QueryDeviceFileList](~~112001~~) operation and view the file ID in the response.
        self.file_id = file_id
        # The ID of the device. The device ID is issued by IoT Platform.
        # 
        # >  If you specify this parameter, you do not need to specify **ProductKey** or **DeviceName**. The **IotId** parameter specifies a globally unique identifier (GUID) of the device, which corresponds to a combination of **ProductKey** and **DeviceName**. If you specify both **IotId** and the combination of **ProductKey** and **DeviceName**, **IotId** takes precedence.
        self.iot_id = iot_id
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The ProductKey of the product to which the device belongs.
        # 
        # >  If you specify this parameter, you must also specify the **DeviceName** parameter.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.file_id is not None:
            result['FileId'] = self.file_id
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('FileId') is not None:
            self.file_id = m.get('FileId')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class QueryDeviceFileResponseBodyData(TeaModel):
    def __init__(
        self,
        download_url: str = None,
        file_id: str = None,
        name: str = None,
        size: str = None,
        utc_created_on: str = None,
    ):
        # The download URL of the file.
        self.download_url = download_url
        # The ID of the file.
        self.file_id = file_id
        # The name of the file.
        self.name = name
        # The size of the file. Unit: KB.
        self.size = size
        # The time when the file was created.
        self.utc_created_on = utc_created_on

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.download_url is not None:
            result['DownloadUrl'] = self.download_url
        if self.file_id is not None:
            result['FileId'] = self.file_id
        if self.name is not None:
            result['Name'] = self.name
        if self.size is not None:
            result['Size'] = self.size
        if self.utc_created_on is not None:
            result['UtcCreatedOn'] = self.utc_created_on
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DownloadUrl') is not None:
            self.download_url = m.get('DownloadUrl')
        if m.get('FileId') is not None:
            self.file_id = m.get('FileId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('UtcCreatedOn') is not None:
            self.utc_created_on = m.get('UtcCreatedOn')
        return self


class QueryDeviceFileResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryDeviceFileResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The file information returned if the call succeeds.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryDeviceFileResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryDeviceFileResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryDeviceFileResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryDeviceFileResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryDeviceFileListRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        device_name: str = None,
        iot_id: str = None,
        iot_instance_id: str = None,
        page_size: int = None,
        product_key: str = None,
    ):
        # The number of the page to return. Pages start from page 1. Default value: 1.
        self.current_page = current_page
        # The DeviceName of the device.
        # 
        # >  If you specify this parameter, you must also specify the **ProductKey** parameter.
        self.device_name = device_name
        # The ID of the device. The device ID is issued by IoT Platform.
        # 
        # >  If you specify this parameter, you do not need to specify **ProductKey** or **DeviceName**. The **IotId** parameter specifies a globally unique identifier (GUID) of the device, which corresponds to a combination of **ProductKey** and **DeviceName**. If you specify both **IotId** and the combination of **ProductKey** and **DeviceName**, **IotId** takes precedence.
        self.iot_id = iot_id
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The number of entries to return on each page. Maximum value: 200. Default value: 10.
        self.page_size = page_size
        # The ProductKey of the product to which the device belongs.
        # 
        # >  If you specify this parameter, you must also specify the **DeviceName** parameter.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class QueryDeviceFileListResponseBodyDataFileSummary(TeaModel):
    def __init__(
        self,
        file_id: str = None,
        name: str = None,
        size: str = None,
        utc_created_on: str = None,
    ):
        # The ID of each file. The ID is the unique identifier for the file.
        self.file_id = file_id
        # The name of the file.
        self.name = name
        # The size of the file. Unit: KB.
        self.size = size
        # The time when the file was created.
        self.utc_created_on = utc_created_on

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_id is not None:
            result['FileId'] = self.file_id
        if self.name is not None:
            result['Name'] = self.name
        if self.size is not None:
            result['Size'] = self.size
        if self.utc_created_on is not None:
            result['UtcCreatedOn'] = self.utc_created_on
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileId') is not None:
            self.file_id = m.get('FileId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('UtcCreatedOn') is not None:
            self.utc_created_on = m.get('UtcCreatedOn')
        return self


class QueryDeviceFileListResponseBodyData(TeaModel):
    def __init__(
        self,
        file_summary: List[QueryDeviceFileListResponseBodyDataFileSummary] = None,
    ):
        self.file_summary = file_summary

    def validate(self):
        if self.file_summary:
            for k in self.file_summary:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['FileSummary'] = []
        if self.file_summary is not None:
            for k in self.file_summary:
                result['FileSummary'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.file_summary = []
        if m.get('FileSummary') is not None:
            for k in m.get('FileSummary'):
                temp_model = QueryDeviceFileListResponseBodyDataFileSummary()
                self.file_summary.append(temp_model.from_map(k))
        return self


class QueryDeviceFileListResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        current_page: int = None,
        data: QueryDeviceFileListResponseBodyData = None,
        error_message: str = None,
        page_count: int = None,
        page_size: int = None,
        request_id: str = None,
        success: bool = None,
        total: int = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The number of the returned page.
        self.current_page = current_page
        # The file list information returned if the call succeeds.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The total number of pages.
        self.page_count = page_count
        # The number of entries returned per page.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success
        # The total number of files.
        self.total = total

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.page_count is not None:
            result['PageCount'] = self.page_count
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Data') is not None:
            temp_model = QueryDeviceFileListResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('PageCount') is not None:
            self.page_count = m.get('PageCount')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class QueryDeviceFileListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryDeviceFileListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryDeviceFileListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryDeviceGroupByDeviceRequest(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        iot_instance_id: str = None,
        product_key: str = None,
    ):
        # The DeviceName of the device.
        self.device_name = device_name
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The ProductKey of the product to which the device belongs.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class QueryDeviceGroupByDeviceResponseBodyGroupInfosGroupInfo(TeaModel):
    def __init__(
        self,
        group_desc: str = None,
        group_id: str = None,
        group_name: str = None,
        group_type: str = None,
        utc_create: str = None,
    ):
        # The description of the group.
        self.group_desc = group_desc
        # The ID of the group.
        self.group_id = group_id
        # The name of the group.
        self.group_name = group_name
        # The type of the group.
        self.group_type = group_type
        # The time when the group was created.
        self.utc_create = utc_create

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_desc is not None:
            result['GroupDesc'] = self.group_desc
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.group_type is not None:
            result['GroupType'] = self.group_type
        if self.utc_create is not None:
            result['UtcCreate'] = self.utc_create
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupDesc') is not None:
            self.group_desc = m.get('GroupDesc')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('GroupType') is not None:
            self.group_type = m.get('GroupType')
        if m.get('UtcCreate') is not None:
            self.utc_create = m.get('UtcCreate')
        return self


class QueryDeviceGroupByDeviceResponseBodyGroupInfos(TeaModel):
    def __init__(
        self,
        group_info: List[QueryDeviceGroupByDeviceResponseBodyGroupInfosGroupInfo] = None,
    ):
        self.group_info = group_info

    def validate(self):
        if self.group_info:
            for k in self.group_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['GroupInfo'] = []
        if self.group_info is not None:
            for k in self.group_info:
                result['GroupInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.group_info = []
        if m.get('GroupInfo') is not None:
            for k in m.get('GroupInfo'):
                temp_model = QueryDeviceGroupByDeviceResponseBodyGroupInfosGroupInfo()
                self.group_info.append(temp_model.from_map(k))
        return self


class QueryDeviceGroupByDeviceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        group_infos: QueryDeviceGroupByDeviceResponseBodyGroupInfos = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The group information returned if the call succeeds. For more information, see the following GroupInfo parameter.
        self.group_infos = group_infos
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.group_infos:
            self.group_infos.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.group_infos is not None:
            result['GroupInfos'] = self.group_infos.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('GroupInfos') is not None:
            temp_model = QueryDeviceGroupByDeviceResponseBodyGroupInfos()
            self.group_infos = temp_model.from_map(m['GroupInfos'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryDeviceGroupByDeviceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryDeviceGroupByDeviceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryDeviceGroupByDeviceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryDeviceGroupByTagsRequestTag(TeaModel):
    def __init__(
        self,
        tag_key: str = None,
        tag_value: str = None,
    ):
        # The key of each tag.
        self.tag_key = tag_key
        # The value of the tag.
        self.tag_value = tag_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        return self


class QueryDeviceGroupByTagsRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        iot_instance_id: str = None,
        page_size: int = None,
        tag: List[QueryDeviceGroupByTagsRequestTag] = None,
    ):
        # The number of the page to return. Default value: 1.
        self.current_page = current_page
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The number of entries to return on each page. Default value: 10.
        self.page_size = page_size
        self.tag = tag

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = QueryDeviceGroupByTagsRequestTag()
                self.tag.append(temp_model.from_map(k))
        return self


class QueryDeviceGroupByTagsResponseBodyDataDeviceGroup(TeaModel):
    def __init__(
        self,
        group_id: str = None,
        group_name: str = None,
    ):
        # The ID of the group.
        self.group_id = group_id
        # The name of the group.
        self.group_name = group_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        return self


class QueryDeviceGroupByTagsResponseBodyData(TeaModel):
    def __init__(
        self,
        device_group: List[QueryDeviceGroupByTagsResponseBodyDataDeviceGroup] = None,
    ):
        self.device_group = device_group

    def validate(self):
        if self.device_group:
            for k in self.device_group:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DeviceGroup'] = []
        if self.device_group is not None:
            for k in self.device_group:
                result['DeviceGroup'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.device_group = []
        if m.get('DeviceGroup') is not None:
            for k in m.get('DeviceGroup'):
                temp_model = QueryDeviceGroupByTagsResponseBodyDataDeviceGroup()
                self.device_group.append(temp_model.from_map(k))
        return self


class QueryDeviceGroupByTagsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryDeviceGroupByTagsResponseBodyData = None,
        error_message: str = None,
        page: int = None,
        page_count: int = None,
        page_size: int = None,
        request_id: str = None,
        success: bool = None,
        total: int = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The group information returned if the call succeeds.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The number of the returned page.
        self.page = page
        # The total number of pages.
        self.page_count = page_count
        # The number of entries returned on each page.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success
        # The total number of records.
        self.total = total

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.page is not None:
            result['Page'] = self.page
        if self.page_count is not None:
            result['PageCount'] = self.page_count
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryDeviceGroupByTagsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('PageCount') is not None:
            self.page_count = m.get('PageCount')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class QueryDeviceGroupByTagsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryDeviceGroupByTagsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryDeviceGroupByTagsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryDeviceGroupInfoRequest(TeaModel):
    def __init__(
        self,
        group_id: str = None,
        group_type: str = None,
        iot_instance_id: str = None,
    ):
        # The ID of the group. The ID is the globally unique identifier (GUID) for the group.
        # 
        # You can call the [QueryDeviceGroupList](~~93356~~) operation to query the **GroupId** parameter.
        self.group_id = group_id
        # The type of the group.
        # 
        # Set the value to **LINK_PLATFORM_DYNAMIC**. This value indicates a dynamic group. If you do not specify this parameter, a static group is queried by default.
        self.group_type = group_type
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_type is not None:
            result['GroupType'] = self.group_type
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupType') is not None:
            self.group_type = m.get('GroupType')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class QueryDeviceGroupInfoResponseBodyData(TeaModel):
    def __init__(
        self,
        device_active: int = None,
        device_count: int = None,
        device_online: int = None,
        dynamic_group_expression: str = None,
        group_desc: str = None,
        group_id: str = None,
        group_name: str = None,
        utc_create: str = None,
    ):
        # The number of activated devices.
        self.device_active = device_active
        # The total number of devices.
        self.device_count = device_count
        # The number of online devices.
        self.device_online = device_online
        # The rule of the dynamic group. This parameter is returned if a dynamic group is queried.
        self.dynamic_group_expression = dynamic_group_expression
        # The description of the group.
        self.group_desc = group_desc
        # The ID of the group.
        self.group_id = group_id
        # The name of the group.
        self.group_name = group_name
        # The time when the group was created.
        self.utc_create = utc_create

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_active is not None:
            result['DeviceActive'] = self.device_active
        if self.device_count is not None:
            result['DeviceCount'] = self.device_count
        if self.device_online is not None:
            result['DeviceOnline'] = self.device_online
        if self.dynamic_group_expression is not None:
            result['DynamicGroupExpression'] = self.dynamic_group_expression
        if self.group_desc is not None:
            result['GroupDesc'] = self.group_desc
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.utc_create is not None:
            result['UtcCreate'] = self.utc_create
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceActive') is not None:
            self.device_active = m.get('DeviceActive')
        if m.get('DeviceCount') is not None:
            self.device_count = m.get('DeviceCount')
        if m.get('DeviceOnline') is not None:
            self.device_online = m.get('DeviceOnline')
        if m.get('DynamicGroupExpression') is not None:
            self.dynamic_group_expression = m.get('DynamicGroupExpression')
        if m.get('GroupDesc') is not None:
            self.group_desc = m.get('GroupDesc')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('UtcCreate') is not None:
            self.utc_create = m.get('UtcCreate')
        return self


class QueryDeviceGroupInfoResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryDeviceGroupInfoResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The group details returned if the call succeeds. This parameter includes the following parameters.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryDeviceGroupInfoResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryDeviceGroupInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryDeviceGroupInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryDeviceGroupInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryDeviceGroupListRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        group_name: str = None,
        group_types: List[str] = None,
        iot_instance_id: str = None,
        page_size: int = None,
        super_group_id: str = None,
    ):
        # The number of the page to return. Default value: 1.
        self.current_page = current_page
        # The name of the group.
        # 
        # *   If you specify this parameter, the system queries groups by group name. You can perform a fuzzy search by group name.
        # *   If you do not specify this parameter, the system queries all groups.
        self.group_name = group_name
        self.group_types = group_types
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The number of the entries to return on each page. Maximum value: 200. Default value: 10.
        self.page_size = page_size
        # The ID of the parent group. If you need to query the subgroups of a parent group, specify this parameter.
        self.super_group_id = super_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.group_types is not None:
            result['GroupTypes'] = self.group_types
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.super_group_id is not None:
            result['SuperGroupId'] = self.super_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('GroupTypes') is not None:
            self.group_types = m.get('GroupTypes')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SuperGroupId') is not None:
            self.super_group_id = m.get('SuperGroupId')
        return self


class QueryDeviceGroupListResponseBodyDataGroupInfo(TeaModel):
    def __init__(
        self,
        group_desc: str = None,
        group_id: str = None,
        group_name: str = None,
        group_type: str = None,
        utc_create: str = None,
    ):
        # The description of the group.
        self.group_desc = group_desc
        # The ID of the group.
        self.group_id = group_id
        # The name of the group.
        self.group_name = group_name
        # The type of the group.
        self.group_type = group_type
        # The time when the group was created.
        self.utc_create = utc_create

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_desc is not None:
            result['GroupDesc'] = self.group_desc
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.group_type is not None:
            result['GroupType'] = self.group_type
        if self.utc_create is not None:
            result['UtcCreate'] = self.utc_create
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupDesc') is not None:
            self.group_desc = m.get('GroupDesc')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('GroupType') is not None:
            self.group_type = m.get('GroupType')
        if m.get('UtcCreate') is not None:
            self.utc_create = m.get('UtcCreate')
        return self


class QueryDeviceGroupListResponseBodyData(TeaModel):
    def __init__(
        self,
        group_info: List[QueryDeviceGroupListResponseBodyDataGroupInfo] = None,
    ):
        self.group_info = group_info

    def validate(self):
        if self.group_info:
            for k in self.group_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['GroupInfo'] = []
        if self.group_info is not None:
            for k in self.group_info:
                result['GroupInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.group_info = []
        if m.get('GroupInfo') is not None:
            for k in m.get('GroupInfo'):
                temp_model = QueryDeviceGroupListResponseBodyDataGroupInfo()
                self.group_info.append(temp_model.from_map(k))
        return self


class QueryDeviceGroupListResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        current_page: int = None,
        data: QueryDeviceGroupListResponseBodyData = None,
        error_message: str = None,
        page_count: int = None,
        page_size: int = None,
        request_id: str = None,
        success: bool = None,
        total: int = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The page number of the returned page.
        self.current_page = current_page
        # The group information returned if the call succeeds. For more information, see the GroupInfo parameter.
        # 
        # >  The returned group information is sorted in reverse chronological order in which the groups are created.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The total number of pages.
        self.page_count = page_count
        # The number of entries return on each page.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success
        # The total number of records that were returned.
        self.total = total

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.page_count is not None:
            result['PageCount'] = self.page_count
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Data') is not None:
            temp_model = QueryDeviceGroupListResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('PageCount') is not None:
            self.page_count = m.get('PageCount')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class QueryDeviceGroupListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryDeviceGroupListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryDeviceGroupListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryDeviceGroupTagListRequest(TeaModel):
    def __init__(
        self,
        group_id: str = None,
        group_type: str = None,
        iot_instance_id: str = None,
    ):
        # The ID of the group. The ID is the globally unique identifier (GUID) for the group.
        self.group_id = group_id
        # The type of the group.
        # 
        # If you set the value to **LINK_PLATFORM_DYNAMIC**, a dynamic group is queried. If you do not specify this parameter, a static group is queried by default.
        self.group_type = group_type
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_type is not None:
            result['GroupType'] = self.group_type
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupType') is not None:
            self.group_type = m.get('GroupType')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class QueryDeviceGroupTagListResponseBodyDataGroupTagInfo(TeaModel):
    def __init__(
        self,
        tag_key: str = None,
        tag_value: str = None,
    ):
        # The key of the tag.
        self.tag_key = tag_key
        # The value of the tag.
        self.tag_value = tag_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        return self


class QueryDeviceGroupTagListResponseBodyData(TeaModel):
    def __init__(
        self,
        group_tag_info: List[QueryDeviceGroupTagListResponseBodyDataGroupTagInfo] = None,
    ):
        self.group_tag_info = group_tag_info

    def validate(self):
        if self.group_tag_info:
            for k in self.group_tag_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['GroupTagInfo'] = []
        if self.group_tag_info is not None:
            for k in self.group_tag_info:
                result['GroupTagInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.group_tag_info = []
        if m.get('GroupTagInfo') is not None:
            for k in m.get('GroupTagInfo'):
                temp_model = QueryDeviceGroupTagListResponseBodyDataGroupTagInfo()
                self.group_tag_info.append(temp_model.from_map(k))
        return self


class QueryDeviceGroupTagListResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryDeviceGroupTagListResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The tag information returned if the call succeeds. For more information, see the following **GroupTagInfo** parameter.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryDeviceGroupTagListResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryDeviceGroupTagListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryDeviceGroupTagListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryDeviceGroupTagListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryDeviceInfoRequest(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        iot_id: str = None,
        iot_instance_id: str = None,
        product_key: str = None,
    ):
        # The ID of the device.
        # 
        # > If you specify this parameter, you do not need to specify **ProductKey** or **DeviceName**. The **IotId** parameter specifies a globally unique identifier (GUID) of the device, which corresponds to a combination of **ProductKey** and **DeviceName**. If you specify both **IotId** and the combination of **ProductKey** and **DeviceName**, **IotId** takes precedence.
        self.device_name = device_name
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.iot_id = iot_id
        # The ProductKey of the product to which the device belongs.
        # 
        # > If you specify this parameter, you must also specify the **DeviceName** parameter.
        self.iot_instance_id = iot_instance_id
        # The DeviceName of the device.
        # 
        # > If you specify this parameter, you must also specify the **ProductKey** parameter.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class QueryDeviceInfoResponseBodyData(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        device_secret: str = None,
        iot_id: str = None,
        nickname: str = None,
        product_key: str = None,
    ):
        # The DeviceSecret of the device.
        self.device_name = device_name
        # The ID of the device. The ID is the unique identifier that is issued by IoT Platform to the device.
        self.device_secret = device_secret
        self.iot_id = iot_id
        # The ProductKey of the product to which the device belongs.
        self.nickname = nickname
        # The DeviceName of the device.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.device_secret is not None:
            result['DeviceSecret'] = self.device_secret
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.nickname is not None:
            result['Nickname'] = self.nickname
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('DeviceSecret') is not None:
            self.device_secret = m.get('DeviceSecret')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('Nickname') is not None:
            self.nickname = m.get('Nickname')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class QueryDeviceInfoResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryDeviceInfoResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error message returned if the call fails.
        self.code = code
        # The alias of the device.
        self.data = data
        # The ID of the request.
        self.error_message = error_message
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.request_id = request_id
        # The information about the device returned if the call is successful.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryDeviceInfoResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryDeviceInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryDeviceInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryDeviceInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryDeviceListByDeviceGroupRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        group_id: str = None,
        iot_instance_id: str = None,
        page_size: int = None,
    ):
        # The number of the page to return.
        self.current_page = current_page
        # The ID of the group. The ID is the globally unique identifier (GUID) for the group.
        self.group_id = group_id
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The number of entries to return on each page.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class QueryDeviceListByDeviceGroupResponseBodyDataSimpleDeviceInfo(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        iot_id: str = None,
        product_key: str = None,
        product_name: str = None,
    ):
        # The name of each device.
        self.device_name = device_name
        # The ID of the device. The ID is the unique identifier that is issued by IoT Platform to the device.
        self.iot_id = iot_id
        # The ProductKey of the product to which the device belongs.
        self.product_key = product_key
        # The ProductName of the product to which the device belongs.
        self.product_name = product_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.product_name is not None:
            result['ProductName'] = self.product_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('ProductName') is not None:
            self.product_name = m.get('ProductName')
        return self


class QueryDeviceListByDeviceGroupResponseBodyData(TeaModel):
    def __init__(
        self,
        simple_device_info: List[QueryDeviceListByDeviceGroupResponseBodyDataSimpleDeviceInfo] = None,
    ):
        self.simple_device_info = simple_device_info

    def validate(self):
        if self.simple_device_info:
            for k in self.simple_device_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SimpleDeviceInfo'] = []
        if self.simple_device_info is not None:
            for k in self.simple_device_info:
                result['SimpleDeviceInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.simple_device_info = []
        if m.get('SimpleDeviceInfo') is not None:
            for k in m.get('SimpleDeviceInfo'):
                temp_model = QueryDeviceListByDeviceGroupResponseBodyDataSimpleDeviceInfo()
                self.simple_device_info.append(temp_model.from_map(k))
        return self


class QueryDeviceListByDeviceGroupResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryDeviceListByDeviceGroupResponseBodyData = None,
        error_message: str = None,
        page: int = None,
        page_count: int = None,
        page_size: int = None,
        request_id: str = None,
        success: bool = None,
        total: int = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The device list information returned if the call succeeds. For more information, see the following **SimpleDeviceInfo** parameter.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The number of the returned page.
        self.page = page
        # The total number of pages.
        self.page_count = page_count
        # The number of entries returned per page.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success
        # The total number of devices.
        self.total = total

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.page is not None:
            result['Page'] = self.page
        if self.page_count is not None:
            result['PageCount'] = self.page_count
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryDeviceListByDeviceGroupResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('PageCount') is not None:
            self.page_count = m.get('PageCount')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class QueryDeviceListByDeviceGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryDeviceListByDeviceGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryDeviceListByDeviceGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryDeviceOriginalEventDataRequest(TeaModel):
    def __init__(
        self,
        asc: int = None,
        device_name: str = None,
        end_time: int = None,
        identifier: str = None,
        iot_id: str = None,
        iot_instance_id: str = None,
        next_page_token: str = None,
        page_size: int = None,
        product_key: str = None,
        start_time: int = None,
    ):
        # The sorting order of the returned event records. Value values:
        # 
        # *   0: descending.
        # *   1: ascending.
        self.asc = asc
        # The name of the device.
        # 
        # >  If you specify this parameter, you must also specify the **ProductKey** parameter.
        self.device_name = device_name
        # The end of the time range to query. The value is a 13-digit timestamp in milliseconds.
        self.end_time = end_time
        # The event identifier that you want to query.
        # 
        # *   If low-level verification is applied, you can perform the following steps to view the **Identifier** of a device event: Log on to the IoT Platform console and go to the Define Feature tab of the Product Details page. You can also call the [QueryThingModel](~~150321~~) operation and view the service identifier in the returned TSL data.
        # *   If no verification is applied, the value must be the same as the value of the custom** identifier** that is submitted by the device.
        self.identifier = identifier
        # The ID of the device. It is the unique identifier that IoT Platform generated for the device.
        # 
        # >  If you specify this parameter, you do not need to specify the **ProductKey** or **DeviceName** parameter. The **IotId** parameter specifies a unique identifier for the device, and corresponds to a combination of the **ProductKey** and **DeviceName** parameters. If you specify the **IotId** parameter and the combination of the **ProductKey** and **DeviceName** parameters at the same time, only the **IotId** parameter is used.
        self.iot_id = iot_id
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The identifier of the next page. If the next page exists, this parameter is returned. In this case, you must add the value of the parameter to the next request.
        self.next_page_token = next_page_token
        # The number of entries to return on each page. Valid values: 1 to 50. Default value: 10.
        self.page_size = page_size
        # The **ProductKey** of the product to which the device belongs.
        # 
        # >  If you specify this parameter, you must also specify the **DeviceName** parameter.
        self.product_key = product_key
        # The start of the time range to query. The value is a 13-digit timestamp in milliseconds.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asc is not None:
            result['Asc'] = self.asc
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.identifier is not None:
            result['Identifier'] = self.identifier
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Asc') is not None:
            self.asc = m.get('Asc')
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Identifier') is not None:
            self.identifier = m.get('Identifier')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class QueryDeviceOriginalEventDataResponseBodyDataListEventInfo(TeaModel):
    def __init__(
        self,
        event_type: str = None,
        identifier: str = None,
        name: str = None,
        output_data: str = None,
        time: str = None,
    ):
        # The type of the event. Valid values:
        # 
        # *   info: information.
        # *   alert: alert.
        # *   error: error.
        self.event_type = event_type
        # The identifier of the event.
        self.identifier = identifier
        # The name of the event.
        self.name = name
        # The output parameter of the event. The value is a string in the MAP format.
        self.output_data = output_data
        # The time when the event occurred. The value is a 13-digit timestamp in milliseconds.
        self.time = time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.event_type is not None:
            result['EventType'] = self.event_type
        if self.identifier is not None:
            result['Identifier'] = self.identifier
        if self.name is not None:
            result['Name'] = self.name
        if self.output_data is not None:
            result['OutputData'] = self.output_data
        if self.time is not None:
            result['Time'] = self.time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EventType') is not None:
            self.event_type = m.get('EventType')
        if m.get('Identifier') is not None:
            self.identifier = m.get('Identifier')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OutputData') is not None:
            self.output_data = m.get('OutputData')
        if m.get('Time') is not None:
            self.time = m.get('Time')
        return self


class QueryDeviceOriginalEventDataResponseBodyDataList(TeaModel):
    def __init__(
        self,
        event_info: List[QueryDeviceOriginalEventDataResponseBodyDataListEventInfo] = None,
    ):
        self.event_info = event_info

    def validate(self):
        if self.event_info:
            for k in self.event_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['EventInfo'] = []
        if self.event_info is not None:
            for k in self.event_info:
                result['EventInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.event_info = []
        if m.get('EventInfo') is not None:
            for k in m.get('EventInfo'):
                temp_model = QueryDeviceOriginalEventDataResponseBodyDataListEventInfo()
                self.event_info.append(temp_model.from_map(k))
        return self


class QueryDeviceOriginalEventDataResponseBodyData(TeaModel):
    def __init__(
        self,
        list: QueryDeviceOriginalEventDataResponseBodyDataList = None,
        next_page_token: str = None,
        next_valid: bool = None,
    ):
        # The array of events. Each element represents an event. For more information about the details of the event, see the parameters of the **EventInfo** parameter.
        self.list = list
        # The identifier of the next page.
        self.next_page_token = next_page_token
        # Indicates whether the next page exists.
        # 
        # *   **true**: The next page exists.
        # *   **false**: The next page does not exist.
        # 
        # If the value ******true** is returned, you can add the value of the **NextPageToken** parameter**** to the next request. This allows you to query the data that is not included in the current query.
        self.next_valid = next_valid

    def validate(self):
        if self.list:
            self.list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.list is not None:
            result['List'] = self.list.to_map()
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.next_valid is not None:
            result['NextValid'] = self.next_valid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('List') is not None:
            temp_model = QueryDeviceOriginalEventDataResponseBodyDataList()
            self.list = temp_model.from_map(m['List'])
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('NextValid') is not None:
            self.next_valid = m.get('NextValid')
        return self


class QueryDeviceOriginalEventDataResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryDeviceOriginalEventDataResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The event records returned if the call succeeds.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call succeeds.
        # 
        # *   true: The call succeeded.
        # *   false: The call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryDeviceOriginalEventDataResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryDeviceOriginalEventDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryDeviceOriginalEventDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryDeviceOriginalEventDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryDeviceOriginalPropertyDataRequest(TeaModel):
    def __init__(
        self,
        asc: int = None,
        device_name: str = None,
        end_time: int = None,
        identifier: str = None,
        iot_id: str = None,
        iot_instance_id: str = None,
        next_page_token: str = None,
        page_size: int = None,
        product_key: str = None,
        start_time: int = None,
    ):
        # The order in which you want to sort the returned property records. Valid values:
        # 
        # *   0: descending.
        # *   1: ascending.
        # 
        # >  The **start time** must be earlier than the **end time**. The system sorts the returned records based on the specified order.
        self.asc = asc
        # The DeviceName of the device.
        # 
        # > If you specify a value for this parameter, you must configure the **ProductKey** parameter.
        self.device_name = device_name
        # The end of the time range to query. The value must be a 13-digit timestamp.
        self.end_time = end_time
        # The identifier of the property.
        # 
        # *   If weak verification is used, you can perform the following steps to view the **Identifier** of a device property: Log on to the IoT Platform console and go to the Define Feature tab of the Product Details page. You can also call the [QueryThingModel](~~150321~~) operation and view the property identifier in the returned TSL data.
        # *   If no verification is used, the value must be the same as the custom **identifier** that is submitted by the device.
        self.identifier = identifier
        # The ID of the device. The ID is a unique identifier that is issued by IoT Platform to the device.
        # 
        # > The IotId parameter specifies a unique ID for the device. The value of the **IotId** parameter is equivalent to a combination of the values of the **ProductKey** and **DeviceName.N** parameters. If you specify the IotId parameter, you do not need to configure the **ProductKey** or **DeviceName.N** parameter. If you specify values for the **IotId**, **ProductKey**, and **DeviceName.N** parameters, the value of the **IotId** parameter takes precedence.
        self.iot_id = iot_id
        # The ID of the instance. You can view the ID of the instance on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.****\
        # >*   If no **Overview** page or **ID** is generated for your instance, you do not need to configure this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The token that is used to retrieve the next page of the query results. If the next page exists, this parameter is returned. In this case, you must add the value of the parameter to the next request.
        self.next_page_token = next_page_token
        # The maximum number of records that can be returned for each property. Maximum value: 100.
        # 
        # The number of records that are returned for an arbitrary property cannot exceed the limit.
        self.page_size = page_size
        # The ProductKey of the product to which the device belongs.****\
        # 
        # 
        # 
        # > If you specify a value for this parameter, you must configure the **DeviceName** parameter.
        self.product_key = product_key
        # The start of the time range to query. The value must be a 13-digit timestamp.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asc is not None:
            result['Asc'] = self.asc
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.identifier is not None:
            result['Identifier'] = self.identifier
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Asc') is not None:
            self.asc = m.get('Asc')
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Identifier') is not None:
            self.identifier = m.get('Identifier')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class QueryDeviceOriginalPropertyDataResponseBodyDataListPropertyInfo(TeaModel):
    def __init__(
        self,
        time: str = None,
        value: str = None,
    ):
        # The time when the property was modified.
        self.time = time
        # The value of the property.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.time is not None:
            result['Time'] = self.time
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Time') is not None:
            self.time = m.get('Time')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class QueryDeviceOriginalPropertyDataResponseBodyDataList(TeaModel):
    def __init__(
        self,
        property_info: List[QueryDeviceOriginalPropertyDataResponseBodyDataListPropertyInfo] = None,
    ):
        self.property_info = property_info

    def validate(self):
        if self.property_info:
            for k in self.property_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['PropertyInfo'] = []
        if self.property_info is not None:
            for k in self.property_info:
                result['PropertyInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.property_info = []
        if m.get('PropertyInfo') is not None:
            for k in m.get('PropertyInfo'):
                temp_model = QueryDeviceOriginalPropertyDataResponseBodyDataListPropertyInfo()
                self.property_info.append(temp_model.from_map(k))
        return self


class QueryDeviceOriginalPropertyDataResponseBodyData(TeaModel):
    def __init__(
        self,
        list: QueryDeviceOriginalPropertyDataResponseBodyDataList = None,
        next_valid: bool = None,
        next_page_token: str = None,
    ):
        # The properties. Each element indicates a property.
        self.list = list
        # Indicates whether the next page exists. 
        # 
        # - **true**: The next page exists.
        # - **false**: The next page does not exist.
        # 
        # If **true** is returned for the **NextValid** parameter, you can add the value of the **NextPageToken** parameter to the next request. This way, you can query the data that is not included in the current query.
        self.next_valid = next_valid
        # The token that is used to retrieve the next page of the query results.
        self.next_page_token = next_page_token

    def validate(self):
        if self.list:
            self.list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.list is not None:
            result['List'] = self.list.to_map()
        if self.next_valid is not None:
            result['NextValid'] = self.next_valid
        if self.next_page_token is not None:
            result['nextPageToken'] = self.next_page_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('List') is not None:
            temp_model = QueryDeviceOriginalPropertyDataResponseBodyDataList()
            self.list = temp_model.from_map(m['List'])
        if m.get('NextValid') is not None:
            self.next_valid = m.get('NextValid')
        if m.get('nextPageToken') is not None:
            self.next_page_token = m.get('nextPageToken')
        return self


class QueryDeviceOriginalPropertyDataResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryDeviceOriginalPropertyDataResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The property records returned if the call is successful.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful. Valid values:
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryDeviceOriginalPropertyDataResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryDeviceOriginalPropertyDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryDeviceOriginalPropertyDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryDeviceOriginalPropertyDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryDeviceOriginalPropertyStatusRequest(TeaModel):
    def __init__(
        self,
        asc: int = None,
        device_name: str = None,
        iot_id: str = None,
        iot_instance_id: str = None,
        next_page_token: str = None,
        page_size: int = None,
        product_key: str = None,
    ):
        # The chronological order in which property data is queried. Valid values:
        # 
        # *   0: in reverse chronological order.
        # *   1: in chronological order.
        self.asc = asc
        # The name of the device.
        # 
        # >  If you specify this parameter, you must also specify the **ProductKey** parameter.
        self.device_name = device_name
        # The ID of the device. It is the unique identifier that IoT Platform generated for the device.
        # 
        # >  If you specify this parameter, you do not need to specify the **ProductKey** or **DeviceName** parameter. The **IotId** parameter specifies a unique identifier for the device, and corresponds to a combination of the **ProductKey** and **DeviceName** parameters. If you specify the **IotId** parameter and a combination of the **ProductKey** and **DeviceName** parameters at the same time, the **IotId** parameter takes precedence.
        self.iot_id = iot_id
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The identifier of the next page. If the next page exists, this parameter is returned. In this case, you must add the value of the parameter to the next request.
        self.next_page_token = next_page_token
        # The number of entries to return on each page. Valid values: 1 to 50.
        self.page_size = page_size
        # The **ProductKey** of the product to which the device belongs.
        # 
        # >  If you specify this parameter, you must also specify the **DeviceName** parameter.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asc is not None:
            result['Asc'] = self.asc
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Asc') is not None:
            self.asc = m.get('Asc')
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class QueryDeviceOriginalPropertyStatusResponseBodyDataListPropertyStatusDataInfo(TeaModel):
    def __init__(
        self,
        identifier: str = None,
        time: int = None,
        value: str = None,
    ):
        # The identifier of the property.
        self.identifier = identifier
        # The time when the property was modified, in milliseconds.
        self.time = time
        # The value of the property.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.identifier is not None:
            result['Identifier'] = self.identifier
        if self.time is not None:
            result['Time'] = self.time
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Identifier') is not None:
            self.identifier = m.get('Identifier')
        if m.get('Time') is not None:
            self.time = m.get('Time')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class QueryDeviceOriginalPropertyStatusResponseBodyDataList(TeaModel):
    def __init__(
        self,
        property_status_data_info: List[QueryDeviceOriginalPropertyStatusResponseBodyDataListPropertyStatusDataInfo] = None,
    ):
        self.property_status_data_info = property_status_data_info

    def validate(self):
        if self.property_status_data_info:
            for k in self.property_status_data_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['PropertyStatusDataInfo'] = []
        if self.property_status_data_info is not None:
            for k in self.property_status_data_info:
                result['PropertyStatusDataInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.property_status_data_info = []
        if m.get('PropertyStatusDataInfo') is not None:
            for k in m.get('PropertyStatusDataInfo'):
                temp_model = QueryDeviceOriginalPropertyStatusResponseBodyDataListPropertyStatusDataInfo()
                self.property_status_data_info.append(temp_model.from_map(k))
        return self


class QueryDeviceOriginalPropertyStatusResponseBodyData(TeaModel):
    def __init__(
        self,
        list: QueryDeviceOriginalPropertyStatusResponseBodyDataList = None,
        next_page_token: str = None,
        next_valid: bool = None,
    ):
        # The array of property information. The information about each property is indicated by the **PropertyStatusInfo** parameter.
        self.list = list
        # The identifier of the next page.
        self.next_page_token = next_page_token
        # Indicates whether the next page exists.
        # 
        # *   **true**: The next page exists.
        # *   **false**: The next page does not exist.
        # 
        # If the value ******true** is returned, you can add the value of the **NextPageToken** parameter**** to the next query. This allows you to query the data that is not returned by the current query.
        self.next_valid = next_valid

    def validate(self):
        if self.list:
            self.list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.list is not None:
            result['List'] = self.list.to_map()
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.next_valid is not None:
            result['NextValid'] = self.next_valid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('List') is not None:
            temp_model = QueryDeviceOriginalPropertyStatusResponseBodyDataList()
            self.list = temp_model.from_map(m['List'])
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('NextValid') is not None:
            self.next_valid = m.get('NextValid')
        return self


class QueryDeviceOriginalPropertyStatusResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryDeviceOriginalPropertyStatusResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The data returned if the call succeeds. For more information, see the parameters of the List parameter.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call succeeds.
        # 
        # *   true: The call succeeded.
        # *   false: The call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryDeviceOriginalPropertyStatusResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryDeviceOriginalPropertyStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryDeviceOriginalPropertyStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryDeviceOriginalPropertyStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryDeviceOriginalServiceDataRequest(TeaModel):
    def __init__(
        self,
        asc: int = None,
        device_name: str = None,
        end_time: int = None,
        identifier: str = None,
        iot_id: str = None,
        iot_instance_id: str = None,
        next_page_token: str = None,
        page_size: int = None,
        product_key: str = None,
        start_time: int = None,
    ):
        # The sorting order of the returned service call records. Valid values:
        # 
        # *   0: descending.
        # *   1: ascending.
        # 
        # >  **The start time** must be earlier than **the end time**. The system sorts the returned records based on the specified order.
        self.asc = asc
        # The name of the device.
        # 
        # >  If you specify this parameter, you must also specify the **ProductKey** parameter.
        self.device_name = device_name
        # The end of the time range to query. The value must be a 13-digit timestamp.
        self.end_time = end_time
        # The identifier of the service.
        # 
        # *   If low-level verification is applied, you can perform the following steps to view the **Identifier** of a device event: Log on to the IoT Platform console and go to the Define Feature tab of the Product Details page. You can also call the [QueryThingModel](~~150321~~) operation and view the service identifier in the returned TSL data.
        # *   If no verification is applied, the value must be the same as the value of the custom** identifier** that is submitted by the device.
        self.identifier = identifier
        # The ID of the device. It is the unique identifier that IoT Platform generated for the device.
        # 
        # >  If you specify this parameter, you do not need to specify the **ProductKey** or **DeviceName** parameter. The **IotId** parameter specifies a unique identifier for the device, and corresponds to a combination of the **ProductKey** and **DeviceName** parameters. If you specify the **IotId** parameter and a combination of the **ProductKey** and **DeviceName** parameters at the same time, the **IotId** parameter takes precedence.
        self.iot_id = iot_id
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The identifier of the next page. The response to the first request contains this parameter, which will be added to the next request.
        self.next_page_token = next_page_token
        # The number of entries to return on each page. Maximum value: 50.
        self.page_size = page_size
        # The **ProductKey** of the product to which the device belongs.
        # 
        # >  If you specify this parameter, you must also specify the **DeviceName** parameter.
        self.product_key = product_key
        # The start of the time range to query. The value must be a 13-digit timestamp.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asc is not None:
            result['Asc'] = self.asc
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.identifier is not None:
            result['Identifier'] = self.identifier
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Asc') is not None:
            self.asc = m.get('Asc')
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Identifier') is not None:
            self.identifier = m.get('Identifier')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class QueryDeviceOriginalServiceDataResponseBodyDataListServiceInfo(TeaModel):
    def __init__(
        self,
        identifier: str = None,
        input_data: str = None,
        name: str = None,
        output_data: str = None,
        time: str = None,
    ):
        # The identifier of the service.
        self.identifier = identifier
        # The input parameter of the service. The value is a string in the MAP format. Syntax: key:value.
        self.input_data = input_data
        # The service name.
        self.name = name
        # The output parameter of the service. The value is a string in the MAP format. Syntax: key:value.
        self.output_data = output_data
        # The time when the service was called.
        self.time = time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.identifier is not None:
            result['Identifier'] = self.identifier
        if self.input_data is not None:
            result['InputData'] = self.input_data
        if self.name is not None:
            result['Name'] = self.name
        if self.output_data is not None:
            result['OutputData'] = self.output_data
        if self.time is not None:
            result['Time'] = self.time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Identifier') is not None:
            self.identifier = m.get('Identifier')
        if m.get('InputData') is not None:
            self.input_data = m.get('InputData')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OutputData') is not None:
            self.output_data = m.get('OutputData')
        if m.get('Time') is not None:
            self.time = m.get('Time')
        return self


class QueryDeviceOriginalServiceDataResponseBodyDataList(TeaModel):
    def __init__(
        self,
        service_info: List[QueryDeviceOriginalServiceDataResponseBodyDataListServiceInfo] = None,
    ):
        self.service_info = service_info

    def validate(self):
        if self.service_info:
            for k in self.service_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ServiceInfo'] = []
        if self.service_info is not None:
            for k in self.service_info:
                result['ServiceInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.service_info = []
        if m.get('ServiceInfo') is not None:
            for k in m.get('ServiceInfo'):
                temp_model = QueryDeviceOriginalServiceDataResponseBodyDataListServiceInfo()
                self.service_info.append(temp_model.from_map(k))
        return self


class QueryDeviceOriginalServiceDataResponseBodyData(TeaModel):
    def __init__(
        self,
        list: QueryDeviceOriginalServiceDataResponseBodyDataList = None,
        next_page_token: str = None,
        next_valid: bool = None,
    ):
        # The array of service call records. Each element represents a service call record. For more information about the details of a service, see the parameters that belong to the **ServiceInfo** parameter.
        self.list = list
        # The identifier of the next page.
        self.next_page_token = next_page_token
        # Indicates whether the next page exists.
        # 
        # *   **true**: The next page exists.
        # *   **false**: The next page does not exist.
        # 
        # If the value ******true** is returned, you can add the value of the **NextPageToken** parameter**** to the next request. This allows you to query the data that is not included in the current query.
        self.next_valid = next_valid

    def validate(self):
        if self.list:
            self.list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.list is not None:
            result['List'] = self.list.to_map()
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.next_valid is not None:
            result['NextValid'] = self.next_valid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('List') is not None:
            temp_model = QueryDeviceOriginalServiceDataResponseBodyDataList()
            self.list = temp_model.from_map(m['List'])
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('NextValid') is not None:
            self.next_valid = m.get('NextValid')
        return self


class QueryDeviceOriginalServiceDataResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryDeviceOriginalServiceDataResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The service call records returned if the call succeeds.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call succeeds.
        # 
        # *   true: The call succeeded.
        # *   false: The call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryDeviceOriginalServiceDataResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryDeviceOriginalServiceDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryDeviceOriginalServiceDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryDeviceOriginalServiceDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryDevicePropRequest(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        iot_id: str = None,
        iot_instance_id: str = None,
        product_key: str = None,
    ):
        # The DeviceName of the device.
        # 
        # >  If you specify this parameter, you must also specify the **ProductKey** parameter.
        self.device_name = device_name
        # The ID of the device. The device ID is issued by IoT Platform.
        # 
        # >  If you specify this parameter, you do not need to specify **ProductKey** or **DeviceName**. The **IotId** parameter specifies a globally unique identifier (GUID) of the device, which corresponds to a combination of **ProductKey** and **DeviceName**. If you specify both **IotId** and the combination of **ProductKey** and **DeviceName**, **IotId** takes precedence.
        self.iot_id = iot_id
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # 
        # **Important**\
        # 
        # *   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # *   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The ProductKey of the product to which the device belongs.
        # 
        # >  If you specify this parameter, you must also specify the **DeviceName** parameter.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class QueryDevicePropResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        props: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # A JSON string returned if the call is successful. The JSON string includes the details of the device tags.
        self.props = props
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.props is not None:
            result['Props'] = self.props
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Props') is not None:
            self.props = m.get('Props')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryDevicePropResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryDevicePropResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryDevicePropResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryDevicePropertiesDataRequest(TeaModel):
    def __init__(
        self,
        asc: int = None,
        device_name: str = None,
        end_time: int = None,
        identifier: List[str] = None,
        iot_id: str = None,
        iot_instance_id: str = None,
        page_size: int = None,
        product_key: str = None,
        start_time: int = None,
    ):
        # The sorting order of the returned property records. Valid values:
        # 
        # *   **0**: in reverse chronological order. In this case, the time that is specified by the **StartTime** parameter must be later than the time that is specified by the **EndTime** parameter.
        # *   **1**: in chronological order. In this case, the time that is specified by the **StartTime** parameter must be earlier than the time that is specified by the **EndTime** parameter.
        self.asc = asc
        # The DeviceName of the device.
        self.device_name = device_name
        # The end of the time range to query. The value is a 13-digit timestamp in milliseconds, for example 1579249499000.
        self.end_time = end_time
        self.identifier = identifier
        # The ID of the device. The device ID is issued by IoT Platform.
        # 
        # >  The **IotId** parameter is a globally unique identifier (GUID), and corresponds to a combination of the **ProductKey** and **DeviceName** parameters. If you specify the **IotId** parameter and a combination of the **ProductKey** and **DeviceName** parameters at the same time, the **IotId** parameter is used.
        self.iot_id = iot_id
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The maximum number of records that is returned for each property. Maximum value: 100.
        # 
        # The number of records that are returned for an arbitrary property cannot exceed the limit.
        self.page_size = page_size
        # The ProductKey of the product to which the device belongs.
        self.product_key = product_key
        # The start of the time range to query. The value is a 13-digit timestamp in milliseconds, for example, 1579249499000.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asc is not None:
            result['Asc'] = self.asc
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.identifier is not None:
            result['Identifier'] = self.identifier
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Asc') is not None:
            self.asc = m.get('Asc')
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Identifier') is not None:
            self.identifier = m.get('Identifier')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoListPropertyInfo(TeaModel):
    def __init__(
        self,
        time: int = None,
        value: str = None,
    ):
        # The time when the property was submitted. The value is a timestamp in milliseconds, such as 1579249499000.
        self.time = time
        # The value of the property.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.time is not None:
            result['Time'] = self.time
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Time') is not None:
            self.time = m.get('Time')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoList(TeaModel):
    def __init__(
        self,
        property_info: List[QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoListPropertyInfo] = None,
    ):
        self.property_info = property_info

    def validate(self):
        if self.property_info:
            for k in self.property_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['PropertyInfo'] = []
        if self.property_info is not None:
            for k in self.property_info:
                result['PropertyInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.property_info = []
        if m.get('PropertyInfo') is not None:
            for k in m.get('PropertyInfo'):
                temp_model = QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoListPropertyInfo()
                self.property_info.append(temp_model.from_map(k))
        return self


class QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfo(TeaModel):
    def __init__(
        self,
        identifier: str = None,
        list: QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoList = None,
    ):
        # The identifier of the property.
        self.identifier = identifier
        # The list of property records.
        self.list = list

    def validate(self):
        if self.list:
            self.list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.identifier is not None:
            result['Identifier'] = self.identifier
        if self.list is not None:
            result['List'] = self.list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Identifier') is not None:
            self.identifier = m.get('Identifier')
        if m.get('List') is not None:
            temp_model = QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoList()
            self.list = temp_model.from_map(m['List'])
        return self


class QueryDevicePropertiesDataResponseBodyPropertyDataInfos(TeaModel):
    def __init__(
        self,
        property_data_info: List[QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfo] = None,
    ):
        self.property_data_info = property_data_info

    def validate(self):
        if self.property_data_info:
            for k in self.property_data_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['PropertyDataInfo'] = []
        if self.property_data_info is not None:
            for k in self.property_data_info:
                result['PropertyDataInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.property_data_info = []
        if m.get('PropertyDataInfo') is not None:
            for k in m.get('PropertyDataInfo'):
                temp_model = QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfo()
                self.property_data_info.append(temp_model.from_map(k))
        return self


class QueryDevicePropertiesDataResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        next_time: int = None,
        next_valid: bool = None,
        property_data_infos: QueryDevicePropertiesDataResponseBodyPropertyDataInfos = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The start time to query on the next page.
        # 
        # You can use the value of the **NextTime** parameter as the value of the **StartTime** parameter when you query the next page of results.
        self.next_time = next_time
        # Indicates whether the next page exists.
        # 
        # *   **true**: The next page exists.
        # *   **false**: The next page does not exist.
        # 
        # If the return value of the **NextValid** parameter is **true**, you can use the value of the **NextTime** parameter as the value of the **StartTime** parameter when you query the next page of results.
        self.next_valid = next_valid
        # The list of property records returned if the call is successful. For more information, see **PropertyDataInfo**.
        self.property_data_infos = property_data_infos
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful. 
        # 
        # - **true**: The call was successful.
        # - **false**: The call failed.
        self.success = success

    def validate(self):
        if self.property_data_infos:
            self.property_data_infos.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.next_time is not None:
            result['NextTime'] = self.next_time
        if self.next_valid is not None:
            result['NextValid'] = self.next_valid
        if self.property_data_infos is not None:
            result['PropertyDataInfos'] = self.property_data_infos.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('NextTime') is not None:
            self.next_time = m.get('NextTime')
        if m.get('NextValid') is not None:
            self.next_valid = m.get('NextValid')
        if m.get('PropertyDataInfos') is not None:
            temp_model = QueryDevicePropertiesDataResponseBodyPropertyDataInfos()
            self.property_data_infos = temp_model.from_map(m['PropertyDataInfos'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryDevicePropertiesDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryDevicePropertiesDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryDevicePropertiesDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryDevicePropertyDataRequest(TeaModel):
    def __init__(
        self,
        asc: int = None,
        device_name: str = None,
        end_time: int = None,
        identifier: str = None,
        iot_id: str = None,
        iot_instance_id: str = None,
        page_size: int = None,
        product_key: str = None,
        start_time: int = None,
    ):
        # The order in which you want to sort the property records that are returned. Valid values:
        # 
        # *   **0**: reverse chronological order
        # *   **1**: chronological order
        self.asc = asc
        # The name of the device.
        # 
        # >If you specify a value for this parameter, you must also specify a value for the **ProductKey** parameter.
        self.device_name = device_name
        # The end of the time range to query. The value of the EndTime parameter must be greater than the value of the **StartTime** parameter. The value is a timestamp in milliseconds, for example, 1579249499000.
        self.end_time = end_time
        # The identifier of the property that you want to query.
        # 
        # You can view the property **identifier** on the Define Feature tab of the Product Details page in the IoT Platform console. You can also call the [QueryThingModel](~~150321~~) operation and view the property identifier in the returned TSL data.
        # 
        # >  If a property named temperature belongs to a custom module named testFb, set this parameter to **testFb:temperature**. The custom module is not the default module.
        self.identifier = identifier
        # The ID of the device to which the property belongs.:
        # 
        # You can call the [QueryDeviceInfo](~~257184~~) operation to query the **ID** of the device.
        # 
        # >If you specify a value for this parameter, you do not need to specify a value for the **ProductKey** or **DeviceName** parameter. The **IotId** parameter specifies a globally unique identifier (GUID) for the device. The value of the IotId parameter corresponds to a combination of the values of the **ProductKey** and **DeviceName** parameters. If you specify a value for the **IotId** parameter and values for the **ProductKey** and **DeviceName** parameters, the value of the **IotId** parameter takes precedence.
        self.iot_id = iot_id
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not configure this parameter, the call fails.
        # *   If your instance has no **Overview** page or ID, you do not need to configure this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The number of entries to return on each page. Valid values: 1 to 50.
        self.page_size = page_size
        # The ProductKey of the product to which the device belongs.
        # 
        # >If you specify a value for this parameter, you must also specify a value for the **DeviceName** parameter.
        self.product_key = product_key
        # The start of the time range to query. The value of the StartTime parameter must be less than the value of the **EndTime** parameter. The value is a timestamp in milliseconds, for example, 1579249499000.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asc is not None:
            result['Asc'] = self.asc
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.identifier is not None:
            result['Identifier'] = self.identifier
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Asc') is not None:
            self.asc = m.get('Asc')
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Identifier') is not None:
            self.identifier = m.get('Identifier')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class QueryDevicePropertyDataResponseBodyDataListPropertyInfo(TeaModel):
    def __init__(
        self,
        time: str = None,
        value: str = None,
    ):
        # The time when the property was modified.
        self.time = time
        # The value of the property.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.time is not None:
            result['Time'] = self.time
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Time') is not None:
            self.time = m.get('Time')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class QueryDevicePropertyDataResponseBodyDataList(TeaModel):
    def __init__(
        self,
        property_info: List[QueryDevicePropertyDataResponseBodyDataListPropertyInfo] = None,
    ):
        self.property_info = property_info

    def validate(self):
        if self.property_info:
            for k in self.property_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['PropertyInfo'] = []
        if self.property_info is not None:
            for k in self.property_info:
                result['PropertyInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.property_info = []
        if m.get('PropertyInfo') is not None:
            for k in m.get('PropertyInfo'):
                temp_model = QueryDevicePropertyDataResponseBodyDataListPropertyInfo()
                self.property_info.append(temp_model.from_map(k))
        return self


class QueryDevicePropertyDataResponseBodyData(TeaModel):
    def __init__(
        self,
        list: QueryDevicePropertyDataResponseBodyDataList = None,
        next_time: int = None,
        next_valid: bool = None,
    ):
        # The list of property records.
        self.list = list
        # The start time of the property records on the next page. 
        # 
        # - If the **Asc** parameter is set to **0**, you can specify this value for the **EndTime** parameter when you call this operation again to query the next page of property records.
        # - If the **Asc** parameter is set to **1**, you can specify this value for the **StartTime** parameter when you call this operation again to query the next page of property records.
        self.next_time = next_time
        # Indicates whether the next page exists.
        # 
        # *   **true**: The next page exists. If the return value of the NextValid parameter is true, the value of the **NextTime** parameter is returned. For more information, see the description of the **NextTime** parameter in this topic.
        # *   **false**: The next page does not exist.
        self.next_valid = next_valid

    def validate(self):
        if self.list:
            self.list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.list is not None:
            result['List'] = self.list.to_map()
        if self.next_time is not None:
            result['NextTime'] = self.next_time
        if self.next_valid is not None:
            result['NextValid'] = self.next_valid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('List') is not None:
            temp_model = QueryDevicePropertyDataResponseBodyDataList()
            self.list = temp_model.from_map(m['List'])
        if m.get('NextTime') is not None:
            self.next_time = m.get('NextTime')
        if m.get('NextValid') is not None:
            self.next_valid = m.get('NextValid')
        return self


class QueryDevicePropertyDataResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryDevicePropertyDataResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The property data returned if the call is successful.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryDevicePropertyDataResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryDevicePropertyDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryDevicePropertyDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryDevicePropertyDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryDevicePropertyStatusRequest(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        function_block_id: str = None,
        iot_id: str = None,
        iot_instance_id: str = None,
        product_key: str = None,
    ):
        # The DeviceName of the device.
        # 
        # >If you specify this parameter, you must also specify the **ProductKey** parameter.
        self.device_name = device_name
        # The identifier of the custom TSL module. Each identifier is unique in a product.
        # 
        # If you do not specify this parameter, the system queries the data of the default module.
        self.function_block_id = function_block_id
        # The ID of the device or digital twin node whose property data you want to query.
        # 
        # *   You can call the [QueryDeviceInfo](~~257184~~) operation to query the **ID** of the device.
        # *   Log on to the IoT Platform console. On the **Twin Details** page, click the digital twin node to view its **ID**.
        # 
        # >If you specify this parameter, you do not need to specify the **ProductKey** and **DeviceName** parameters. The **IotId** parameter specifies a globally unique identifier (GUID) for the device. The value of the IotId parameter corresponds to a combination of the values of the **ProductKey** and **DeviceName** parameters. If you specify the **IotId**, **ProductKey**, and **DeviceName** parameters, the value of the **IotId** parameter takes precedence.
        self.iot_id = iot_id
        # The ID of the instance. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.
        # >*   If no **Overview** page or instance ID appears in the console, you do not need to configure this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The ProductKey of the product to which the device belongs.
        # 
        # >If you specify this parameter, you must also specify the **DeviceName** parameter.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.function_block_id is not None:
            result['FunctionBlockId'] = self.function_block_id
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('FunctionBlockId') is not None:
            self.function_block_id = m.get('FunctionBlockId')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class QueryDevicePropertyStatusResponseBodyDataListPropertyStatusInfo(TeaModel):
    def __init__(
        self,
        data_type: str = None,
        identifier: str = None,
        name: str = None,
        time: str = None,
        unit: str = None,
        value: str = None,
    ):
        # The data type of the property. Valid values:
        # 
        # *   **int**: integer
        # *   **float**: single-precision floating-point number
        # *   **double**: double-precision floating-point number
        # *   **enum**: enumeration
        # *   **bool**: Boolean
        # *   **text**: character
        # *   **date**: time (string-type UTC timestamp in milliseconds)
        # *   **array**: array
        # *   **struct**: structure
        self.data_type = data_type
        # The identifier of the property.
        self.identifier = identifier
        # The name of the property.
        self.name = name
        # The time when the property was modified, in milliseconds.
        self.time = time
        # The unit of the property value.
        self.unit = unit
        # The value of the property.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_type is not None:
            result['DataType'] = self.data_type
        if self.identifier is not None:
            result['Identifier'] = self.identifier
        if self.name is not None:
            result['Name'] = self.name
        if self.time is not None:
            result['Time'] = self.time
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataType') is not None:
            self.data_type = m.get('DataType')
        if m.get('Identifier') is not None:
            self.identifier = m.get('Identifier')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Time') is not None:
            self.time = m.get('Time')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class QueryDevicePropertyStatusResponseBodyDataList(TeaModel):
    def __init__(
        self,
        property_status_info: List[QueryDevicePropertyStatusResponseBodyDataListPropertyStatusInfo] = None,
    ):
        self.property_status_info = property_status_info

    def validate(self):
        if self.property_status_info:
            for k in self.property_status_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['PropertyStatusInfo'] = []
        if self.property_status_info is not None:
            for k in self.property_status_info:
                result['PropertyStatusInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.property_status_info = []
        if m.get('PropertyStatusInfo') is not None:
            for k in m.get('PropertyStatusInfo'):
                temp_model = QueryDevicePropertyStatusResponseBodyDataListPropertyStatusInfo()
                self.property_status_info.append(temp_model.from_map(k))
        return self


class QueryDevicePropertyStatusResponseBodyData(TeaModel):
    def __init__(
        self,
        list: QueryDevicePropertyStatusResponseBodyDataList = None,
    ):
        # The array of property information. The information about each property is indicated by the **PropertyStatusInfo** parameter.
        self.list = list

    def validate(self):
        if self.list:
            self.list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.list is not None:
            result['List'] = self.list.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('List') is not None:
            temp_model = QueryDevicePropertyStatusResponseBodyDataList()
            self.list = temp_model.from_map(m['List'])
        return self


class QueryDevicePropertyStatusResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryDevicePropertyStatusResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The data returned if the call succeeds. For more information, see **List**.
        self.data = data
        # The error message returned if the request fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryDevicePropertyStatusResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryDevicePropertyStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryDevicePropertyStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryDevicePropertyStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryDeviceProvisioningRequest(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        product_key: str = None,
    ):
        self.device_name = device_name
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class QueryDeviceProvisioningResponseBodyData(TeaModel):
    def __init__(
        self,
        aliyun_uid: str = None,
        device_name: str = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        product_key: str = None,
        source_iot_instance_id: str = None,
        source_region: str = None,
        target_iot_instance_id: str = None,
        target_region: str = None,
    ):
        self.aliyun_uid = aliyun_uid
        self.device_name = device_name
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.product_key = product_key
        self.source_iot_instance_id = source_iot_instance_id
        self.source_region = source_region
        self.target_iot_instance_id = target_iot_instance_id
        self.target_region = target_region

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_uid is not None:
            result['AliyunUid'] = self.aliyun_uid
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.source_iot_instance_id is not None:
            result['SourceIotInstanceId'] = self.source_iot_instance_id
        if self.source_region is not None:
            result['SourceRegion'] = self.source_region
        if self.target_iot_instance_id is not None:
            result['TargetIotInstanceId'] = self.target_iot_instance_id
        if self.target_region is not None:
            result['TargetRegion'] = self.target_region
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliyunUid') is not None:
            self.aliyun_uid = m.get('AliyunUid')
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('SourceIotInstanceId') is not None:
            self.source_iot_instance_id = m.get('SourceIotInstanceId')
        if m.get('SourceRegion') is not None:
            self.source_region = m.get('SourceRegion')
        if m.get('TargetIotInstanceId') is not None:
            self.target_iot_instance_id = m.get('TargetIotInstanceId')
        if m.get('TargetRegion') is not None:
            self.target_region = m.get('TargetRegion')
        return self


class QueryDeviceProvisioningResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryDeviceProvisioningResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryDeviceProvisioningResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryDeviceProvisioningResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryDeviceProvisioningResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryDeviceProvisioningResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryDeviceServiceDataRequest(TeaModel):
    def __init__(
        self,
        asc: int = None,
        device_name: str = None,
        end_time: int = None,
        identifier: str = None,
        iot_id: str = None,
        iot_instance_id: str = None,
        page_size: int = None,
        product_key: str = None,
        start_time: int = None,
    ):
        # The sorting order of the returned service call records. Valid values:
        # 
        # *   **0**: reverse chronological order
        # *   **1**: chronological order
        self.asc = asc
        # The DeviceName of the device.
        # 
        # > If you specify a value for this parameter, you must configure the **ProductKey** parameter.
        self.device_name = device_name
        # The end of the time range to query. The value is a Unix timestamp. Unit: milliseconds. Example: 1579249499000.
        self.end_time = end_time
        # The identifier of the service. The **identifier** of the service that is called. You can view the service identifier on the Define Feature tab in the IoT Platform console. You can also call the [QueryThingModel](~~150321~~) operation to view the service identifier.
        # 
        # >  If a service named **testService** belongs to a custom module named **testFb**, you can set this parameter to **testFb:testService**. The custom module is not the default module.
        # 
        # If you do not specify a value for this parameter, the system queries all service data of the default module and custom modules.
        self.identifier = identifier
        # The ID of the device. The ID is a unique identifier that is issued by IoT Platform to the device.
        # 
        # > The IotId parameter specifies a GUID for the device. The value of the **IotId** parameter is equivalent to a combination of the values of the **ProductKey** and **DeviceName** parameters. If you specify a value for this parameter, you do not need to configure the **ProductKey** or **DeviceName** parameter. If you specify values for the **IotId**, **ProductKey**, and **DeviceName** parameters, the value of the **IotId** parameter takes precedence.
        self.iot_id = iot_id
        # The ID of the instance. You can view the ID of the instance on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.****\
        # >*   If no **Overview** page or **ID** is generated for your instance, you do not need to configure this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The number of entries to return on each page. Valid values: 1 to 50.
        self.page_size = page_size
        # The ProductKey of the product to which the device belongs.
        # 
        # >If you specify a value for this parameter, you must configure the **DeviceName** parameter.
        self.product_key = product_key
        # The beginning of the time range to query. The value is a Unix timestamp. Unit: milliseconds. Example: 1579249499000.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asc is not None:
            result['Asc'] = self.asc
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.identifier is not None:
            result['Identifier'] = self.identifier
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Asc') is not None:
            self.asc = m.get('Asc')
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Identifier') is not None:
            self.identifier = m.get('Identifier')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class QueryDeviceServiceDataResponseBodyDataListServiceInfo(TeaModel):
    def __init__(
        self,
        identifier: str = None,
        input_data: str = None,
        name: str = None,
        output_data: str = None,
        time: str = None,
    ):
        # The identifier of the service.
        self.identifier = identifier
        # The input parameter of the service. The value is a string in the MAP format. Syntax: `key:value`.
        self.input_data = input_data
        # The name of the service.
        self.name = name
        # The output parameter of the service. The value is a string in the MAP format. Syntax: `key:value`.
        self.output_data = output_data
        # The time when the service was called.
        self.time = time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.identifier is not None:
            result['Identifier'] = self.identifier
        if self.input_data is not None:
            result['InputData'] = self.input_data
        if self.name is not None:
            result['Name'] = self.name
        if self.output_data is not None:
            result['OutputData'] = self.output_data
        if self.time is not None:
            result['Time'] = self.time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Identifier') is not None:
            self.identifier = m.get('Identifier')
        if m.get('InputData') is not None:
            self.input_data = m.get('InputData')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OutputData') is not None:
            self.output_data = m.get('OutputData')
        if m.get('Time') is not None:
            self.time = m.get('Time')
        return self


class QueryDeviceServiceDataResponseBodyDataList(TeaModel):
    def __init__(
        self,
        service_info: List[QueryDeviceServiceDataResponseBodyDataListServiceInfo] = None,
    ):
        self.service_info = service_info

    def validate(self):
        if self.service_info:
            for k in self.service_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ServiceInfo'] = []
        if self.service_info is not None:
            for k in self.service_info:
                result['ServiceInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.service_info = []
        if m.get('ServiceInfo') is not None:
            for k in m.get('ServiceInfo'):
                temp_model = QueryDeviceServiceDataResponseBodyDataListServiceInfo()
                self.service_info.append(temp_model.from_map(k))
        return self


class QueryDeviceServiceDataResponseBodyData(TeaModel):
    def __init__(
        self,
        list: QueryDeviceServiceDataResponseBodyDataList = None,
        next_time: int = None,
        next_valid: bool = None,
    ):
        # The array of service call records. Each element represents a service call record.
        self.list = list
        # The start time of service call records on the next page. 
        # 
        # If you call the QueryDeviceServiceData operation to query the service call records on the next page, you must set the **StartTime** parameter to the value of this parameter.
        self.next_time = next_time
        # Indicates whether the next page exists.
        # 
        # *   **true**\
        # *   **false**\
        # 
        # If the return value of the **NextValid** parameter is **true**, you can use the value of the **NextTime** parameter as the value of the **StartTime** parameter when you query the next page of results.
        self.next_valid = next_valid

    def validate(self):
        if self.list:
            self.list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.list is not None:
            result['List'] = self.list.to_map()
        if self.next_time is not None:
            result['NextTime'] = self.next_time
        if self.next_valid is not None:
            result['NextValid'] = self.next_valid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('List') is not None:
            temp_model = QueryDeviceServiceDataResponseBodyDataList()
            self.list = temp_model.from_map(m['List'])
        if m.get('NextTime') is not None:
            self.next_time = m.get('NextTime')
        if m.get('NextValid') is not None:
            self.next_valid = m.get('NextValid')
        return self


class QueryDeviceServiceDataResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryDeviceServiceDataResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code that is returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The service call records returned if the call is successful.
        self.data = data
        # The error message that is returned if the call fails.
        self.error_message = error_message
        # The ID of the request. The ID uniquely identifies the request.
        self.request_id = request_id
        # Indicates whether the call was successful. Valid values:
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryDeviceServiceDataResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryDeviceServiceDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryDeviceServiceDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryDeviceServiceDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryDeviceSpeechRequest(TeaModel):
    def __init__(
        self,
        iot_id: str = None,
        iot_instance_id: str = None,
        page_id: int = None,
        page_size: int = None,
    ):
        self.iot_id = iot_id
        self.iot_instance_id = iot_instance_id
        self.page_id = page_id
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.page_id is not None:
            result['PageId'] = self.page_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('PageId') is not None:
            self.page_id = m.get('PageId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class QueryDeviceSpeechResponseBodyDataListItems(TeaModel):
    def __init__(
        self,
        audio_format: str = None,
        biz_code: str = None,
        size: float = None,
    ):
        self.audio_format = audio_format
        self.biz_code = biz_code
        self.size = size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_format is not None:
            result['AudioFormat'] = self.audio_format
        if self.biz_code is not None:
            result['BizCode'] = self.biz_code
        if self.size is not None:
            result['Size'] = self.size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioFormat') is not None:
            self.audio_format = m.get('AudioFormat')
        if m.get('BizCode') is not None:
            self.biz_code = m.get('BizCode')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        return self


class QueryDeviceSpeechResponseBodyDataList(TeaModel):
    def __init__(
        self,
        items: List[QueryDeviceSpeechResponseBodyDataListItems] = None,
    ):
        self.items = items

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Items'] = []
        if self.items is not None:
            for k in self.items:
                result['Items'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('Items') is not None:
            for k in m.get('Items'):
                temp_model = QueryDeviceSpeechResponseBodyDataListItems()
                self.items.append(temp_model.from_map(k))
        return self


class QueryDeviceSpeechResponseBodyData(TeaModel):
    def __init__(
        self,
        list: QueryDeviceSpeechResponseBodyDataList = None,
        page_id: int = None,
        page_size: int = None,
        total: int = None,
    ):
        self.list = list
        self.page_id = page_id
        self.page_size = page_size
        self.total = total

    def validate(self):
        if self.list:
            self.list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.list is not None:
            result['List'] = self.list.to_map()
        if self.page_id is not None:
            result['PageId'] = self.page_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('List') is not None:
            temp_model = QueryDeviceSpeechResponseBodyDataList()
            self.list = temp_model.from_map(m['List'])
        if m.get('PageId') is not None:
            self.page_id = m.get('PageId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class QueryDeviceSpeechResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryDeviceSpeechResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryDeviceSpeechResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryDeviceSpeechResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryDeviceSpeechResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryDeviceSpeechResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryDeviceStatisticsRequest(TeaModel):
    def __init__(
        self,
        group_id: str = None,
        iot_instance_id: str = None,
        product_key: str = None,
    ):
        # The ID of the group to which the devices belong.
        # 
        # *   If you specify this parameter, the statistics of the devices that are added to the group is returned. If you also specify **ProductKey**, the statistics of the devices that are created under the product and added to the group is returned.
        # *   If you do not specify this parameter and **ProductKey**, the statistics of all devices within the current account is returned.
        self.group_id = group_id
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The ProductKey of the product to which the devices belong.
        # 
        # *   If you specify this parameter, the statistics of the devices under the product is returned. If you also specify **GroupId**, the statistics of the devices that are created under the product and added to the group is returned.
        # *   If you do not specify this parameter and **GroupId**, the statistics of all devices within the current account is returned.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class QueryDeviceStatisticsResponseBodyData(TeaModel):
    def __init__(
        self,
        active_count: int = None,
        device_count: int = None,
        online_count: int = None,
    ):
        # The number of activated devices.
        self.active_count = active_count
        # The total number of devices.
        self.device_count = device_count
        # The number of online devices.
        self.online_count = online_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.active_count is not None:
            result['activeCount'] = self.active_count
        if self.device_count is not None:
            result['deviceCount'] = self.device_count
        if self.online_count is not None:
            result['onlineCount'] = self.online_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('activeCount') is not None:
            self.active_count = m.get('activeCount')
        if m.get('deviceCount') is not None:
            self.device_count = m.get('deviceCount')
        if m.get('onlineCount') is not None:
            self.online_count = m.get('onlineCount')
        return self


class QueryDeviceStatisticsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryDeviceStatisticsResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The device statistics returned if the call is successful.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryDeviceStatisticsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryDeviceStatisticsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryDeviceStatisticsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryDeviceStatisticsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryDeviceSubTopicRequest(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        iot_instance_id: str = None,
        product_key: str = None,
    ):
        # The name of the device.
        # 
        # You can use the IoT Platform console or call the [QueryDeviceInfo](~~257184~~) operation to view the information about the device.
        self.device_name = device_name
        # The ID of the instance. You can view the ID of an instance on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must specify the ID for this parameter. If you do not specify the instance ID, the call fails.
        # >*   If the **Overview** page or instance ID is not displayed in the IoT Platform console, you do not need to configure this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The ProductKey of the product to which the device belongs.
        # 
        # You can use the IoT Platform console or call the [QueryProductList](~~69271~~) operation to view the information about all products within the current Alibaba Cloud account.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class QueryDeviceSubTopicResponseBodyTopicList(TeaModel):
    def __init__(
        self,
        timestamp: int = None,
        topic_name: str = None,
    ):
        # The time when the device subscribed to a topic. Unit: milliseconds.
        self.timestamp = timestamp
        # The name of the topic.
        self.topic_name = topic_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        if self.topic_name is not None:
            result['TopicName'] = self.topic_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        if m.get('TopicName') is not None:
            self.topic_name = m.get('TopicName')
        return self


class QueryDeviceSubTopicResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        topic_list: List[QueryDeviceSubTopicResponseBodyTopicList] = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request. The ID uniquely identifies this request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success
        # The information about the topics to which the device has subscribed. This parameter is returned if the call was successful.
        self.topic_list = topic_list

    def validate(self):
        if self.topic_list:
            for k in self.topic_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        result['TopicList'] = []
        if self.topic_list is not None:
            for k in self.topic_list:
                result['TopicList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        self.topic_list = []
        if m.get('TopicList') is not None:
            for k in m.get('TopicList'):
                temp_model = QueryDeviceSubTopicResponseBodyTopicList()
                self.topic_list.append(temp_model.from_map(k))
        return self


class QueryDeviceSubTopicResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryDeviceSubTopicResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryDeviceSubTopicResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryDeviceTunnelRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        tunnel_id: str = None,
    ):
        self.iot_instance_id = iot_instance_id
        self.tunnel_id = tunnel_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.tunnel_id is not None:
            result['TunnelId'] = self.tunnel_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('TunnelId') is not None:
            self.tunnel_id = m.get('TunnelId')
        return self


class QueryDeviceTunnelResponseBodyData(TeaModel):
    def __init__(
        self,
        description: str = None,
        device_conn_state: str = None,
        device_name: str = None,
        iot_id: str = None,
        product_key: str = None,
        product_name: str = None,
        source_conn_state: str = None,
        tunnel_id: str = None,
        tunnel_state: str = None,
        udi: str = None,
        utc_closed: str = None,
        utc_created: str = None,
    ):
        self.description = description
        self.device_conn_state = device_conn_state
        self.device_name = device_name
        self.iot_id = iot_id
        self.product_key = product_key
        self.product_name = product_name
        self.source_conn_state = source_conn_state
        self.tunnel_id = tunnel_id
        self.tunnel_state = tunnel_state
        self.udi = udi
        self.utc_closed = utc_closed
        self.utc_created = utc_created

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.device_conn_state is not None:
            result['DeviceConnState'] = self.device_conn_state
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.product_name is not None:
            result['ProductName'] = self.product_name
        if self.source_conn_state is not None:
            result['SourceConnState'] = self.source_conn_state
        if self.tunnel_id is not None:
            result['TunnelId'] = self.tunnel_id
        if self.tunnel_state is not None:
            result['TunnelState'] = self.tunnel_state
        if self.udi is not None:
            result['Udi'] = self.udi
        if self.utc_closed is not None:
            result['UtcClosed'] = self.utc_closed
        if self.utc_created is not None:
            result['UtcCreated'] = self.utc_created
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DeviceConnState') is not None:
            self.device_conn_state = m.get('DeviceConnState')
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('ProductName') is not None:
            self.product_name = m.get('ProductName')
        if m.get('SourceConnState') is not None:
            self.source_conn_state = m.get('SourceConnState')
        if m.get('TunnelId') is not None:
            self.tunnel_id = m.get('TunnelId')
        if m.get('TunnelState') is not None:
            self.tunnel_state = m.get('TunnelState')
        if m.get('Udi') is not None:
            self.udi = m.get('Udi')
        if m.get('UtcClosed') is not None:
            self.utc_closed = m.get('UtcClosed')
        if m.get('UtcCreated') is not None:
            self.utc_created = m.get('UtcCreated')
        return self


class QueryDeviceTunnelResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryDeviceTunnelResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryDeviceTunnelResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryDeviceTunnelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryDeviceTunnelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryDeviceTunnelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryDevicesHotStorageDataRequest(TeaModel):
    def __init__(
        self,
        asc: int = None,
        device_name: str = None,
        end_time: int = None,
        identifier: str = None,
        iot_id: str = None,
        iot_instance_id: str = None,
        next_page_token: str = None,
        page_size: int = None,
        product_key: str = None,
        start_time: int = None,
        user_topic: str = None,
    ):
        self.asc = asc
        self.device_name = device_name
        self.end_time = end_time
        self.identifier = identifier
        self.iot_id = iot_id
        self.iot_instance_id = iot_instance_id
        self.next_page_token = next_page_token
        self.page_size = page_size
        self.product_key = product_key
        self.start_time = start_time
        self.user_topic = user_topic

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asc is not None:
            result['Asc'] = self.asc
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.identifier is not None:
            result['Identifier'] = self.identifier
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.user_topic is not None:
            result['UserTopic'] = self.user_topic
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Asc') is not None:
            self.asc = m.get('Asc')
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Identifier') is not None:
            self.identifier = m.get('Identifier')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('UserTopic') is not None:
            self.user_topic = m.get('UserTopic')
        return self


class QueryDevicesHotStorageDataResponseBodyDataListPropertyInfo(TeaModel):
    def __init__(
        self,
        time: str = None,
        value: str = None,
    ):
        self.time = time
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.time is not None:
            result['Time'] = self.time
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Time') is not None:
            self.time = m.get('Time')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class QueryDevicesHotStorageDataResponseBodyDataList(TeaModel):
    def __init__(
        self,
        property_info: List[QueryDevicesHotStorageDataResponseBodyDataListPropertyInfo] = None,
    ):
        self.property_info = property_info

    def validate(self):
        if self.property_info:
            for k in self.property_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['PropertyInfo'] = []
        if self.property_info is not None:
            for k in self.property_info:
                result['PropertyInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.property_info = []
        if m.get('PropertyInfo') is not None:
            for k in m.get('PropertyInfo'):
                temp_model = QueryDevicesHotStorageDataResponseBodyDataListPropertyInfo()
                self.property_info.append(temp_model.from_map(k))
        return self


class QueryDevicesHotStorageDataResponseBodyData(TeaModel):
    def __init__(
        self,
        list: QueryDevicesHotStorageDataResponseBodyDataList = None,
        next_valid: bool = None,
        next_page_token: str = None,
    ):
        self.list = list
        self.next_valid = next_valid
        self.next_page_token = next_page_token

    def validate(self):
        if self.list:
            self.list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.list is not None:
            result['List'] = self.list.to_map()
        if self.next_valid is not None:
            result['NextValid'] = self.next_valid
        if self.next_page_token is not None:
            result['nextPageToken'] = self.next_page_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('List') is not None:
            temp_model = QueryDevicesHotStorageDataResponseBodyDataList()
            self.list = temp_model.from_map(m['List'])
        if m.get('NextValid') is not None:
            self.next_valid = m.get('NextValid')
        if m.get('nextPageToken') is not None:
            self.next_page_token = m.get('nextPageToken')
        return self


class QueryDevicesHotStorageDataResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryDevicesHotStorageDataResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryDevicesHotStorageDataResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryDevicesHotStorageDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryDevicesHotStorageDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryDevicesHotStorageDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryDevicesHotStorageDataStatusRequest(TeaModel):
    def __init__(
        self,
        asc: int = None,
        device_name: str = None,
        iot_id: str = None,
        iot_instance_id: str = None,
        next_page_token: str = None,
        page_size: int = None,
        product_key: str = None,
        user_topic: str = None,
    ):
        self.asc = asc
        self.device_name = device_name
        self.iot_id = iot_id
        self.iot_instance_id = iot_instance_id
        self.next_page_token = next_page_token
        self.page_size = page_size
        self.product_key = product_key
        self.user_topic = user_topic

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asc is not None:
            result['Asc'] = self.asc
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.user_topic is not None:
            result['UserTopic'] = self.user_topic
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Asc') is not None:
            self.asc = m.get('Asc')
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('UserTopic') is not None:
            self.user_topic = m.get('UserTopic')
        return self


class QueryDevicesHotStorageDataStatusResponseBodyDataListPropertyStatusDataInfo(TeaModel):
    def __init__(
        self,
        identifier: str = None,
        time: int = None,
        value: str = None,
    ):
        self.identifier = identifier
        self.time = time
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.identifier is not None:
            result['Identifier'] = self.identifier
        if self.time is not None:
            result['Time'] = self.time
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Identifier') is not None:
            self.identifier = m.get('Identifier')
        if m.get('Time') is not None:
            self.time = m.get('Time')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class QueryDevicesHotStorageDataStatusResponseBodyDataList(TeaModel):
    def __init__(
        self,
        property_status_data_info: List[QueryDevicesHotStorageDataStatusResponseBodyDataListPropertyStatusDataInfo] = None,
    ):
        self.property_status_data_info = property_status_data_info

    def validate(self):
        if self.property_status_data_info:
            for k in self.property_status_data_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['PropertyStatusDataInfo'] = []
        if self.property_status_data_info is not None:
            for k in self.property_status_data_info:
                result['PropertyStatusDataInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.property_status_data_info = []
        if m.get('PropertyStatusDataInfo') is not None:
            for k in m.get('PropertyStatusDataInfo'):
                temp_model = QueryDevicesHotStorageDataStatusResponseBodyDataListPropertyStatusDataInfo()
                self.property_status_data_info.append(temp_model.from_map(k))
        return self


class QueryDevicesHotStorageDataStatusResponseBodyData(TeaModel):
    def __init__(
        self,
        list: QueryDevicesHotStorageDataStatusResponseBodyDataList = None,
        next_page_token: str = None,
        next_valid: bool = None,
    ):
        self.list = list
        self.next_page_token = next_page_token
        self.next_valid = next_valid

    def validate(self):
        if self.list:
            self.list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.list is not None:
            result['List'] = self.list.to_map()
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.next_valid is not None:
            result['NextValid'] = self.next_valid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('List') is not None:
            temp_model = QueryDevicesHotStorageDataStatusResponseBodyDataList()
            self.list = temp_model.from_map(m['List'])
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('NextValid') is not None:
            self.next_valid = m.get('NextValid')
        return self


class QueryDevicesHotStorageDataStatusResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryDevicesHotStorageDataStatusResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryDevicesHotStorageDataStatusResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryDevicesHotStorageDataStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryDevicesHotStorageDataStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryDevicesHotStorageDataStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryDynamicGroupDevicesRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        device_name: str = None,
        fuzzy_name: bool = None,
        group_id: str = None,
        iot_instance_id: str = None,
        next_token: str = None,
        page_size: int = None,
        product_key: str = None,
        status: str = None,
    ):
        # The page number. Default value: 1.
        self.current_page = current_page
        # The DeviceName of the device.
        # 
        # If you specify this parameter and set **FuzzyName** to **true**, the value you specified is used as the prefix to fuzzy match the DeviceName. The value must be at least 4 characters in length.
        self.device_name = device_name
        # Specifies whether to fuzzy match devices by the value of the **DeviceName** parameter. Valid values:
        # 
        # *   **true**\
        # *   **false** (default)
        self.fuzzy_name = fuzzy_name
        # The ID of the group. The ID is the globally unique identifier (GUID) for the group.
        # 
        # You can call the [QueryDeviceGroupList](~~93356~~) operation to query the **GroupId** parameter.
        self.group_id = group_id
        # The instance ID. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
        self.iot_instance_id = iot_instance_id
        # The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request.
        self.next_token = next_token
        # The number of entries per page. Valid values: 1 to 200. Default value: 10.
        self.page_size = page_size
        # The **ProductKey** of the product to which the devices belong.
        self.product_key = product_key
        # The device status. Valid values:
        # 
        # *   **ONLINE**: The device is online.
        # *   **OFFLINE**: The device is offline.
        # *   **UNACTIVE**: The device is not activated.
        # *   **DISABLE**: The device is deactivated.
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.fuzzy_name is not None:
            result['FuzzyName'] = self.fuzzy_name
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('FuzzyName') is not None:
            self.fuzzy_name = m.get('FuzzyName')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class QueryDynamicGroupDevicesResponseBodyDataSimpleDeviceInfo(TeaModel):
    def __init__(
        self,
        active_time: str = None,
        category_key: str = None,
        device_name: str = None,
        iot_id: str = None,
        last_online_time: str = None,
        nickname: str = None,
        node_type: int = None,
        product_key: str = None,
        product_name: str = None,
        status: str = None,
        utc_active_time: str = None,
        utc_last_online_time: str = None,
    ):
        # The time when the device was activated.
        self.active_time = active_time
        # The identifier of the category to which the product belongs.
        # 
        # This parameter is returned if the product uses the Thing Specification Language (TSL) model of a standard category that is pre-defined by IoT Platform.
        self.category_key = category_key
        # The DeviceName of the device.
        self.device_name = device_name
        # The ID of the device. The ID is a unique identifier that is issued by IoT Platform to the device.
        self.iot_id = iot_id
        # The last time when the device went online.
        self.last_online_time = last_online_time
        # The alias of the device.
        self.nickname = nickname
        # The node type of the product. Valid values:
        # 
        # *   **0**: device. A device can connect to IoT Platform directly, or be attached to a gateway as a sub-device and then connect to IoT Platform. Sub-devices cannot be attached to a device.
        # *   **1**: gateway. Sub-devices can be attached to a gateway. A gateway can manage sub-devices, maintain topological relationships with sub-devices, and synchronize topological relationships to IoT Platform.
        self.node_type = node_type
        # The **ProductKey** of the product to which the device belongs.
        self.product_key = product_key
        # The ProductName of the product to which the device belongs.
        self.product_name = product_name
        # The device status. Valid values:
        # 
        # *   **ONLINE**: The device is online.
        # *   **OFFLINE**: The device is offline.
        # *   **UNACTIVE**: The device is not activated.
        # *   **DISABLE**: The device is deactivated.
        self.status = status
        # The time when the device was activated. The time is in the UTC format.
        self.utc_active_time = utc_active_time
        # The last time when the device went online. The time is in the UTC format.
        self.utc_last_online_time = utc_last_online_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.active_time is not None:
            result['ActiveTime'] = self.active_time
        if self.category_key is not None:
            result['CategoryKey'] = self.category_key
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.last_online_time is not None:
            result['LastOnlineTime'] = self.last_online_time
        if self.nickname is not None:
            result['Nickname'] = self.nickname
        if self.node_type is not None:
            result['NodeType'] = self.node_type
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.product_name is not None:
            result['ProductName'] = self.product_name
        if self.status is not None:
            result['Status'] = self.status
        if self.utc_active_time is not None:
            result['UtcActiveTime'] = self.utc_active_time
        if self.utc_last_online_time is not None:
            result['UtcLastOnlineTime'] = self.utc_last_online_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActiveTime') is not None:
            self.active_time = m.get('ActiveTime')
        if m.get('CategoryKey') is not None:
            self.category_key = m.get('CategoryKey')
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('LastOnlineTime') is not None:
            self.last_online_time = m.get('LastOnlineTime')
        if m.get('Nickname') is not None:
            self.nickname = m.get('Nickname')
        if m.get('NodeType') is not None:
            self.node_type = m.get('NodeType')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('ProductName') is not None:
            self.product_name = m.get('ProductName')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UtcActiveTime') is not None:
            self.utc_active_time = m.get('UtcActiveTime')
        if m.get('UtcLastOnlineTime') is not None:
            self.utc_last_online_time = m.get('UtcLastOnlineTime')
        return self


class QueryDynamicGroupDevicesResponseBodyData(TeaModel):
    def __init__(
        self,
        simple_device_info: List[QueryDynamicGroupDevicesResponseBodyDataSimpleDeviceInfo] = None,
    ):
        self.simple_device_info = simple_device_info

    def validate(self):
        if self.simple_device_info:
            for k in self.simple_device_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SimpleDeviceInfo'] = []
        if self.simple_device_info is not None:
            for k in self.simple_device_info:
                result['SimpleDeviceInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.simple_device_info = []
        if m.get('SimpleDeviceInfo') is not None:
            for k in m.get('SimpleDeviceInfo'):
                temp_model = QueryDynamicGroupDevicesResponseBodyDataSimpleDeviceInfo()
                self.simple_device_info.append(temp_model.from_map(k))
        return self


class QueryDynamicGroupDevicesResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryDynamicGroupDevicesResponseBodyData = None,
        error_message: str = None,
        next_token: str = None,
        page: int = None,
        page_count: int = None,
        page_size: int = None,
        request_id: str = None,
        success: bool = None,
        total: int = None,
    ):
        # The error code returned if the request fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The devices returned after the request succeeds. The information is included in the **SimpleDeviceInfo** field.
        self.data = data
        # The error message returned if the request fails.
        self.error_message = error_message
        # A pagination token. It can be used in the next request to retrieve a new page of results.
        # 
        # If NextToken is empty, no next page exists.
        self.next_token = next_token
        # The page number.
        self.page = page
        # The total number of pages returned.
        self.page_count = page_count
        # The number of entries per page.
        self.page_size = page_size
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success
        # The total number of devices.
        self.total = total

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.page is not None:
            result['Page'] = self.page
        if self.page_count is not None:
            result['PageCount'] = self.page_count
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryDynamicGroupDevicesResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('PageCount') is not None:
            self.page_count = m.get('PageCount')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class QueryDynamicGroupDevicesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryDynamicGroupDevicesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryDynamicGroupDevicesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryEdgeDriverRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        driver_name: str = None,
        iot_instance_id: str = None,
        page_size: int = None,
        type: int = None,
    ):
        # The number of the page to return. Default value: 1. If you specify a value smaller than 1, pages start from page 1.
        self.current_page = current_page
        # The name of the driver whose information is to be queried. If you want to query information about drivers with a specific name, set this parameter.
        self.driver_name = driver_name
        # The ID of the Internet of Things (IoT) service instance. This parameter is not required for public instances. However, this parameter is required for the instances that you have purchased.
        self.iot_instance_id = iot_instance_id
        # The number of entries to return on each page. Maximum value: 30. Default value: 10. If you specify a value smaller than 1, a maximum of 10 entries are displayed on each page.
        self.page_size = page_size
        # The type of the driver whose information is to be queried. Valid values:
        # 
        # *   0: official driver
        # *   1: custom driver
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.driver_name is not None:
            result['DriverName'] = self.driver_name
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('DriverName') is not None:
            self.driver_name = m.get('DriverName')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class QueryEdgeDriverResponseBodyDataDriverList(TeaModel):
    def __init__(
        self,
        cpu_arch: str = None,
        driver_id: str = None,
        driver_name: str = None,
        driver_protocol: str = None,
        gmt_create_timestamp: int = None,
        gmt_modified_timestamp: int = None,
        is_apply: bool = None,
        is_built_in: bool = None,
        runtime: str = None,
        type: int = None,
    ):
        # The CPU architecture that the driver supports. Valid values:
        # 
        # *   ARMv7
        # *   ARMv7-HF
        # *   AArch64
        # *   x86-64
        # *   x86
        self.cpu_arch = cpu_arch
        # The ID of the driver.
        self.driver_id = driver_id
        # The name of the driver.
        self.driver_name = driver_name
        # The communications protocol that the driver uses. Valid values:
        # 
        # *   modbus: Modbus protocol
        # *   opc-ua: OPC UA protocol
        # *   customize: custom protocol
        self.driver_protocol = driver_protocol
        # The time when the driver was created. The time is displayed in UTC.
        self.gmt_create_timestamp = gmt_create_timestamp
        # The time when the driver was last modified. The time is displayed in UTC.
        self.gmt_modified_timestamp = gmt_modified_timestamp
        self.is_apply = is_apply
        # Indicates whether the driver is a built-in driver.
        # 
        # *   true: indicates that the driver is a built-in driver, that is, the driver code is pre-configured on the gateway device.
        # *   false: indicates that the driver is not a built-in driver.
        self.is_built_in = is_built_in
        # The language in which the driver is programmed. Valid values:
        # 
        # *   nodejs8: Node.js v8
        # *   python3: Python v3.5
        # *   c: C
        self.runtime = runtime
        # The type of the driver. Valid values:
        # 
        # *   0: official driver
        # *   1: custom driver
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cpu_arch is not None:
            result['CpuArch'] = self.cpu_arch
        if self.driver_id is not None:
            result['DriverId'] = self.driver_id
        if self.driver_name is not None:
            result['DriverName'] = self.driver_name
        if self.driver_protocol is not None:
            result['DriverProtocol'] = self.driver_protocol
        if self.gmt_create_timestamp is not None:
            result['GmtCreateTimestamp'] = self.gmt_create_timestamp
        if self.gmt_modified_timestamp is not None:
            result['GmtModifiedTimestamp'] = self.gmt_modified_timestamp
        if self.is_apply is not None:
            result['IsApply'] = self.is_apply
        if self.is_built_in is not None:
            result['IsBuiltIn'] = self.is_built_in
        if self.runtime is not None:
            result['Runtime'] = self.runtime
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CpuArch') is not None:
            self.cpu_arch = m.get('CpuArch')
        if m.get('DriverId') is not None:
            self.driver_id = m.get('DriverId')
        if m.get('DriverName') is not None:
            self.driver_name = m.get('DriverName')
        if m.get('DriverProtocol') is not None:
            self.driver_protocol = m.get('DriverProtocol')
        if m.get('GmtCreateTimestamp') is not None:
            self.gmt_create_timestamp = m.get('GmtCreateTimestamp')
        if m.get('GmtModifiedTimestamp') is not None:
            self.gmt_modified_timestamp = m.get('GmtModifiedTimestamp')
        if m.get('IsApply') is not None:
            self.is_apply = m.get('IsApply')
        if m.get('IsBuiltIn') is not None:
            self.is_built_in = m.get('IsBuiltIn')
        if m.get('Runtime') is not None:
            self.runtime = m.get('Runtime')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class QueryEdgeDriverResponseBodyData(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        driver_list: List[QueryEdgeDriverResponseBodyDataDriverList] = None,
        page_size: int = None,
        total: int = None,
    ):
        # The page number of the returned page.
        self.current_page = current_page
        # The information about each driver.
        self.driver_list = driver_list
        # The number of entries returned per page.
        self.page_size = page_size
        # The total number of official or custom drivers found.
        # 
        # *   If the value of Type is 0, the value of this parameter is the total number of official drivers found.
        # *   If the value of Type is 1, the value of this parameter is the total number of custom drivers found.
        self.total = total

    def validate(self):
        if self.driver_list:
            for k in self.driver_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        result['DriverList'] = []
        if self.driver_list is not None:
            for k in self.driver_list:
                result['DriverList'].append(k.to_map() if k else None)
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        self.driver_list = []
        if m.get('DriverList') is not None:
            for k in m.get('DriverList'):
                temp_model = QueryEdgeDriverResponseBodyDataDriverList()
                self.driver_list.append(temp_model.from_map(k))
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class QueryEdgeDriverResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryEdgeDriverResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code. Success indicates that the call was successful. Other values indicate that specific errors occurred. For more information, see [Error codes](~~135200~~).
        self.code = code
        # The data returned if the call was successful.
        self.data = data
        # The error message returned if the call failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful. true indicates that the call was successful. false indicates that the call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryEdgeDriverResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryEdgeDriverResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryEdgeDriverResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryEdgeDriverResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryEdgeDriverVersionRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        driver_id: str = None,
        driver_version: str = None,
        iot_instance_id: str = None,
        page_size: int = None,
        version_state: int = None,
    ):
        # The number of the page to return. Pages start from Page 1.
        self.current_page = current_page
        # The ID of the driver. To obtain the driver ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Drivers** page, move the pointer over the name of the driver whose versions you want to query and obtain the driver ID.
        # 
        # You can also call the [QueryEdgeDriver](~~155776~~) operation to query the driver ID.
        self.driver_id = driver_id
        # The version number of the driver. To query information about a specific driver version, set this parameter to the specific version number.
        self.driver_version = driver_version
        # The ID of the Internet of Things (IoT) service instance. This parameter is not required for the public instance but required for Enterprise Edition instances.
        self.iot_instance_id = iot_instance_id
        # The number of entries to return on each page. Valid values: 1 to 30. Default value: 10.
        self.page_size = page_size
        # The status of the driver version. Valid values:
        # 
        # *   0: The driver version to be queried is not published.
        # *   1: The driver version to be queried is published.
        self.version_state = version_state

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.driver_id is not None:
            result['DriverId'] = self.driver_id
        if self.driver_version is not None:
            result['DriverVersion'] = self.driver_version
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.version_state is not None:
            result['VersionState'] = self.version_state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('DriverId') is not None:
            self.driver_id = m.get('DriverId')
        if m.get('DriverVersion') is not None:
            self.driver_version = m.get('DriverVersion')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('VersionState') is not None:
            self.version_state = m.get('VersionState')
        return self


class QueryEdgeDriverVersionResponseBodyDataDriverVersionList(TeaModel):
    def __init__(
        self,
        argument: str = None,
        config_check_rule: str = None,
        container_config: str = None,
        description: str = None,
        driver_config: str = None,
        driver_id: str = None,
        driver_version: str = None,
        edge_version: str = None,
        gmt_create_timestamp: int = None,
        gmt_modified_timestamp: int = None,
        source_config: str = None,
        version_state: str = None,
    ):
        # The Java Virtual Machine (JVM) startup parameter.
        self.argument = argument
        # The rule for verifying configurations. The value is a JSON string in the following format:
        # 
        # `{"deviceConfig":{"required":false},"driverConfig":{"required":false}`
        # 
        # The JSON string contains the following parameters:
        # 
        # *   driverConfig: the rule for verifying the configuration of the driver when the driver is to be deployed in an edge instance.
        # *   deviceConfig: the rule for verifying the configurations of devices that use the driver when the driver is to be deployed in an edge instance.
        self.config_check_rule = config_check_rule
        # The configuration of the container where the driver runs. The value is a JSON string. For more information about parameters in the JSON string, see the following parameter description of ContainerConfig.
        self.container_config = container_config
        # The description of the driver.
        self.description = description
        # The configuration of the driver. The value is a JSON string in the following format:
        # 
        # `{"format":"JSON","content":"{}"}`
        # 
        # The JSON string contains the following parameters:
        # 
        # *   format: the format of the driver configuration. Valid values: KV (key-value pair), JSON (JSON string), and FILE (configuration file).
        # *   content: the content of the driver configuration. If the format parameter is set to KV or JSON, the value of this parameter is the configuration content. If the format parameter is set to FILE, the value of this parameter is the URL of the configuration file stored in Object Storage Service (OSS).
        self.driver_config = driver_config
        # The ID of the driver.
        self.driver_id = driver_id
        # The version number of the driver.
        self.driver_version = driver_version
        # The earliest version of Link IoT Edge that is supported by the driver.
        self.edge_version = edge_version
        # The UNIX timestamp when the driver was created.
        self.gmt_create_timestamp = gmt_create_timestamp
        # The last UNIX timestamp when the driver was updated.
        self.gmt_modified_timestamp = gmt_modified_timestamp
        self.source_config = source_config
        # The status of the driver version. Valid values:
        # 
        # *   0: The driver version was not published.
        # *   1: The driver version was published.
        self.version_state = version_state

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.argument is not None:
            result['Argument'] = self.argument
        if self.config_check_rule is not None:
            result['ConfigCheckRule'] = self.config_check_rule
        if self.container_config is not None:
            result['ContainerConfig'] = self.container_config
        if self.description is not None:
            result['Description'] = self.description
        if self.driver_config is not None:
            result['DriverConfig'] = self.driver_config
        if self.driver_id is not None:
            result['DriverId'] = self.driver_id
        if self.driver_version is not None:
            result['DriverVersion'] = self.driver_version
        if self.edge_version is not None:
            result['EdgeVersion'] = self.edge_version
        if self.gmt_create_timestamp is not None:
            result['GmtCreateTimestamp'] = self.gmt_create_timestamp
        if self.gmt_modified_timestamp is not None:
            result['GmtModifiedTimestamp'] = self.gmt_modified_timestamp
        if self.source_config is not None:
            result['SourceConfig'] = self.source_config
        if self.version_state is not None:
            result['VersionState'] = self.version_state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Argument') is not None:
            self.argument = m.get('Argument')
        if m.get('ConfigCheckRule') is not None:
            self.config_check_rule = m.get('ConfigCheckRule')
        if m.get('ContainerConfig') is not None:
            self.container_config = m.get('ContainerConfig')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DriverConfig') is not None:
            self.driver_config = m.get('DriverConfig')
        if m.get('DriverId') is not None:
            self.driver_id = m.get('DriverId')
        if m.get('DriverVersion') is not None:
            self.driver_version = m.get('DriverVersion')
        if m.get('EdgeVersion') is not None:
            self.edge_version = m.get('EdgeVersion')
        if m.get('GmtCreateTimestamp') is not None:
            self.gmt_create_timestamp = m.get('GmtCreateTimestamp')
        if m.get('GmtModifiedTimestamp') is not None:
            self.gmt_modified_timestamp = m.get('GmtModifiedTimestamp')
        if m.get('SourceConfig') is not None:
            self.source_config = m.get('SourceConfig')
        if m.get('VersionState') is not None:
            self.version_state = m.get('VersionState')
        return self


class QueryEdgeDriverVersionResponseBodyData(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        driver_version_list: List[QueryEdgeDriverVersionResponseBodyDataDriverVersionList] = None,
        page_size: int = None,
        total: int = None,
    ):
        # The page number of the returned page.
        self.current_page = current_page
        # The information about each version of the driver.
        self.driver_version_list = driver_version_list
        # The number of entries returned per page.
        self.page_size = page_size
        # The number of driver versions.
        self.total = total

    def validate(self):
        if self.driver_version_list:
            for k in self.driver_version_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        result['DriverVersionList'] = []
        if self.driver_version_list is not None:
            for k in self.driver_version_list:
                result['DriverVersionList'].append(k.to_map() if k else None)
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        self.driver_version_list = []
        if m.get('DriverVersionList') is not None:
            for k in m.get('DriverVersionList'):
                temp_model = QueryEdgeDriverVersionResponseBodyDataDriverVersionList()
                self.driver_version_list.append(temp_model.from_map(k))
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class QueryEdgeDriverVersionResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryEdgeDriverVersionResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The return code of the operation. A value of Success indicates that the call was successful. Other values indicate that specific errors occurred. For more information, see [Error codes](~~135200~~).
        self.code = code
        # The data that is returned if the call was successful.
        self.data = data
        # The error message that is returned if the call failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful. A value of true indicates that the call was successful. A value of false indicates that the call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryEdgeDriverVersionResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryEdgeDriverVersionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryEdgeDriverVersionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryEdgeDriverVersionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryEdgeInstanceRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        iot_instance_id: str = None,
        name: str = None,
        page_size: int = None,
    ):
        # The name of the edge instance.
        self.current_page = current_page
        # The number of entries to return on each page. Maximum value: 30. Default value: 10. If you specify a value smaller than 1, the system uses 10.
        self.iot_instance_id = iot_instance_id
        # The error code. Success indicates that the call was successful. Other values indicate that specific errors occurred. For more information, see [Error codes](~~135200~~).
        self.name = name
        # The number of the page from which the results are displayed. The minimum value is 1. If you specify a value smaller than 1, the system uses 1.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.name is not None:
            result['Name'] = self.name
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class QueryEdgeInstanceResponseBodyDataInstanceList(TeaModel):
    def __init__(
        self,
        biz_enable: bool = None,
        gmt_create: str = None,
        gmt_create_timestamp: int = None,
        gmt_modified: str = None,
        gmt_modified_timestamp: int = None,
        instance_id: str = None,
        latest_deployment_status: int = None,
        latest_deployment_type: str = None,
        name: str = None,
        role_arn: str = None,
        role_attach_time: str = None,
        role_attach_timestamp: int = None,
        role_name: str = None,
        spec: int = None,
        tags: str = None,
        type: int = None,
    ):
        # The time when the edge instance was created.
        self.biz_enable = biz_enable
        # The name of the edge instance.
        self.gmt_create = gmt_create
        self.gmt_create_timestamp = gmt_create_timestamp
        # The type of the latest deployment task.
        # 
        # *   deploy: deploys the edge instance.
        # *   Reset: resets the edge instance.
        self.gmt_modified = gmt_modified
        self.gmt_modified_timestamp = gmt_modified_timestamp
        # The name of the RAM role.
        self.instance_id = instance_id
        # Indicates whether the edge instance was enabled.
        # 
        # *   true: enabled
        # *   false: disabled
        self.latest_deployment_status = latest_deployment_status
        # The status of the latest deployment task.
        # 
        # *   0: The task has not started.
        # *   1: The task is being processed.
        # *   2: The task was successful.
        # *   3: The task failed.
        self.latest_deployment_type = latest_deployment_type
        self.name = name
        # The time when the RAM role was attached to IoT Platform.
        self.role_arn = role_arn
        # The specification of the edge instance.
        # 
        # *   10: Lite Edition.
        # *   20: Standard Edition.
        # *   30: Pro Edition.
        self.role_attach_time = role_attach_time
        self.role_attach_timestamp = role_attach_timestamp
        # The time when the edge instance was last updated.
        self.role_name = role_name
        # The tags of the edge instance.
        self.spec = spec
        # The ID of the edge instance.
        self.tags = tags
        # The Alibaba Cloud Resource Name (ARN) of the RAM role.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_enable is not None:
            result['BizEnable'] = self.biz_enable
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_create_timestamp is not None:
            result['GmtCreateTimestamp'] = self.gmt_create_timestamp
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.gmt_modified_timestamp is not None:
            result['GmtModifiedTimestamp'] = self.gmt_modified_timestamp
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.latest_deployment_status is not None:
            result['LatestDeploymentStatus'] = self.latest_deployment_status
        if self.latest_deployment_type is not None:
            result['LatestDeploymentType'] = self.latest_deployment_type
        if self.name is not None:
            result['Name'] = self.name
        if self.role_arn is not None:
            result['RoleArn'] = self.role_arn
        if self.role_attach_time is not None:
            result['RoleAttachTime'] = self.role_attach_time
        if self.role_attach_timestamp is not None:
            result['RoleAttachTimestamp'] = self.role_attach_timestamp
        if self.role_name is not None:
            result['RoleName'] = self.role_name
        if self.spec is not None:
            result['Spec'] = self.spec
        if self.tags is not None:
            result['Tags'] = self.tags
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BizEnable') is not None:
            self.biz_enable = m.get('BizEnable')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtCreateTimestamp') is not None:
            self.gmt_create_timestamp = m.get('GmtCreateTimestamp')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('GmtModifiedTimestamp') is not None:
            self.gmt_modified_timestamp = m.get('GmtModifiedTimestamp')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('LatestDeploymentStatus') is not None:
            self.latest_deployment_status = m.get('LatestDeploymentStatus')
        if m.get('LatestDeploymentType') is not None:
            self.latest_deployment_type = m.get('LatestDeploymentType')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RoleArn') is not None:
            self.role_arn = m.get('RoleArn')
        if m.get('RoleAttachTime') is not None:
            self.role_attach_time = m.get('RoleAttachTime')
        if m.get('RoleAttachTimestamp') is not None:
            self.role_attach_timestamp = m.get('RoleAttachTimestamp')
        if m.get('RoleName') is not None:
            self.role_name = m.get('RoleName')
        if m.get('Spec') is not None:
            self.spec = m.get('Spec')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class QueryEdgeInstanceResponseBodyData(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        instance_list: List[QueryEdgeInstanceResponseBodyDataInstanceList] = None,
        page_size: int = None,
        total: int = None,
    ):
        # The number of entries returned per page.
        self.current_page = current_page
        # Indicates whether you own the edge instance or you are authorized to use the edge instance.
        # 
        # *   0: You own the edge instance.
        # *   1: You are authorized to use the edge instance.
        self.instance_list = instance_list
        # The number of edge instances.
        self.page_size = page_size
        # A list of edge instances.
        self.total = total

    def validate(self):
        if self.instance_list:
            for k in self.instance_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        result['InstanceList'] = []
        if self.instance_list is not None:
            for k in self.instance_list:
                result['InstanceList'].append(k.to_map() if k else None)
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        self.instance_list = []
        if m.get('InstanceList') is not None:
            for k in m.get('InstanceList'):
                temp_model = QueryEdgeInstanceResponseBodyDataInstanceList()
                self.instance_list.append(temp_model.from_map(k))
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class QueryEdgeInstanceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryEdgeInstanceResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error message returned if the call failed.
        self.code = code
        # The page number of the returned page.
        self.data = data
        # The ID of the request.
        self.error_message = error_message
        # Indicates whether the call was successful. true: indicates that the call was successful. false: indicates that the call failed.
        self.request_id = request_id
        # The data returned if the call was successful.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryEdgeInstanceResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryEdgeInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryEdgeInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryEdgeInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryEdgeInstanceChannelRequest(TeaModel):
    def __init__(
        self,
        channel_name: str = None,
        current_page: int = None,
        driver_id: str = None,
        instance_id: str = None,
        iot_instance_id: str = None,
        page_size: int = None,
    ):
        self.channel_name = channel_name
        self.current_page = current_page
        self.driver_id = driver_id
        self.instance_id = instance_id
        self.iot_instance_id = iot_instance_id
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_name is not None:
            result['ChannelName'] = self.channel_name
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.driver_id is not None:
            result['DriverId'] = self.driver_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelName') is not None:
            self.channel_name = m.get('ChannelName')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('DriverId') is not None:
            self.driver_id = m.get('DriverId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigListConfig(TeaModel):
    def __init__(
        self,
        config_id: str = None,
        content: str = None,
        format: str = None,
        key: str = None,
    ):
        self.config_id = config_id
        self.content = content
        self.format = format
        self.key = key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config_id is not None:
            result['ConfigId'] = self.config_id
        if self.content is not None:
            result['Content'] = self.content
        if self.format is not None:
            result['Format'] = self.format
        if self.key is not None:
            result['Key'] = self.key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConfigId') is not None:
            self.config_id = m.get('ConfigId')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('Format') is not None:
            self.format = m.get('Format')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        return self


class QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigList(TeaModel):
    def __init__(
        self,
        config: List[QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigListConfig] = None,
    ):
        self.config = config

    def validate(self):
        if self.config:
            for k in self.config:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Config'] = []
        if self.config is not None:
            for k in self.config:
                result['Config'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.config = []
        if m.get('Config') is not None:
            for k in m.get('Config'):
                temp_model = QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigListConfig()
                self.config.append(temp_model.from_map(k))
        return self


class QueryEdgeInstanceChannelResponseBodyDataChannelListChannel(TeaModel):
    def __init__(
        self,
        channel_id: str = None,
        channel_name: str = None,
        config_list: QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigList = None,
        gmt_create: str = None,
        gmt_create_timestamp: int = None,
        gmt_modified: str = None,
        gmt_modified_timestamp: int = None,
    ):
        self.channel_id = channel_id
        self.channel_name = channel_name
        self.config_list = config_list
        self.gmt_create = gmt_create
        self.gmt_create_timestamp = gmt_create_timestamp
        self.gmt_modified = gmt_modified
        self.gmt_modified_timestamp = gmt_modified_timestamp

    def validate(self):
        if self.config_list:
            self.config_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.channel_name is not None:
            result['ChannelName'] = self.channel_name
        if self.config_list is not None:
            result['ConfigList'] = self.config_list.to_map()
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_create_timestamp is not None:
            result['GmtCreateTimestamp'] = self.gmt_create_timestamp
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.gmt_modified_timestamp is not None:
            result['GmtModifiedTimestamp'] = self.gmt_modified_timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('ChannelName') is not None:
            self.channel_name = m.get('ChannelName')
        if m.get('ConfigList') is not None:
            temp_model = QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigList()
            self.config_list = temp_model.from_map(m['ConfigList'])
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtCreateTimestamp') is not None:
            self.gmt_create_timestamp = m.get('GmtCreateTimestamp')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('GmtModifiedTimestamp') is not None:
            self.gmt_modified_timestamp = m.get('GmtModifiedTimestamp')
        return self


class QueryEdgeInstanceChannelResponseBodyDataChannelList(TeaModel):
    def __init__(
        self,
        channel: List[QueryEdgeInstanceChannelResponseBodyDataChannelListChannel] = None,
    ):
        self.channel = channel

    def validate(self):
        if self.channel:
            for k in self.channel:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Channel'] = []
        if self.channel is not None:
            for k in self.channel:
                result['Channel'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.channel = []
        if m.get('Channel') is not None:
            for k in m.get('Channel'):
                temp_model = QueryEdgeInstanceChannelResponseBodyDataChannelListChannel()
                self.channel.append(temp_model.from_map(k))
        return self


class QueryEdgeInstanceChannelResponseBodyData(TeaModel):
    def __init__(
        self,
        channel_list: QueryEdgeInstanceChannelResponseBodyDataChannelList = None,
        current_page: int = None,
        page_size: int = None,
        total: int = None,
    ):
        self.channel_list = channel_list
        self.current_page = current_page
        self.page_size = page_size
        self.total = total

    def validate(self):
        if self.channel_list:
            self.channel_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_list is not None:
            result['ChannelList'] = self.channel_list.to_map()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelList') is not None:
            temp_model = QueryEdgeInstanceChannelResponseBodyDataChannelList()
            self.channel_list = temp_model.from_map(m['ChannelList'])
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class QueryEdgeInstanceChannelResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryEdgeInstanceChannelResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryEdgeInstanceChannelResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryEdgeInstanceChannelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryEdgeInstanceChannelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryEdgeInstanceChannelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryEdgeInstanceDeviceRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        instance_id: str = None,
        iot_instance_id: str = None,
        page_size: int = None,
    ):
        # The number of the page to return. Pages start from Page 1.
        self.current_page = current_page
        # The ID of the edge instance. To obtain the instance ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Edge Instances** page, move the pointer over the name of the edge instance that you want to query and obtain the instance ID.
        # 
        # You can also call the [QueryEdgeInstance](~~135214~~) operation to query the instance ID.
        self.instance_id = instance_id
        # The ID of the Internet of Things (IoT) service instance. This parameter is not required for the public instance but required for Enterprise Edition instances.
        self.iot_instance_id = iot_instance_id
        # The number of entries to return on each page. Valid values: 1 to 30. Default value: 10.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class QueryEdgeInstanceDeviceResponseBodyDataDeviceList(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        driver_id: str = None,
        iot_id: str = None,
        product_key: str = None,
    ):
        # The name of the device.
        self.device_name = device_name
        # The ID of the driver.
        self.driver_id = driver_id
        # The ID of the device.
        self.iot_id = iot_id
        # The key that uniquely identifies the product to which the device belongs.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.driver_id is not None:
            result['DriverId'] = self.driver_id
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('DriverId') is not None:
            self.driver_id = m.get('DriverId')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class QueryEdgeInstanceDeviceResponseBodyData(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        device_list: List[QueryEdgeInstanceDeviceResponseBodyDataDeviceList] = None,
        page_size: int = None,
        total: int = None,
    ):
        # The page number of the returned page.
        self.current_page = current_page
        # The list of device information.
        self.device_list = device_list
        # The number of entries returned per page.
        self.page_size = page_size
        # The number of devices.
        self.total = total

    def validate(self):
        if self.device_list:
            for k in self.device_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        result['DeviceList'] = []
        if self.device_list is not None:
            for k in self.device_list:
                result['DeviceList'].append(k.to_map() if k else None)
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        self.device_list = []
        if m.get('DeviceList') is not None:
            for k in m.get('DeviceList'):
                temp_model = QueryEdgeInstanceDeviceResponseBodyDataDeviceList()
                self.device_list.append(temp_model.from_map(k))
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class QueryEdgeInstanceDeviceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryEdgeInstanceDeviceResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The return code of the operation. A value of Success indicates that the call was successful. Other values indicate that specific errors occurred. For more information, see [Error codes](~~135200~~).
        self.code = code
        # The data that is returned if the call was successful.
        self.data = data
        # The error message that is returned if the call failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful. A value of true indicates that the call was successful. A value of false indicates that the call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryEdgeInstanceDeviceResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryEdgeInstanceDeviceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryEdgeInstanceDeviceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryEdgeInstanceDeviceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryEdgeInstanceDeviceByDriverRequest(TeaModel):
    def __init__(
        self,
        channel_id: str = None,
        current_page: int = None,
        driver_id: str = None,
        instance_id: str = None,
        iot_instance_id: str = None,
        page_size: int = None,
    ):
        self.channel_id = channel_id
        self.current_page = current_page
        self.driver_id = driver_id
        self.instance_id = instance_id
        self.iot_instance_id = iot_instance_id
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.driver_id is not None:
            result['DriverId'] = self.driver_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('DriverId') is not None:
            self.driver_id = m.get('DriverId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class QueryEdgeInstanceDeviceByDriverResponseBodyDataDeviceList(TeaModel):
    def __init__(
        self,
        iot_id: str = None,
    ):
        self.iot_id = iot_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        return self


class QueryEdgeInstanceDeviceByDriverResponseBodyData(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        device_list: List[QueryEdgeInstanceDeviceByDriverResponseBodyDataDeviceList] = None,
        page_size: int = None,
        total: int = None,
    ):
        self.current_page = current_page
        self.device_list = device_list
        self.page_size = page_size
        self.total = total

    def validate(self):
        if self.device_list:
            for k in self.device_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        result['DeviceList'] = []
        if self.device_list is not None:
            for k in self.device_list:
                result['DeviceList'].append(k.to_map() if k else None)
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        self.device_list = []
        if m.get('DeviceList') is not None:
            for k in m.get('DeviceList'):
                temp_model = QueryEdgeInstanceDeviceByDriverResponseBodyDataDeviceList()
                self.device_list.append(temp_model.from_map(k))
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class QueryEdgeInstanceDeviceByDriverResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryEdgeInstanceDeviceByDriverResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryEdgeInstanceDeviceByDriverResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryEdgeInstanceDeviceByDriverResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryEdgeInstanceDeviceByDriverResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryEdgeInstanceDeviceByDriverResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryEdgeInstanceDriverRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        instance_id: str = None,
        iot_instance_id: str = None,
        page_size: int = None,
    ):
        # The number of the page to return. Pages start from Page 1.
        self.current_page = current_page
        # The ID of the edge instance. To obtain the instance ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Edge Instances** page, move the pointer over the name of the edge instance that you want to query and obtain the instance ID.
        # 
        # You can also call the [QueryEdgeInstance](~~135214~~) operation to query the instance ID.
        self.instance_id = instance_id
        # The ID of the Internet of Things (IoT) service instance. This parameter is not required for the public instance but required for Enterprise Edition instances.
        self.iot_instance_id = iot_instance_id
        # The number of entries to return on each page. Valid values: 1 to 30. Default value: 10.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class QueryEdgeInstanceDriverResponseBodyDataDriverList(TeaModel):
    def __init__(
        self,
        driver_id: str = None,
        driver_version: str = None,
        gmt_create: str = None,
        gmt_modified: str = None,
        order_id: str = None,
    ):
        # The ID of the driver.
        self.driver_id = driver_id
        # The version number of the driver.
        self.driver_version = driver_version
        # The time when the driver was created.
        self.gmt_create = gmt_create
        # The last time when the driver was updated.
        self.gmt_modified = gmt_modified
        # The ID of the order.
        self.order_id = order_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.driver_id is not None:
            result['DriverId'] = self.driver_id
        if self.driver_version is not None:
            result['DriverVersion'] = self.driver_version
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DriverId') is not None:
            self.driver_id = m.get('DriverId')
        if m.get('DriverVersion') is not None:
            self.driver_version = m.get('DriverVersion')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        return self


class QueryEdgeInstanceDriverResponseBodyData(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        driver_list: List[QueryEdgeInstanceDriverResponseBodyDataDriverList] = None,
        page_size: int = None,
        total: int = None,
    ):
        # The page number of the returned page.
        self.current_page = current_page
        # The list of drivers.
        self.driver_list = driver_list
        # The number of entries returned per page.
        self.page_size = page_size
        # The number of drivers.
        self.total = total

    def validate(self):
        if self.driver_list:
            for k in self.driver_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        result['DriverList'] = []
        if self.driver_list is not None:
            for k in self.driver_list:
                result['DriverList'].append(k.to_map() if k else None)
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        self.driver_list = []
        if m.get('DriverList') is not None:
            for k in m.get('DriverList'):
                temp_model = QueryEdgeInstanceDriverResponseBodyDataDriverList()
                self.driver_list.append(temp_model.from_map(k))
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class QueryEdgeInstanceDriverResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryEdgeInstanceDriverResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The return code of the operation. A value of Success indicates that the call was successful. Other values indicate that specific errors occurred. For more information, see [Error codes](~~135200~~).
        self.code = code
        # The data that is returned if the call was successful.
        self.data = data
        # The error message that is returned if the call failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful. A value of true indicates that the call was successful. A value of false indicates that the call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryEdgeInstanceDriverResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryEdgeInstanceDriverResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryEdgeInstanceDriverResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryEdgeInstanceDriverResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryEdgeInstanceGatewayRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        iot_instance_id: str = None,
    ):
        # The ID of the edge instance. To obtain the instance ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Edge Instances** page, move the pointer over the name of the edge instance that you want to query and obtain the instance ID.
        # 
        # You can also call the [QueryEdgeInstance](~~135214~~) operation to query the instance ID.
        self.instance_id = instance_id
        # The ID of the Internet of Things (IoT) service instance. This parameter is not required for the public instance but required for Enterprise Edition instances.
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class QueryEdgeInstanceGatewayResponseBodyGatewayList(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        edge_version: str = None,
        iot_id: str = None,
        product_key: str = None,
    ):
        # The name of the gateway.
        self.device_name = device_name
        # The version number of Link IoT Edge.
        self.edge_version = edge_version
        # The ID of the gateway in IoT Platform.
        self.iot_id = iot_id
        # The key that uniquely identifies the product to which the gateway belongs.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.edge_version is not None:
            result['EdgeVersion'] = self.edge_version
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('EdgeVersion') is not None:
            self.edge_version = m.get('EdgeVersion')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class QueryEdgeInstanceGatewayResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        gateway_list: List[QueryEdgeInstanceGatewayResponseBodyGatewayList] = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The return code of the operation. A value of Success indicates that the call was successful. Other values indicate that specific errors occurred. For more information, see [Error codes](~~135200~~).
        self.code = code
        # The error message that is returned if the call failed.
        self.error_message = error_message
        # The data that is returned if the call was successful.
        self.gateway_list = gateway_list
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful. A value of true indicates that the call was successful. A value of false indicates that the call failed.
        self.success = success

    def validate(self):
        if self.gateway_list:
            for k in self.gateway_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        result['GatewayList'] = []
        if self.gateway_list is not None:
            for k in self.gateway_list:
                result['GatewayList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        self.gateway_list = []
        if m.get('GatewayList') is not None:
            for k in m.get('GatewayList'):
                temp_model = QueryEdgeInstanceGatewayResponseBodyGatewayList()
                self.gateway_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryEdgeInstanceGatewayResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryEdgeInstanceGatewayResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryEdgeInstanceGatewayResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryEdgeInstanceHistoricDeploymentRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        end_time: int = None,
        instance_id: str = None,
        iot_instance_id: str = None,
        page_size: int = None,
        start_time: int = None,
    ):
        # The number of the page to return. Pages start from Page 1.
        self.current_page = current_page
        # The end of the time range to query. If you do not specify the start time and end time, all the deployment task records of the edge instance are queried.
        self.end_time = end_time
        # The ID of the edge instance. To obtain the instance ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Edge Instances** page, move the pointer over the name of the edge instance that you want to manage and obtain the instance ID.
        # 
        # You can also call the [QueryEdgeInstance](~~135214~~) operation to query the instance ID.
        self.instance_id = instance_id
        # The ID of the Internet of Things (IoT) service instance. This parameter is not required for the public instance but required for Enterprise Edition instances.
        self.iot_instance_id = iot_instance_id
        # The number of entries to return on each page. Valid values: 1 to 30. Default value: 10.
        self.page_size = page_size
        # The beginning of the time range to query. If you do not specify the start time and end time, all the deployment task records of the edge instance are queried.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class QueryEdgeInstanceHistoricDeploymentResponseBodyDataDeploymentList(TeaModel):
    def __init__(
        self,
        deployment_id: str = None,
        description: str = None,
        gmt_completed: str = None,
        gmt_completed_timestamp: int = None,
        gmt_create: str = None,
        gmt_create_timestamp: int = None,
        gmt_modified: str = None,
        gmt_modified_timestamp: int = None,
        status: int = None,
        type: str = None,
    ):
        # The ID of the deployment task.
        self.deployment_id = deployment_id
        # The description of the deployment task.
        self.description = description
        # The time when the deployment task was complete.
        self.gmt_completed = gmt_completed
        # The UNIX timestamp when the deployment task was complete.
        self.gmt_completed_timestamp = gmt_completed_timestamp
        # The time when the deployment task was created.
        self.gmt_create = gmt_create
        # The UNIX timestamp when the deployment task was created.
        self.gmt_create_timestamp = gmt_create_timestamp
        # The last time when the deployment task was modified.
        self.gmt_modified = gmt_modified
        # The last UNIX timestamp when the deployment task was modified.
        self.gmt_modified_timestamp = gmt_modified_timestamp
        # The status of the deployment task.
        # 
        # *   0: The task was not started.
        # *   1: The task was being processed.
        # *   2: The task was successful.
        # *   3: The task failed.
        self.status = status
        # The type of the deployment task.
        # 
        # *   deploy: deploys the edge instance.
        # *   reset: resets the edge instance.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.deployment_id is not None:
            result['DeploymentId'] = self.deployment_id
        if self.description is not None:
            result['Description'] = self.description
        if self.gmt_completed is not None:
            result['GmtCompleted'] = self.gmt_completed
        if self.gmt_completed_timestamp is not None:
            result['GmtCompletedTimestamp'] = self.gmt_completed_timestamp
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_create_timestamp is not None:
            result['GmtCreateTimestamp'] = self.gmt_create_timestamp
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.gmt_modified_timestamp is not None:
            result['GmtModifiedTimestamp'] = self.gmt_modified_timestamp
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeploymentId') is not None:
            self.deployment_id = m.get('DeploymentId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('GmtCompleted') is not None:
            self.gmt_completed = m.get('GmtCompleted')
        if m.get('GmtCompletedTimestamp') is not None:
            self.gmt_completed_timestamp = m.get('GmtCompletedTimestamp')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtCreateTimestamp') is not None:
            self.gmt_create_timestamp = m.get('GmtCreateTimestamp')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('GmtModifiedTimestamp') is not None:
            self.gmt_modified_timestamp = m.get('GmtModifiedTimestamp')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class QueryEdgeInstanceHistoricDeploymentResponseBodyData(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        deployment_list: List[QueryEdgeInstanceHistoricDeploymentResponseBodyDataDeploymentList] = None,
        page_size: int = None,
        total: int = None,
    ):
        # The page number of the returned page.
        self.current_page = current_page
        # The list of deployment tasks.
        self.deployment_list = deployment_list
        # The number of entries returned per page.
        self.page_size = page_size
        # The total number of deployment tasks.
        self.total = total

    def validate(self):
        if self.deployment_list:
            for k in self.deployment_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        result['DeploymentList'] = []
        if self.deployment_list is not None:
            for k in self.deployment_list:
                result['DeploymentList'].append(k.to_map() if k else None)
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        self.deployment_list = []
        if m.get('DeploymentList') is not None:
            for k in m.get('DeploymentList'):
                temp_model = QueryEdgeInstanceHistoricDeploymentResponseBodyDataDeploymentList()
                self.deployment_list.append(temp_model.from_map(k))
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class QueryEdgeInstanceHistoricDeploymentResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryEdgeInstanceHistoricDeploymentResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The return code of the operation. A value of Success indicates that the call was successful. Other values indicate that specific errors occurred. For more information, see [Error codes](~~135200~~).
        self.code = code
        # The data that is returned if the call was successful.
        self.data = data
        # The error message that is returned if the call failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful. A value of true indicates that the call was successful. A value of false indicates that the call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryEdgeInstanceHistoricDeploymentResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryEdgeInstanceHistoricDeploymentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryEdgeInstanceHistoricDeploymentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryEdgeInstanceHistoricDeploymentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryEdgeInstanceMessageRoutingRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        instance_id: str = None,
        iot_instance_id: str = None,
        page_size: int = None,
    ):
        self.current_page = current_page
        self.instance_id = instance_id
        self.iot_instance_id = iot_instance_id
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRouteRouteContext(TeaModel):
    def __init__(
        self,
        qos: str = None,
        source_application_name: str = None,
        source_fc_function_name: str = None,
        source_fc_service_name: str = None,
        target_application_name: str = None,
        target_fc_function_name: str = None,
        target_fc_service_name: str = None,
    ):
        self.qos = qos
        self.source_application_name = source_application_name
        self.source_fc_function_name = source_fc_function_name
        self.source_fc_service_name = source_fc_service_name
        self.target_application_name = target_application_name
        self.target_fc_function_name = target_fc_function_name
        self.target_fc_service_name = target_fc_service_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.qos is not None:
            result['Qos'] = self.qos
        if self.source_application_name is not None:
            result['SourceApplicationName'] = self.source_application_name
        if self.source_fc_function_name is not None:
            result['SourceFcFunctionName'] = self.source_fc_function_name
        if self.source_fc_service_name is not None:
            result['SourceFcServiceName'] = self.source_fc_service_name
        if self.target_application_name is not None:
            result['TargetApplicationName'] = self.target_application_name
        if self.target_fc_function_name is not None:
            result['TargetFcFunctionName'] = self.target_fc_function_name
        if self.target_fc_service_name is not None:
            result['TargetFcServiceName'] = self.target_fc_service_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Qos') is not None:
            self.qos = m.get('Qos')
        if m.get('SourceApplicationName') is not None:
            self.source_application_name = m.get('SourceApplicationName')
        if m.get('SourceFcFunctionName') is not None:
            self.source_fc_function_name = m.get('SourceFcFunctionName')
        if m.get('SourceFcServiceName') is not None:
            self.source_fc_service_name = m.get('SourceFcServiceName')
        if m.get('TargetApplicationName') is not None:
            self.target_application_name = m.get('TargetApplicationName')
        if m.get('TargetFcFunctionName') is not None:
            self.target_fc_function_name = m.get('TargetFcFunctionName')
        if m.get('TargetFcServiceName') is not None:
            self.target_fc_service_name = m.get('TargetFcServiceName')
        return self


class QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRoute(TeaModel):
    def __init__(
        self,
        gmt_create: str = None,
        gmt_create_timestamp: int = None,
        gmt_modified: str = None,
        gmt_modified_timestamp: int = None,
        name: str = None,
        route_context: QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRouteRouteContext = None,
        route_id: int = None,
        source_data: str = None,
        source_type: str = None,
        target_data: str = None,
        target_type: str = None,
        topic_filter: str = None,
    ):
        self.gmt_create = gmt_create
        self.gmt_create_timestamp = gmt_create_timestamp
        self.gmt_modified = gmt_modified
        self.gmt_modified_timestamp = gmt_modified_timestamp
        self.name = name
        self.route_context = route_context
        self.route_id = route_id
        self.source_data = source_data
        self.source_type = source_type
        self.target_data = target_data
        self.target_type = target_type
        self.topic_filter = topic_filter

    def validate(self):
        if self.route_context:
            self.route_context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_create_timestamp is not None:
            result['GmtCreateTimestamp'] = self.gmt_create_timestamp
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.gmt_modified_timestamp is not None:
            result['GmtModifiedTimestamp'] = self.gmt_modified_timestamp
        if self.name is not None:
            result['Name'] = self.name
        if self.route_context is not None:
            result['RouteContext'] = self.route_context.to_map()
        if self.route_id is not None:
            result['RouteId'] = self.route_id
        if self.source_data is not None:
            result['SourceData'] = self.source_data
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        if self.target_data is not None:
            result['TargetData'] = self.target_data
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        if self.topic_filter is not None:
            result['TopicFilter'] = self.topic_filter
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtCreateTimestamp') is not None:
            self.gmt_create_timestamp = m.get('GmtCreateTimestamp')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('GmtModifiedTimestamp') is not None:
            self.gmt_modified_timestamp = m.get('GmtModifiedTimestamp')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RouteContext') is not None:
            temp_model = QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRouteRouteContext()
            self.route_context = temp_model.from_map(m['RouteContext'])
        if m.get('RouteId') is not None:
            self.route_id = m.get('RouteId')
        if m.get('SourceData') is not None:
            self.source_data = m.get('SourceData')
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        if m.get('TargetData') is not None:
            self.target_data = m.get('TargetData')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        if m.get('TopicFilter') is not None:
            self.topic_filter = m.get('TopicFilter')
        return self


class QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteList(TeaModel):
    def __init__(
        self,
        message_route: List[QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRoute] = None,
    ):
        self.message_route = message_route

    def validate(self):
        if self.message_route:
            for k in self.message_route:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MessageRoute'] = []
        if self.message_route is not None:
            for k in self.message_route:
                result['MessageRoute'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.message_route = []
        if m.get('MessageRoute') is not None:
            for k in m.get('MessageRoute'):
                temp_model = QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRoute()
                self.message_route.append(temp_model.from_map(k))
        return self


class QueryEdgeInstanceMessageRoutingResponseBodyData(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        message_route_list: QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteList = None,
        page_size: int = None,
        total: int = None,
    ):
        self.current_page = current_page
        self.message_route_list = message_route_list
        self.page_size = page_size
        self.total = total

    def validate(self):
        if self.message_route_list:
            self.message_route_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.message_route_list is not None:
            result['MessageRouteList'] = self.message_route_list.to_map()
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('MessageRouteList') is not None:
            temp_model = QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteList()
            self.message_route_list = temp_model.from_map(m['MessageRouteList'])
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class QueryEdgeInstanceMessageRoutingResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryEdgeInstanceMessageRoutingResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryEdgeInstanceMessageRoutingResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryEdgeInstanceMessageRoutingResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryEdgeInstanceMessageRoutingResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryEdgeInstanceMessageRoutingResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryEdgeInstanceSceneRuleRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        instance_id: str = None,
        iot_instance_id: str = None,
        page_size: int = None,
    ):
        self.current_page = current_page
        self.instance_id = instance_id
        self.iot_instance_id = iot_instance_id
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class QueryEdgeInstanceSceneRuleResponseBodyDataRuleList(TeaModel):
    def __init__(
        self,
        gmt_create: int = None,
        is_existed: int = None,
        rule_id: str = None,
        rule_name: str = None,
        status: int = None,
    ):
        self.gmt_create = gmt_create
        self.is_existed = is_existed
        self.rule_id = rule_id
        self.rule_name = rule_name
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.is_existed is not None:
            result['IsExisted'] = self.is_existed
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('IsExisted') is not None:
            self.is_existed = m.get('IsExisted')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class QueryEdgeInstanceSceneRuleResponseBodyData(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        page_size: int = None,
        rule_list: List[QueryEdgeInstanceSceneRuleResponseBodyDataRuleList] = None,
        total: int = None,
    ):
        self.current_page = current_page
        self.page_size = page_size
        self.rule_list = rule_list
        self.total = total

    def validate(self):
        if self.rule_list:
            for k in self.rule_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        result['RuleList'] = []
        if self.rule_list is not None:
            for k in self.rule_list:
                result['RuleList'].append(k.to_map() if k else None)
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        self.rule_list = []
        if m.get('RuleList') is not None:
            for k in m.get('RuleList'):
                temp_model = QueryEdgeInstanceSceneRuleResponseBodyDataRuleList()
                self.rule_list.append(temp_model.from_map(k))
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class QueryEdgeInstanceSceneRuleResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryEdgeInstanceSceneRuleResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryEdgeInstanceSceneRuleResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryEdgeInstanceSceneRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryEdgeInstanceSceneRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryEdgeInstanceSceneRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryImportedDeviceByApplyIdRequest(TeaModel):
    def __init__(
        self,
        apply_id: int = None,
        iot_instance_id: str = None,
        page_no: int = None,
        page_size: int = None,
    ):
        # The application ID. You can call the [BatchImportDevice](~~433878~~) operation to obtain the application ID.
        self.apply_id = apply_id
        # The instance ID. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
        # 
        # >  If your instance has an ID, you must specify this parameter. Otherwise, the request fails. If no Overview page exists or no instance ID is displayed, you do not need to specify this parameter.
        # 
        # For more information, see the [Overview](~~356505~~) topic of IoT instances.
        self.iot_instance_id = iot_instance_id
        # The page number. Valid values: 1 to 10000.
        self.page_no = page_no
        # The number of entries per page. Default value: 10. Valid values: 1 to 50.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.apply_id is not None:
            result['ApplyId'] = self.apply_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApplyId') is not None:
            self.apply_id = m.get('ApplyId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class QueryImportedDeviceByApplyIdResponseBodyDeviceListDevice(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        device_secret: str = None,
        product_key: str = None,
        sn: str = None,
    ):
        # The DeviceName of the device.
        # 
        # >  Keep the information confidential.
        self.device_name = device_name
        # The DeviceSecret of the device.
        # 
        # >  Keep the information confidential.
        self.device_secret = device_secret
        # The **ProductKey** of the product to which the device belongs.
        self.product_key = product_key
        # The serial number (SN) of the device.
        # 
        # > If you did not specify an SN for the device, this parameter is empty.
        self.sn = sn

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.device_secret is not None:
            result['DeviceSecret'] = self.device_secret
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.sn is not None:
            result['Sn'] = self.sn
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('DeviceSecret') is not None:
            self.device_secret = m.get('DeviceSecret')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('Sn') is not None:
            self.sn = m.get('Sn')
        return self


class QueryImportedDeviceByApplyIdResponseBodyDeviceList(TeaModel):
    def __init__(
        self,
        device: List[QueryImportedDeviceByApplyIdResponseBodyDeviceListDevice] = None,
    ):
        self.device = device

    def validate(self):
        if self.device:
            for k in self.device:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['device'] = []
        if self.device is not None:
            for k in self.device:
                result['device'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.device = []
        if m.get('device') is not None:
            for k in m.get('device'):
                temp_model = QueryImportedDeviceByApplyIdResponseBodyDeviceListDevice()
                self.device.append(temp_model.from_map(k))
        return self


class QueryImportedDeviceByApplyIdResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        device_list: QueryImportedDeviceByApplyIdResponseBodyDeviceList = None,
        error_message: str = None,
        page_no: int = None,
        page_size: int = None,
        product_key: str = None,
        request_id: str = None,
        success: bool = None,
        total_page: int = None,
    ):
        # The error code returned if the request fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The queried devices.
        self.device_list = device_list
        # The error message returned if the request fails.
        self.error_message = error_message
        # The page number.
        self.page_no = page_no
        # The number of entries per page.
        self.page_size = page_size
        # The **ProductKey** of the product to which the devices belong.
        self.product_key = product_key
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success
        # The total number of pages returned.
        self.total_page = total_page

    def validate(self):
        if self.device_list:
            self.device_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.device_list is not None:
            result['DeviceList'] = self.device_list.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total_page is not None:
            result['TotalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('DeviceList') is not None:
            temp_model = QueryImportedDeviceByApplyIdResponseBodyDeviceList()
            self.device_list = temp_model.from_map(m['DeviceList'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalPage') is not None:
            self.total_page = m.get('TotalPage')
        return self


class QueryImportedDeviceByApplyIdResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryImportedDeviceByApplyIdResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryImportedDeviceByApplyIdResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryJobRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        job_id: str = None,
    ):
        self.iot_instance_id = iot_instance_id
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class QueryJobResponseBodyDataJobFile(TeaModel):
    def __init__(
        self,
        file_url: str = None,
        sign: str = None,
        sign_method: str = None,
    ):
        self.file_url = file_url
        self.sign = sign
        self.sign_method = sign_method

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.sign is not None:
            result['Sign'] = self.sign
        if self.sign_method is not None:
            result['SignMethod'] = self.sign_method
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('Sign') is not None:
            self.sign = m.get('Sign')
        if m.get('SignMethod') is not None:
            self.sign_method = m.get('SignMethod')
        return self


class QueryJobResponseBodyDataRolloutConfig(TeaModel):
    def __init__(
        self,
        maximum_per_minute: int = None,
        message_qo_s: str = None,
    ):
        self.maximum_per_minute = maximum_per_minute
        self.message_qo_s = message_qo_s

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.maximum_per_minute is not None:
            result['MaximumPerMinute'] = self.maximum_per_minute
        if self.message_qo_s is not None:
            result['MessageQoS'] = self.message_qo_s
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MaximumPerMinute') is not None:
            self.maximum_per_minute = m.get('MaximumPerMinute')
        if m.get('MessageQoS') is not None:
            self.message_qo_s = m.get('MessageQoS')
        return self


class QueryJobResponseBodyDataTargetConfigTargetDevicesTargetDevices(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        product_key: str = None,
    ):
        self.device_name = device_name
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class QueryJobResponseBodyDataTargetConfigTargetDevices(TeaModel):
    def __init__(
        self,
        target_devices: List[QueryJobResponseBodyDataTargetConfigTargetDevicesTargetDevices] = None,
    ):
        self.target_devices = target_devices

    def validate(self):
        if self.target_devices:
            for k in self.target_devices:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['targetDevices'] = []
        if self.target_devices is not None:
            for k in self.target_devices:
                result['targetDevices'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.target_devices = []
        if m.get('targetDevices') is not None:
            for k in m.get('targetDevices'):
                temp_model = QueryJobResponseBodyDataTargetConfigTargetDevicesTargetDevices()
                self.target_devices.append(temp_model.from_map(k))
        return self


class QueryJobResponseBodyDataTargetConfig(TeaModel):
    def __init__(
        self,
        target_devices: QueryJobResponseBodyDataTargetConfigTargetDevices = None,
        target_group: str = None,
        target_product: str = None,
        target_type: str = None,
    ):
        self.target_devices = target_devices
        self.target_group = target_group
        self.target_product = target_product
        self.target_type = target_type

    def validate(self):
        if self.target_devices:
            self.target_devices.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.target_devices is not None:
            result['TargetDevices'] = self.target_devices.to_map()
        if self.target_group is not None:
            result['TargetGroup'] = self.target_group
        if self.target_product is not None:
            result['TargetProduct'] = self.target_product
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TargetDevices') is not None:
            temp_model = QueryJobResponseBodyDataTargetConfigTargetDevices()
            self.target_devices = temp_model.from_map(m['TargetDevices'])
        if m.get('TargetGroup') is not None:
            self.target_group = m.get('TargetGroup')
        if m.get('TargetProduct') is not None:
            self.target_product = m.get('TargetProduct')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        return self


class QueryJobResponseBodyDataTimeoutConfig(TeaModel):
    def __init__(
        self,
        in_progress_timeout_in_minutes: int = None,
    ):
        self.in_progress_timeout_in_minutes = in_progress_timeout_in_minutes

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.in_progress_timeout_in_minutes is not None:
            result['InProgressTimeoutInMinutes'] = self.in_progress_timeout_in_minutes
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InProgressTimeoutInMinutes') is not None:
            self.in_progress_timeout_in_minutes = m.get('InProgressTimeoutInMinutes')
        return self


class QueryJobResponseBodyData(TeaModel):
    def __init__(
        self,
        description: str = None,
        job_document: str = None,
        job_file: QueryJobResponseBodyDataJobFile = None,
        job_id: str = None,
        job_name: str = None,
        rollout_config: QueryJobResponseBodyDataRolloutConfig = None,
        scheduled_time: int = None,
        status: str = None,
        target_config: QueryJobResponseBodyDataTargetConfig = None,
        timeout_config: QueryJobResponseBodyDataTimeoutConfig = None,
        type: str = None,
        utc_create: str = None,
        utc_modified: str = None,
    ):
        self.description = description
        self.job_document = job_document
        self.job_file = job_file
        self.job_id = job_id
        self.job_name = job_name
        self.rollout_config = rollout_config
        self.scheduled_time = scheduled_time
        self.status = status
        self.target_config = target_config
        self.timeout_config = timeout_config
        self.type = type
        self.utc_create = utc_create
        self.utc_modified = utc_modified

    def validate(self):
        if self.job_file:
            self.job_file.validate()
        if self.rollout_config:
            self.rollout_config.validate()
        if self.target_config:
            self.target_config.validate()
        if self.timeout_config:
            self.timeout_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.job_document is not None:
            result['JobDocument'] = self.job_document
        if self.job_file is not None:
            result['JobFile'] = self.job_file.to_map()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.job_name is not None:
            result['JobName'] = self.job_name
        if self.rollout_config is not None:
            result['RolloutConfig'] = self.rollout_config.to_map()
        if self.scheduled_time is not None:
            result['ScheduledTime'] = self.scheduled_time
        if self.status is not None:
            result['Status'] = self.status
        if self.target_config is not None:
            result['TargetConfig'] = self.target_config.to_map()
        if self.timeout_config is not None:
            result['TimeoutConfig'] = self.timeout_config.to_map()
        if self.type is not None:
            result['Type'] = self.type
        if self.utc_create is not None:
            result['UtcCreate'] = self.utc_create
        if self.utc_modified is not None:
            result['UtcModified'] = self.utc_modified
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('JobDocument') is not None:
            self.job_document = m.get('JobDocument')
        if m.get('JobFile') is not None:
            temp_model = QueryJobResponseBodyDataJobFile()
            self.job_file = temp_model.from_map(m['JobFile'])
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('JobName') is not None:
            self.job_name = m.get('JobName')
        if m.get('RolloutConfig') is not None:
            temp_model = QueryJobResponseBodyDataRolloutConfig()
            self.rollout_config = temp_model.from_map(m['RolloutConfig'])
        if m.get('ScheduledTime') is not None:
            self.scheduled_time = m.get('ScheduledTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TargetConfig') is not None:
            temp_model = QueryJobResponseBodyDataTargetConfig()
            self.target_config = temp_model.from_map(m['TargetConfig'])
        if m.get('TimeoutConfig') is not None:
            temp_model = QueryJobResponseBodyDataTimeoutConfig()
            self.timeout_config = temp_model.from_map(m['TimeoutConfig'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UtcCreate') is not None:
            self.utc_create = m.get('UtcCreate')
        if m.get('UtcModified') is not None:
            self.utc_modified = m.get('UtcModified')
        return self


class QueryJobResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryJobResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryJobResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryJobStatisticsRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        job_id: str = None,
    ):
        self.iot_instance_id = iot_instance_id
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class QueryJobStatisticsResponseBodyData(TeaModel):
    def __init__(
        self,
        cancelled: int = None,
        failed: int = None,
        in_progress: int = None,
        queued: int = None,
        rejected: int = None,
        sent: int = None,
        succeeded: int = None,
        time_out: int = None,
        total: int = None,
    ):
        self.cancelled = cancelled
        self.failed = failed
        self.in_progress = in_progress
        self.queued = queued
        self.rejected = rejected
        self.sent = sent
        self.succeeded = succeeded
        self.time_out = time_out
        self.total = total

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cancelled is not None:
            result['Cancelled'] = self.cancelled
        if self.failed is not None:
            result['Failed'] = self.failed
        if self.in_progress is not None:
            result['InProgress'] = self.in_progress
        if self.queued is not None:
            result['Queued'] = self.queued
        if self.rejected is not None:
            result['Rejected'] = self.rejected
        if self.sent is not None:
            result['Sent'] = self.sent
        if self.succeeded is not None:
            result['Succeeded'] = self.succeeded
        if self.time_out is not None:
            result['TimeOut'] = self.time_out
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Cancelled') is not None:
            self.cancelled = m.get('Cancelled')
        if m.get('Failed') is not None:
            self.failed = m.get('Failed')
        if m.get('InProgress') is not None:
            self.in_progress = m.get('InProgress')
        if m.get('Queued') is not None:
            self.queued = m.get('Queued')
        if m.get('Rejected') is not None:
            self.rejected = m.get('Rejected')
        if m.get('Sent') is not None:
            self.sent = m.get('Sent')
        if m.get('Succeeded') is not None:
            self.succeeded = m.get('Succeeded')
        if m.get('TimeOut') is not None:
            self.time_out = m.get('TimeOut')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class QueryJobStatisticsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryJobStatisticsResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryJobStatisticsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryJobStatisticsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryJobStatisticsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryJobStatisticsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryLicenseDeviceListRequest(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        iot_id: str = None,
        iot_instance_id: str = None,
        license_code: str = None,
        page_id: int = None,
        page_size: int = None,
        product_key: str = None,
        start_time: int = None,
    ):
        # The end time of the time range in which the license is bound to the devices.The timestamp follows the UNIX time format. It is the number of seconds that have elapsed since 00:00:00 Thursday, January 1, 1970.
        self.end_time = end_time
        # The ID of the device.
        # 
        # You can call the [QueryDevice](~~69905~~) operation to query the **IotId** values of all devices that belong to a specific product.
        self.iot_id = iot_id
        # The instance ID. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
        # 
        # >  You must specify this parameter for a public instance of the new version or an Enterprise Edition instance. You do not need to specify this parameter for a public instance of the previous version.
        # 
        # For more information, see the [Overview](~~356505~~) topic of IoT instances.
        self.iot_instance_id = iot_instance_id
        # The license type that specifies the audio and video specifications. Valid values: **480P** and **720P**.
        self.license_code = license_code
        # The page number.
        self.page_id = page_id
        # The number of entries per page. Valid values: 1 to 100. Default value: 20.
        self.page_size = page_size
        # The **ProductKey** of the product to which the devices belong.
        # 
        # You can go to the IoT Platform console or call the [QueryProductList](~~69271~~) operation to view the information about all products of the instance.
        self.product_key = product_key
        # The start time of the time range in which the license is bound to the devices. The timestamp follows the UNIX time format. It is the number of seconds that have elapsed since 00:00:00 Thursday, January 1, 1970.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.license_code is not None:
            result['LicenseCode'] = self.license_code
        if self.page_id is not None:
            result['PageId'] = self.page_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('LicenseCode') is not None:
            self.license_code = m.get('LicenseCode')
        if m.get('PageId') is not None:
            self.page_id = m.get('PageId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class QueryLicenseDeviceListResponseBodyDataDeviceListItem(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        expiry_time: int = None,
        gmt_create: int = None,
        iot_id: str = None,
        license_code: str = None,
        product_key: str = None,
        product_name: str = None,
    ):
        # The DeviceName of the device.
        self.device_name = device_name
        # The expiration time of the license.
        self.expiry_time = expiry_time
        # The time when the license was bound to the device.
        self.gmt_create = gmt_create
        # The device ID.
        self.iot_id = iot_id
        # The license type that indicates the audio and video specifications. Valid values: **480P** and **720P**.
        self.license_code = license_code
        # The **ProductKey** of the product to which the device belongs.
        self.product_key = product_key
        # The ProductName of the product.
        self.product_name = product_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.expiry_time is not None:
            result['ExpiryTime'] = self.expiry_time
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.license_code is not None:
            result['LicenseCode'] = self.license_code
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.product_name is not None:
            result['ProductName'] = self.product_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('ExpiryTime') is not None:
            self.expiry_time = m.get('ExpiryTime')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('LicenseCode') is not None:
            self.license_code = m.get('LicenseCode')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('ProductName') is not None:
            self.product_name = m.get('ProductName')
        return self


class QueryLicenseDeviceListResponseBodyDataDeviceList(TeaModel):
    def __init__(
        self,
        item: List[QueryLicenseDeviceListResponseBodyDataDeviceListItem] = None,
    ):
        self.item = item

    def validate(self):
        if self.item:
            for k in self.item:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['item'] = []
        if self.item is not None:
            for k in self.item:
                result['item'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.item = []
        if m.get('item') is not None:
            for k in m.get('item'):
                temp_model = QueryLicenseDeviceListResponseBodyDataDeviceListItem()
                self.item.append(temp_model.from_map(k))
        return self


class QueryLicenseDeviceListResponseBodyData(TeaModel):
    def __init__(
        self,
        device_list: QueryLicenseDeviceListResponseBodyDataDeviceList = None,
        page_id: int = None,
        page_size: int = None,
        total: int = None,
    ):
        # The information about the devices.
        self.device_list = device_list
        # The page number.
        self.page_id = page_id
        # The number of entries per page.
        self.page_size = page_size
        # The total number of entries returned.
        self.total = total

    def validate(self):
        if self.device_list:
            self.device_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_list is not None:
            result['DeviceList'] = self.device_list.to_map()
        if self.page_id is not None:
            result['PageId'] = self.page_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceList') is not None:
            temp_model = QueryLicenseDeviceListResponseBodyDataDeviceList()
            self.device_list = temp_model.from_map(m['DeviceList'])
        if m.get('PageId') is not None:
            self.page_id = m.get('PageId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class QueryLicenseDeviceListResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryLicenseDeviceListResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request fails. For more information, see the **"Error codes"** section in this topic.
        self.code = code
        # The response message.
        self.data = data
        # The error message returned if the request fails.
        self.error_message = error_message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryLicenseDeviceListResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryLicenseDeviceListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryLicenseDeviceListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryLicenseDeviceListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryLoRaJoinPermissionsRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
    ):
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class QueryLoRaJoinPermissionsResponseBodyJoinPermissionsJoinPermission(TeaModel):
    def __init__(
        self,
        class_mode: str = None,
        enabled: bool = None,
        join_permission_id: str = None,
        join_permission_name: str = None,
        join_permission_type: str = None,
        owner_aliyun_pk: str = None,
    ):
        self.class_mode = class_mode
        self.enabled = enabled
        self.join_permission_id = join_permission_id
        self.join_permission_name = join_permission_name
        self.join_permission_type = join_permission_type
        self.owner_aliyun_pk = owner_aliyun_pk

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.class_mode is not None:
            result['ClassMode'] = self.class_mode
        if self.enabled is not None:
            result['Enabled'] = self.enabled
        if self.join_permission_id is not None:
            result['JoinPermissionId'] = self.join_permission_id
        if self.join_permission_name is not None:
            result['JoinPermissionName'] = self.join_permission_name
        if self.join_permission_type is not None:
            result['JoinPermissionType'] = self.join_permission_type
        if self.owner_aliyun_pk is not None:
            result['OwnerAliyunPk'] = self.owner_aliyun_pk
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClassMode') is not None:
            self.class_mode = m.get('ClassMode')
        if m.get('Enabled') is not None:
            self.enabled = m.get('Enabled')
        if m.get('JoinPermissionId') is not None:
            self.join_permission_id = m.get('JoinPermissionId')
        if m.get('JoinPermissionName') is not None:
            self.join_permission_name = m.get('JoinPermissionName')
        if m.get('JoinPermissionType') is not None:
            self.join_permission_type = m.get('JoinPermissionType')
        if m.get('OwnerAliyunPk') is not None:
            self.owner_aliyun_pk = m.get('OwnerAliyunPk')
        return self


class QueryLoRaJoinPermissionsResponseBodyJoinPermissions(TeaModel):
    def __init__(
        self,
        join_permission: List[QueryLoRaJoinPermissionsResponseBodyJoinPermissionsJoinPermission] = None,
    ):
        self.join_permission = join_permission

    def validate(self):
        if self.join_permission:
            for k in self.join_permission:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['JoinPermission'] = []
        if self.join_permission is not None:
            for k in self.join_permission:
                result['JoinPermission'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.join_permission = []
        if m.get('JoinPermission') is not None:
            for k in m.get('JoinPermission'):
                temp_model = QueryLoRaJoinPermissionsResponseBodyJoinPermissionsJoinPermission()
                self.join_permission.append(temp_model.from_map(k))
        return self


class QueryLoRaJoinPermissionsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        join_permissions: QueryLoRaJoinPermissionsResponseBodyJoinPermissions = None,
        product_key: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.join_permissions = join_permissions
        self.product_key = product_key
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.join_permissions:
            self.join_permissions.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.join_permissions is not None:
            result['JoinPermissions'] = self.join_permissions.to_map()
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('JoinPermissions') is not None:
            temp_model = QueryLoRaJoinPermissionsResponseBodyJoinPermissions()
            self.join_permissions = temp_model.from_map(m['JoinPermissions'])
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryLoRaJoinPermissionsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryLoRaJoinPermissionsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryLoRaJoinPermissionsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryMessageInfoRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        uni_msg_id: str = None,
    ):
        self.iot_instance_id = iot_instance_id
        self.uni_msg_id = uni_msg_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.uni_msg_id is not None:
            result['UniMsgId'] = self.uni_msg_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('UniMsgId') is not None:
            self.uni_msg_id = m.get('UniMsgId')
        return self


class QueryMessageInfoResponseBodyMessageMqttProperties(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        self.key = key
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class QueryMessageInfoResponseBodyMessageUserProperties(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        self.key = key
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class QueryMessageInfoResponseBodyMessage(TeaModel):
    def __init__(
        self,
        generate_time: int = None,
        message_content: str = None,
        mqtt_properties: List[QueryMessageInfoResponseBodyMessageMqttProperties] = None,
        topic_full_name: str = None,
        transformed_message_content: str = None,
        transformed_topic_full_name: str = None,
        uni_msg_id: str = None,
        user_properties: List[QueryMessageInfoResponseBodyMessageUserProperties] = None,
    ):
        self.generate_time = generate_time
        self.message_content = message_content
        self.mqtt_properties = mqtt_properties
        self.topic_full_name = topic_full_name
        self.transformed_message_content = transformed_message_content
        self.transformed_topic_full_name = transformed_topic_full_name
        self.uni_msg_id = uni_msg_id
        self.user_properties = user_properties

    def validate(self):
        if self.mqtt_properties:
            for k in self.mqtt_properties:
                if k:
                    k.validate()
        if self.user_properties:
            for k in self.user_properties:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.generate_time is not None:
            result['GenerateTime'] = self.generate_time
        if self.message_content is not None:
            result['MessageContent'] = self.message_content
        result['MqttProperties'] = []
        if self.mqtt_properties is not None:
            for k in self.mqtt_properties:
                result['MqttProperties'].append(k.to_map() if k else None)
        if self.topic_full_name is not None:
            result['TopicFullName'] = self.topic_full_name
        if self.transformed_message_content is not None:
            result['TransformedMessageContent'] = self.transformed_message_content
        if self.transformed_topic_full_name is not None:
            result['TransformedTopicFullName'] = self.transformed_topic_full_name
        if self.uni_msg_id is not None:
            result['UniMsgId'] = self.uni_msg_id
        result['UserProperties'] = []
        if self.user_properties is not None:
            for k in self.user_properties:
                result['UserProperties'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GenerateTime') is not None:
            self.generate_time = m.get('GenerateTime')
        if m.get('MessageContent') is not None:
            self.message_content = m.get('MessageContent')
        self.mqtt_properties = []
        if m.get('MqttProperties') is not None:
            for k in m.get('MqttProperties'):
                temp_model = QueryMessageInfoResponseBodyMessageMqttProperties()
                self.mqtt_properties.append(temp_model.from_map(k))
        if m.get('TopicFullName') is not None:
            self.topic_full_name = m.get('TopicFullName')
        if m.get('TransformedMessageContent') is not None:
            self.transformed_message_content = m.get('TransformedMessageContent')
        if m.get('TransformedTopicFullName') is not None:
            self.transformed_topic_full_name = m.get('TransformedTopicFullName')
        if m.get('UniMsgId') is not None:
            self.uni_msg_id = m.get('UniMsgId')
        self.user_properties = []
        if m.get('UserProperties') is not None:
            for k in m.get('UserProperties'):
                temp_model = QueryMessageInfoResponseBodyMessageUserProperties()
                self.user_properties.append(temp_model.from_map(k))
        return self


class QueryMessageInfoResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        message: QueryMessageInfoResponseBodyMessage = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.message:
            self.message.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.message is not None:
            result['Message'] = self.message.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Message') is not None:
            temp_model = QueryMessageInfoResponseBodyMessage()
            self.message = temp_model.from_map(m['Message'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryMessageInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryMessageInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryMessageInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryOTAFirmwareRequest(TeaModel):
    def __init__(
        self,
        firmware_id: str = None,
        iot_instance_id: str = None,
    ):
        # The unique ID of the OTA update package.
        # 
        # An update package ID is returned when you call the [CreateOTAFirmware](~~147311~~) operation to create the update package.
        # 
        # You can call the [ListOTAFirmware](~~147450~~) operation and view the update package ID in the response.
        self.firmware_id = firmware_id
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.firmware_id is not None:
            result['FirmwareId'] = self.firmware_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FirmwareId') is not None:
            self.firmware_id = m.get('FirmwareId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class QueryOTAFirmwareResponseBodyFirmwareInfoMultiFiles(TeaModel):
    def __init__(
        self,
        file_md_5: str = None,
        name: str = None,
        sign_value: str = None,
        size: int = None,
        url: str = None,
    ):
        # The MD5 value of the OTA update package file.
        self.file_md_5 = file_md_5
        # The name of the OTA update package file.
        self.name = name
        # The signature of the OTA update package file.
        self.sign_value = sign_value
        # The size of the OTA update package file. Unit: bytes.
        self.size = size
        # The URL of the update package file that is stored in Object Storage Service (OSS).
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_md_5 is not None:
            result['FileMd5'] = self.file_md_5
        if self.name is not None:
            result['Name'] = self.name
        if self.sign_value is not None:
            result['SignValue'] = self.sign_value
        if self.size is not None:
            result['Size'] = self.size
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FileMd5') is not None:
            self.file_md_5 = m.get('FileMd5')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('SignValue') is not None:
            self.sign_value = m.get('SignValue')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class QueryOTAFirmwareResponseBodyFirmwareInfo(TeaModel):
    def __init__(
        self,
        dest_version: str = None,
        firmware_desc: str = None,
        firmware_id: str = None,
        firmware_name: str = None,
        firmware_sign: str = None,
        firmware_size: int = None,
        firmware_url: str = None,
        module_name: str = None,
        multi_files: List[QueryOTAFirmwareResponseBodyFirmwareInfoMultiFiles] = None,
        product_key: str = None,
        product_name: str = None,
        sign_method: str = None,
        src_version: str = None,
        status: int = None,
        type: int = None,
        udi: str = None,
        utc_create: str = None,
        utc_modified: str = None,
        verify_progress: int = None,
    ):
        # The version number of the OTA update package.
        self.dest_version = dest_version
        # The description of the OTA update package.
        self.firmware_desc = firmware_desc
        # The unique ID of the OTA update package.
        self.firmware_id = firmware_id
        # The name of the OTA update package.
        self.firmware_name = firmware_name
        # The signature of the OTA update package.
        # 
        # >  This parameter is available if the OTA update package contains a single file.
        self.firmware_sign = firmware_sign
        # The size of the OTA update package file. Unit: bytes.
        # 
        # >  This parameter is available if the OTA update package contains a single file.
        self.firmware_size = firmware_size
        # The URL of the update package file that is stored in Object Storage Service (OSS).
        # 
        # >  This parameter is available if the OTA update package contains a single file.
        self.firmware_url = firmware_url
        # The name of the module.
        # 
        # OTA updates are based on the firmware modules of a device. For more information, see [Add a custom OTA module to an update package](~~202664~~).
        self.module_name = module_name
        # The information about the OTA update package files. This parameter is available if the OTA update package contains multiple files.
        self.multi_files = multi_files
        # The **ProductKey** of the product to which the OTA update package belongs.
        self.product_key = product_key
        # The name of the product to which the OTA update package belongs.
        self.product_name = product_name
        # The signature method of the OTA update package.
        self.sign_method = sign_method
        # The version number of the original update package to be updated.
        # 
        # >  This parameter is returned if you perform a delta update. For more information about update package types, see the description of the **Type** parameter.
        self.src_version = src_version
        # The status of the OTA update package. Valid values:
        # 
        # *   **-1**: no verification is required
        # *   **0**: unverified
        # *   **1**: verified
        # *   **2**: verifying
        # *   **3**: failed to be verified
        self.status = status
        # The type of the OTA update package. Valid values:
        # 
        # *   **0**: The uploaded file contains a full update package. IoT Platform pushes the full update package to a device for update.
        # *   **1**: The uploaded file contains only the differences between the latest update package and previous update package. IoT Platform pushes only the differences to a device for update.
        self.type = type
        # The custom information that was pushed to the device. The information can be up to 4,096 characters in length. No limit is applies to the content format.
        # 
        # After you add the update package and create an update task, IoT Platform sends the custom information to the specified device when IoT Platform pushes the update notification.
        self.udi = udi
        # The time when the OTA update package was created. The time is displayed in UTC.
        self.utc_create = utc_create
        # The time when the update task was last modified. The time is displayed in UTC.
        self.utc_modified = utc_modified
        # The verification status of the OTA update package. Valid values:
        # 
        # *   **0**: unverified
        # *   **100**: verified
        # *   A value N between 0 and 100 indicates that the update task is N percent completed. You can check the response parameter **Status** to see the verification status.
        self.verify_progress = verify_progress

    def validate(self):
        if self.multi_files:
            for k in self.multi_files:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dest_version is not None:
            result['DestVersion'] = self.dest_version
        if self.firmware_desc is not None:
            result['FirmwareDesc'] = self.firmware_desc
        if self.firmware_id is not None:
            result['FirmwareId'] = self.firmware_id
        if self.firmware_name is not None:
            result['FirmwareName'] = self.firmware_name
        if self.firmware_sign is not None:
            result['FirmwareSign'] = self.firmware_sign
        if self.firmware_size is not None:
            result['FirmwareSize'] = self.firmware_size
        if self.firmware_url is not None:
            result['FirmwareUrl'] = self.firmware_url
        if self.module_name is not None:
            result['ModuleName'] = self.module_name
        result['MultiFiles'] = []
        if self.multi_files is not None:
            for k in self.multi_files:
                result['MultiFiles'].append(k.to_map() if k else None)
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.product_name is not None:
            result['ProductName'] = self.product_name
        if self.sign_method is not None:
            result['SignMethod'] = self.sign_method
        if self.src_version is not None:
            result['SrcVersion'] = self.src_version
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        if self.udi is not None:
            result['Udi'] = self.udi
        if self.utc_create is not None:
            result['UtcCreate'] = self.utc_create
        if self.utc_modified is not None:
            result['UtcModified'] = self.utc_modified
        if self.verify_progress is not None:
            result['VerifyProgress'] = self.verify_progress
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DestVersion') is not None:
            self.dest_version = m.get('DestVersion')
        if m.get('FirmwareDesc') is not None:
            self.firmware_desc = m.get('FirmwareDesc')
        if m.get('FirmwareId') is not None:
            self.firmware_id = m.get('FirmwareId')
        if m.get('FirmwareName') is not None:
            self.firmware_name = m.get('FirmwareName')
        if m.get('FirmwareSign') is not None:
            self.firmware_sign = m.get('FirmwareSign')
        if m.get('FirmwareSize') is not None:
            self.firmware_size = m.get('FirmwareSize')
        if m.get('FirmwareUrl') is not None:
            self.firmware_url = m.get('FirmwareUrl')
        if m.get('ModuleName') is not None:
            self.module_name = m.get('ModuleName')
        self.multi_files = []
        if m.get('MultiFiles') is not None:
            for k in m.get('MultiFiles'):
                temp_model = QueryOTAFirmwareResponseBodyFirmwareInfoMultiFiles()
                self.multi_files.append(temp_model.from_map(k))
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('ProductName') is not None:
            self.product_name = m.get('ProductName')
        if m.get('SignMethod') is not None:
            self.sign_method = m.get('SignMethod')
        if m.get('SrcVersion') is not None:
            self.src_version = m.get('SrcVersion')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Udi') is not None:
            self.udi = m.get('Udi')
        if m.get('UtcCreate') is not None:
            self.utc_create = m.get('UtcCreate')
        if m.get('UtcModified') is not None:
            self.utc_modified = m.get('UtcModified')
        if m.get('VerifyProgress') is not None:
            self.verify_progress = m.get('VerifyProgress')
        return self


class QueryOTAFirmwareResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        firmware_info: QueryOTAFirmwareResponseBodyFirmwareInfo = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The update package information returned if the call succeeds. For more information, see **FirmwareInfo**.
        self.firmware_info = firmware_info
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.firmware_info:
            self.firmware_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.firmware_info is not None:
            result['FirmwareInfo'] = self.firmware_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('FirmwareInfo') is not None:
            temp_model = QueryOTAFirmwareResponseBodyFirmwareInfo()
            self.firmware_info = temp_model.from_map(m['FirmwareInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryOTAFirmwareResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryOTAFirmwareResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryOTAFirmwareResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryOTAJobRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        job_id: str = None,
    ):
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The ID of the update batch.
        # 
        # After you call the [CreateOTAVerifyJob](~~147480~~), [CreateOTAStaticUpgradeJob](~~147496~~), or [CreateOTADynamicUpgradeJob](~~147887~~) API operation to create the update batch, you can obtain the **JobId** parameter. You can also view the batch ID on the **Update Package Details** page of the IoT Platform console.
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class QueryOTAJobResponseBodyDataSrcVersions(TeaModel):
    def __init__(
        self,
        src_version: List[str] = None,
    ):
        self.src_version = src_version

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.src_version is not None:
            result['SrcVersion'] = self.src_version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('SrcVersion') is not None:
            self.src_version = m.get('SrcVersion')
        return self


class QueryOTAJobResponseBodyDataTagsOtaTagDTO(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # The key of each tag.
        self.key = key
        # The value of the tag.
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class QueryOTAJobResponseBodyDataTags(TeaModel):
    def __init__(
        self,
        ota_tag_dto: List[QueryOTAJobResponseBodyDataTagsOtaTagDTO] = None,
    ):
        self.ota_tag_dto = ota_tag_dto

    def validate(self):
        if self.ota_tag_dto:
            for k in self.ota_tag_dto:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['OtaTagDTO'] = []
        if self.ota_tag_dto is not None:
            for k in self.ota_tag_dto:
                result['OtaTagDTO'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.ota_tag_dto = []
        if m.get('OtaTagDTO') is not None:
            for k in m.get('OtaTagDTO'):
                temp_model = QueryOTAJobResponseBodyDataTagsOtaTagDTO()
                self.ota_tag_dto.append(temp_model.from_map(k))
        return self


class QueryOTAJobResponseBodyData(TeaModel):
    def __init__(
        self,
        dest_version: str = None,
        download_protocol: str = None,
        dynamic_mode: int = None,
        firmware_id: str = None,
        gray_percent: str = None,
        group_id: str = None,
        group_name: str = None,
        job_desc: str = None,
        job_id: str = None,
        job_status: str = None,
        job_type: str = None,
        maximum_per_minute: int = None,
        multi_module_mode: bool = None,
        name: str = None,
        need_confirm: bool = None,
        need_push: bool = None,
        overwrite_mode: int = None,
        product_key: str = None,
        retry_count: int = None,
        retry_interval: int = None,
        selection_type: str = None,
        src_versions: QueryOTAJobResponseBodyDataSrcVersions = None,
        tags: QueryOTAJobResponseBodyDataTags = None,
        target_selection: str = None,
        timeout_in_minutes: int = None,
        utc_create: str = None,
        utc_end_time: str = None,
        utc_modified: str = None,
        utc_schedule_finish_time: str = None,
        utc_schedule_time: str = None,
        utc_start_time: str = None,
    ):
        # The destination firmware version of the update.
        self.dest_version = dest_version
        # The download protocol of the update package.
        self.download_protocol = download_protocol
        # The mode of dynamic update. Valid values:
        # 
        # *   **1**: constantly updates the devices that meet the conditions.
        # *   **2**: updates only the devices that subsequently submit the latest firmware versions.
        # 
        # This parameter is returned only if you perform a dynamic update.
        self.dynamic_mode = dynamic_mode
        # The ID of the update package.
        self.firmware_id = firmware_id
        # The phase ratio of the phased update.
        # 
        # This parameter is returned only if you perform a phased update.
        self.gray_percent = gray_percent
        # The ID of the device group to be updated.
        self.group_id = group_id
        # The name of the device group to be updated.
        self.group_name = group_name
        # The description of the update batch.
        self.job_desc = job_desc
        # The ID of the update batch.
        self.job_id = job_id
        # The status of the update batch.
        # 
        # *   **PLANNED**: The update batch is being planned. The batch is created, but the scheduled time has not arrived. This parameter is returned only if you perform a static update.
        # *   **IN_PROGRESS**: The update batch is running.
        # *   **COMPLETED**: The update batch is completed.
        # *   **CANCELED**: The update batch is canceled.
        self.job_status = job_status
        # The type of the batch. Valid values:
        # 
        # *   **VERFIY_FIRMWARE**: update package verification.
        # *   **UPGRADE_FIRMWARE**: batch update.
        self.job_type = job_type
        # The maximum number of devices to which the download URL of the update package is pushed per minute.
        self.maximum_per_minute = maximum_per_minute
        # Specifies whether the device supports simultaneous updates of multiple modules.
        # 
        # *   **false** (default): no.
        # *   **true**: yes.
        # 
        # For more information, see [Overview](~~58328~~).
        self.multi_module_mode = multi_module_mode
        # The name of the update package.
        self.name = name
        # Specifies whether to confirm the update by using your mobile app.
        self.need_confirm = need_confirm
        # Specifies whether to automatically push update tasks from IoT Platform to devices.
        self.need_push = need_push
        # Specifies whether to overwrite the previous update task. Valid values:
        # 
        # *   **1**: The previous update task is not overwritten. If a device already has an update task, the previous update task is implemented.
        # *   **2**: The previous update task is overwritten. Only the current update task is implemented.
        # 
        # The update task that is in progress is not overwritten.
        self.overwrite_mode = overwrite_mode
        # The ProductKey of the product to which the update package belongs.
        self.product_key = product_key
        # The number of automatic retries after a device fails to be updated.
        # 
        # This parameter is returned if a retry policy is set when you create the update batch.
        self.retry_count = retry_count
        # The automatic retry interval after a device fails to be updated. Unit: minutes.
        # 
        # This parameter is returned if a retry policy is set when you create the update batch.
        self.retry_interval = retry_interval
        # The update policy of the update batch. Valid values:
        # 
        # *   **DYNAMIC**: dynamic update. This value is returned if you call the [CreateOTADynamicUpgradeJob](~~147887~~) API operation to create an update batch.
        # *   **STATIC**: static update. This value is returned if you call the [CreateOTAStaticUpgradeJob](~~147496~~) API operation to create an update batch.
        self.selection_type = selection_type
        # The list of firmware versions to be updated.
        self.src_versions = src_versions
        # The tags of the update batch.
        self.tags = tags
        # The scope of the update batch. Valid values: 
        # 
        # - **ALL**: updates all devices.
        # - **SPECIFIC**: updates specified devices.
        # - **GRAY**: performs a phased update.
        # 
        # >  The value ALL is returned if you call the [CreateOTADynamicUpgradeJob](/help/en/iot-platform/latest/av6dui) API operation to create an update batch.
        self.target_selection = target_selection
        # The timeout period of the device update. Unit: minutes.
        # 
        # This parameter is returned if the timeout period is set when you create the update batch.
        self.timeout_in_minutes = timeout_in_minutes
        # The time when the update batch was created. The time is displayed in UTC.
        self.utc_create = utc_create
        # The end time of the update batch. The time is displayed in UTC.
        # 
        # This parameter is returned only after the update batch is completed.
        self.utc_end_time = utc_end_time
        # The time when the update batch was last modified. The time is displayed in UTC.
        self.utc_modified = utc_modified
        # The end time of the scheduled update batch. This parameter is returned only if the update batch is scheduled and the end time of the scheduled update batch is specified.
        self.utc_schedule_finish_time = utc_schedule_finish_time
        # The start time of the scheduled update batch. This parameter is returned only for scheduled update batches.
        self.utc_schedule_time = utc_schedule_time
        # The start time of the update batch. The time is displayed in UTC.
        self.utc_start_time = utc_start_time

    def validate(self):
        if self.src_versions:
            self.src_versions.validate()
        if self.tags:
            self.tags.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dest_version is not None:
            result['DestVersion'] = self.dest_version
        if self.download_protocol is not None:
            result['DownloadProtocol'] = self.download_protocol
        if self.dynamic_mode is not None:
            result['DynamicMode'] = self.dynamic_mode
        if self.firmware_id is not None:
            result['FirmwareId'] = self.firmware_id
        if self.gray_percent is not None:
            result['GrayPercent'] = self.gray_percent
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.job_desc is not None:
            result['JobDesc'] = self.job_desc
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.job_status is not None:
            result['JobStatus'] = self.job_status
        if self.job_type is not None:
            result['JobType'] = self.job_type
        if self.maximum_per_minute is not None:
            result['MaximumPerMinute'] = self.maximum_per_minute
        if self.multi_module_mode is not None:
            result['MultiModuleMode'] = self.multi_module_mode
        if self.name is not None:
            result['Name'] = self.name
        if self.need_confirm is not None:
            result['NeedConfirm'] = self.need_confirm
        if self.need_push is not None:
            result['NeedPush'] = self.need_push
        if self.overwrite_mode is not None:
            result['OverwriteMode'] = self.overwrite_mode
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.retry_count is not None:
            result['RetryCount'] = self.retry_count
        if self.retry_interval is not None:
            result['RetryInterval'] = self.retry_interval
        if self.selection_type is not None:
            result['SelectionType'] = self.selection_type
        if self.src_versions is not None:
            result['SrcVersions'] = self.src_versions.to_map()
        if self.tags is not None:
            result['Tags'] = self.tags.to_map()
        if self.target_selection is not None:
            result['TargetSelection'] = self.target_selection
        if self.timeout_in_minutes is not None:
            result['TimeoutInMinutes'] = self.timeout_in_minutes
        if self.utc_create is not None:
            result['UtcCreate'] = self.utc_create
        if self.utc_end_time is not None:
            result['UtcEndTime'] = self.utc_end_time
        if self.utc_modified is not None:
            result['UtcModified'] = self.utc_modified
        if self.utc_schedule_finish_time is not None:
            result['UtcScheduleFinishTime'] = self.utc_schedule_finish_time
        if self.utc_schedule_time is not None:
            result['UtcScheduleTime'] = self.utc_schedule_time
        if self.utc_start_time is not None:
            result['UtcStartTime'] = self.utc_start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DestVersion') is not None:
            self.dest_version = m.get('DestVersion')
        if m.get('DownloadProtocol') is not None:
            self.download_protocol = m.get('DownloadProtocol')
        if m.get('DynamicMode') is not None:
            self.dynamic_mode = m.get('DynamicMode')
        if m.get('FirmwareId') is not None:
            self.firmware_id = m.get('FirmwareId')
        if m.get('GrayPercent') is not None:
            self.gray_percent = m.get('GrayPercent')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('JobDesc') is not None:
            self.job_desc = m.get('JobDesc')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('JobStatus') is not None:
            self.job_status = m.get('JobStatus')
        if m.get('JobType') is not None:
            self.job_type = m.get('JobType')
        if m.get('MaximumPerMinute') is not None:
            self.maximum_per_minute = m.get('MaximumPerMinute')
        if m.get('MultiModuleMode') is not None:
            self.multi_module_mode = m.get('MultiModuleMode')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NeedConfirm') is not None:
            self.need_confirm = m.get('NeedConfirm')
        if m.get('NeedPush') is not None:
            self.need_push = m.get('NeedPush')
        if m.get('OverwriteMode') is not None:
            self.overwrite_mode = m.get('OverwriteMode')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('RetryCount') is not None:
            self.retry_count = m.get('RetryCount')
        if m.get('RetryInterval') is not None:
            self.retry_interval = m.get('RetryInterval')
        if m.get('SelectionType') is not None:
            self.selection_type = m.get('SelectionType')
        if m.get('SrcVersions') is not None:
            temp_model = QueryOTAJobResponseBodyDataSrcVersions()
            self.src_versions = temp_model.from_map(m['SrcVersions'])
        if m.get('Tags') is not None:
            temp_model = QueryOTAJobResponseBodyDataTags()
            self.tags = temp_model.from_map(m['Tags'])
        if m.get('TargetSelection') is not None:
            self.target_selection = m.get('TargetSelection')
        if m.get('TimeoutInMinutes') is not None:
            self.timeout_in_minutes = m.get('TimeoutInMinutes')
        if m.get('UtcCreate') is not None:
            self.utc_create = m.get('UtcCreate')
        if m.get('UtcEndTime') is not None:
            self.utc_end_time = m.get('UtcEndTime')
        if m.get('UtcModified') is not None:
            self.utc_modified = m.get('UtcModified')
        if m.get('UtcScheduleFinishTime') is not None:
            self.utc_schedule_finish_time = m.get('UtcScheduleFinishTime')
        if m.get('UtcScheduleTime') is not None:
            self.utc_schedule_time = m.get('UtcScheduleTime')
        if m.get('UtcStartTime') is not None:
            self.utc_start_time = m.get('UtcStartTime')
        return self


class QueryOTAJobResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryOTAJobResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The update batch information returned if the call is successful. For more information, see the following parameters.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryOTAJobResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryOTAJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryOTAJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryOTAJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryPageByApplyIdRequest(TeaModel):
    def __init__(
        self,
        apply_id: int = None,
        current_page: int = None,
        iot_instance_id: str = None,
        page_size: int = None,
    ):
        # The ID of the application. You can view the application ID in the response of the [BatchRegisterDeviceWithApplyId](~~69514~~) or [BatchRegisterDevice](~~69473~~) operation.
        self.apply_id = apply_id
        # The number of the page to return. Default value: 1.
        self.current_page = current_page
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The number of entries to return on each page. Maximum value: 50. Default value: 10.
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.apply_id is not None:
            result['ApplyId'] = self.apply_id
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApplyId') is not None:
            self.apply_id = m.get('ApplyId')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class QueryPageByApplyIdResponseBodyApplyDeviceListApplyDeviceInfo(TeaModel):
    def __init__(
        self,
        device_id: str = None,
        device_name: str = None,
        device_secret: str = None,
        iot_id: str = None,
    ):
        # The ID of the device (expired).
        # 
        # >  This parameter is no longer used. Do not use this parameter to identify a device. You can use the **IotId** parameter or a combination of the **ProductKey** and **DeviceName** parameters to identify a device.
        self.device_id = device_id
        # The DeviceName of the device.
        self.device_name = device_name
        # The DeviceSecret of the device.
        self.device_secret = device_secret
        # The ID of the device. The ID is the unique identifier that is issued by IoT Platform to the device.
        self.iot_id = iot_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.device_secret is not None:
            result['DeviceSecret'] = self.device_secret
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('DeviceSecret') is not None:
            self.device_secret = m.get('DeviceSecret')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        return self


class QueryPageByApplyIdResponseBodyApplyDeviceList(TeaModel):
    def __init__(
        self,
        apply_device_info: List[QueryPageByApplyIdResponseBodyApplyDeviceListApplyDeviceInfo] = None,
    ):
        self.apply_device_info = apply_device_info

    def validate(self):
        if self.apply_device_info:
            for k in self.apply_device_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ApplyDeviceInfo'] = []
        if self.apply_device_info is not None:
            for k in self.apply_device_info:
                result['ApplyDeviceInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.apply_device_info = []
        if m.get('ApplyDeviceInfo') is not None:
            for k in m.get('ApplyDeviceInfo'):
                temp_model = QueryPageByApplyIdResponseBodyApplyDeviceListApplyDeviceInfo()
                self.apply_device_info.append(temp_model.from_map(k))
        return self


class QueryPageByApplyIdResponseBody(TeaModel):
    def __init__(
        self,
        apply_device_list: QueryPageByApplyIdResponseBodyApplyDeviceList = None,
        code: str = None,
        error_message: str = None,
        page: int = None,
        page_count: int = None,
        page_size: int = None,
        request_id: str = None,
        success: bool = None,
        total: int = None,
    ):
        # The registered device list information returned if the call succeeds. The **ApplyDeviceInfo** parameter includes the details of the registered devices.
        self.apply_device_list = apply_device_list
        # The error code returned if the call fails. For more information, see [Error codes](/help/en/iot-platform/latest/bce100).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The page number of the returned page.
        self.page = page
        # The total number of pages.
        self.page_count = page_count
        # The number of entries returned per page.
        self.page_size = page_size
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success
        # The total number of devices.
        self.total = total

    def validate(self):
        if self.apply_device_list:
            self.apply_device_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.apply_device_list is not None:
            result['ApplyDeviceList'] = self.apply_device_list.to_map()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.page is not None:
            result['Page'] = self.page
        if self.page_count is not None:
            result['PageCount'] = self.page_count
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApplyDeviceList') is not None:
            temp_model = QueryPageByApplyIdResponseBodyApplyDeviceList()
            self.apply_device_list = temp_model.from_map(m['ApplyDeviceList'])
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('PageCount') is not None:
            self.page_count = m.get('PageCount')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class QueryPageByApplyIdResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryPageByApplyIdResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryPageByApplyIdResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryProductRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        product_key: str = None,
    ):
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # > *   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >  *   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The ProductKey of the product that you want to query. A ProductKey is a GUID that is issued by IoT Platform to a product. You can use the IoT Platform console or call the [QueryProductList](~~69271~~) operation to view the information about all products within the current account.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class QueryProductResponseBodyData(TeaModel):
    def __init__(
        self,
        aliyun_commodity_code: str = None,
        auth_type: str = None,
        category_key: str = None,
        category_name: str = None,
        data_format: int = None,
        description: str = None,
        device_count: int = None,
        gmt_create: int = None,
        id_2: bool = None,
        net_type: int = None,
        node_type: int = None,
        owner: bool = None,
        product_key: str = None,
        product_name: str = None,
        product_secret: str = None,
        product_status: str = None,
        protocol_type: str = None,
        validate_type: int = None,
    ):
        # The type of the product. This parameter indicates whether a Thing Specification Language (TSL) model was used.
        # 
        # Valid values:
        # 
        # *   **iothub_senior**: A TSL model was used.
        # *   **iothub**: No TSL model was used.
        self.aliyun_commodity_code = aliyun_commodity_code
        # The authentication method that was used to connect the devices of the product to IoT Platform. Valid values:
        # 
        # *   **secret**: DeviceSecrets were used to authenticate the devices.
        # *   **id2**: IoT Internet Device ID was used to authenticate the devices.
        # *   **x509**: X.509 certificates were used to authenticate the devices.
        self.auth_type = auth_type
        # The identifier of the category to which the product belongs.
        # 
        # This parameter is returned if the product uses the TSL model of a standard category that is pre-defined by IoT Platform.
        # 
        # This parameter is available if the AliyunCommodityCode parameter is set to iothub_senior.
        self.category_key = category_key
        # The name of the product category.
        # 
        # This parameter is returned if the product uses the TSL model of a standard category that is pre-defined by IoT Platform.
        # 
        # This parameter is available if the AliyunCommodityCode parameter is set to iothub_senior.
        self.category_name = category_name
        # The data format that was used by a communication protocol to transmit data between the devices and IoT Platform. This parameter is available if the AliyunCommodityCode parameter is set to iothub_senior.
        # 
        # Valid values:
        # 
        # *   **0**: custom. A custom serial data format was used. In this case, the device can submit raw data, such as binary data streams. IoT Platform converts the raw data into standard Alink JSON data by using a specified data parsing script.
        # *   **1**: Alink JSON. Alink JSON data is transmitted between the devices and IoT Platform. Alink is a data exchange protocol that is pre-defined by IoT Platform.
        self.data_format = data_format
        # The description of the product.
        self.description = description
        # The number of devices under the product.
        self.device_count = device_count
        # The time when the product was created. The value is a timestamp in milliseconds.
        self.gmt_create = gmt_create
        # Indicates whether IoT Internet Device ID was enabled. Valid values:
        # 
        # *   **true**: IoT Internet Device ID was enabled.
        # *   **false**: IoT Internet Device ID was disabled.
        self.id_2 = id_2
        # The network connection method. Valid values:
        # 
        # *   **3**: Wi-Fi.
        # *   **6**: cellular network (2G/3G/4G/5G).
        # *   **7**: Ethernet.
        # *   **8**: others.
        self.net_type = net_type
        # The node type of the product. This parameter is available if the AliyunCommodityCode parameter is set to iothub_senior. Valid values:
        # 
        # *   **0**: device. Sub-devices cannot be attached to a device. A device can connect to IoT Platform directly or as a sub-device of a gateway.
        # *   **1**: gateway. Sub-devices can be attached to a gateway. A gateway can manage sub-devices, maintain the topological relationships with sub-devices, and synchronize the topological relationships to IoT Platform.
        self.node_type = node_type
        # Indicates whether the operation was called by the owner of the product.
        # 
        # *   **true**: yes.
        # *   **false**: no.
        self.owner = owner
        # The ProductKey of the product. When you create a product, a ProductKey is the globally unique identifier (GUID) that is issued by IoT Platform to the product.
        self.product_key = product_key
        # The name of the product.
        self.product_name = product_name
        # The ProductSecret of the product.
        self.product_secret = product_secret
        # The status of the product.
        # 
        # *   **DEVELOPMENT_STATUS**: The product is being developed.
        # *   **RELEASE_STATUS**: The product was published.
        self.product_status = product_status
        # The type of the protocol that was used by the sub-devices to connect with a gateway.
        # 
        # This parameter is available if the AliyunCommodityCode parameter is set to iothub_senior and the NodeType parameter is set to 1. Valid values:
        # 
        # *   **modbus**: Modbus.
        # *   **opc-ua**: OPC UA.
        # *   **customize**: custom protocol.
        # *   **ble**: BLE.
        # *   **zigbee**: ZigBee.
        self.protocol_type = protocol_type
        # The level of the data verification. Valid values:
        # 
        # *   **2**: no verification. IoT Platform does not verify the data. All data is forwarded.
        # 
        #     In the IoT Platform console, the data is not displayed on the TSL Data tab of the Device Details page.
        # 
        # *   **1**: low-level verification. IoT Platform verifies only the identifier and dataType fields of the data. All data is forwarded.
        # 
        # *   **0**: high-level verification. IoT Platform verifies all fields of the data. Only the data that passes the verification is forwarded.
        # 
        #     The products that were created before October 14, 2020 support only high-level verification.
        # 
        # The products that were created on October 14, 2020 or later support low-level verification or no verification.
        # 
        # After verification, you can view the data that passes or fails the verification.
        # 
        # *   In the IoT Platform console, the data is displayed on the **TSL Data** tab of the **Device Details** page. The data that fails the verification is not displayed.
        # *   You can view the data that fails the verification in the **checkFailedData** parameter of the forwarded data. For more information, see [Data formats](~~73736~~).
        self.validate_type = validate_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_commodity_code is not None:
            result['AliyunCommodityCode'] = self.aliyun_commodity_code
        if self.auth_type is not None:
            result['AuthType'] = self.auth_type
        if self.category_key is not None:
            result['CategoryKey'] = self.category_key
        if self.category_name is not None:
            result['CategoryName'] = self.category_name
        if self.data_format is not None:
            result['DataFormat'] = self.data_format
        if self.description is not None:
            result['Description'] = self.description
        if self.device_count is not None:
            result['DeviceCount'] = self.device_count
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.id_2 is not None:
            result['Id2'] = self.id_2
        if self.net_type is not None:
            result['NetType'] = self.net_type
        if self.node_type is not None:
            result['NodeType'] = self.node_type
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.product_name is not None:
            result['ProductName'] = self.product_name
        if self.product_secret is not None:
            result['ProductSecret'] = self.product_secret
        if self.product_status is not None:
            result['ProductStatus'] = self.product_status
        if self.protocol_type is not None:
            result['ProtocolType'] = self.protocol_type
        if self.validate_type is not None:
            result['ValidateType'] = self.validate_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliyunCommodityCode') is not None:
            self.aliyun_commodity_code = m.get('AliyunCommodityCode')
        if m.get('AuthType') is not None:
            self.auth_type = m.get('AuthType')
        if m.get('CategoryKey') is not None:
            self.category_key = m.get('CategoryKey')
        if m.get('CategoryName') is not None:
            self.category_name = m.get('CategoryName')
        if m.get('DataFormat') is not None:
            self.data_format = m.get('DataFormat')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DeviceCount') is not None:
            self.device_count = m.get('DeviceCount')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('Id2') is not None:
            self.id_2 = m.get('Id2')
        if m.get('NetType') is not None:
            self.net_type = m.get('NetType')
        if m.get('NodeType') is not None:
            self.node_type = m.get('NodeType')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('ProductName') is not None:
            self.product_name = m.get('ProductName')
        if m.get('ProductSecret') is not None:
            self.product_secret = m.get('ProductSecret')
        if m.get('ProductStatus') is not None:
            self.product_status = m.get('ProductStatus')
        if m.get('ProtocolType') is not None:
            self.protocol_type = m.get('ProtocolType')
        if m.get('ValidateType') is not None:
            self.validate_type = m.get('ValidateType')
        return self


class QueryProductResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryProductResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The product information returned if the call is successful.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryProductResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryProductResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryProductResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryProductResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryProductCertInfoRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        product_key: str = None,
    ):
        # The ID of the instance. You can view the ID of the instance on the **Overview** page in the IoT Platform console.****\
        # 
        # >  If your instance has an ID, you must specify the ID for this parameter. If you do not specify the instance ID, the call fails. If no Overview page or ID is generated for your instance, you do not need to configure this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The ProductKey of the product.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class QueryProductCertInfoResponseBodyProductCertInfo(TeaModel):
    def __init__(
        self,
        issue_model: int = None,
    ):
        # The source from which the X.509 certificate is issued.
        # 
        # *   **1**: The X.509 certificate is issued by IoT Platform.
        # *   **3**: The X.509 certificate is issued by a third-party platform.
        self.issue_model = issue_model

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.issue_model is not None:
            result['IssueModel'] = self.issue_model
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IssueModel') is not None:
            self.issue_model = m.get('IssueModel')
        return self


class QueryProductCertInfoResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        product_cert_info: QueryProductCertInfoResponseBodyProductCertInfo = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the request fails.
        self.error_message = error_message
        # The returned certificate information that includes the value of the **IssueModel** parameter.
        self.product_cert_info = product_cert_info
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful. Valid values:
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.product_cert_info:
            self.product_cert_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.product_cert_info is not None:
            result['ProductCertInfo'] = self.product_cert_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('ProductCertInfo') is not None:
            temp_model = QueryProductCertInfoResponseBodyProductCertInfo()
            self.product_cert_info = temp_model.from_map(m['ProductCertInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryProductCertInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryProductCertInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryProductCertInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryProductListRequest(TeaModel):
    def __init__(
        self,
        aliyun_commodity_code: str = None,
        current_page: int = None,
        iot_instance_id: str = None,
        page_size: int = None,
        resource_group_id: str = None,
    ):
        # The type of the product. Valid values:
        # 
        # *   **iothub_senior**: A Thing Specification Language (TSL) model is used for the product.
        # *   **iothub**: No TSL model is used for the product.
        # 
        # >  If you do not configure this parameter, all products are returned.
        self.aliyun_commodity_code = aliyun_commodity_code
        # The number of the page to return.
        self.current_page = current_page
        # The ID of the instance. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
        # 
        # 
        # > *   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.
        # > *   If no **Overview** page or ID is generated for your instance, you do not need to configure this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The number of entries to return on each page. Valid values: 1 to 200.
        self.page_size = page_size
        # The ID of the resource group to which the product belongs. You can log on to the [Resource Management](https://resourcemanager.console.aliyun.com/resource-groups) console to view the details of the resource group.
        # 
        # > You can specify a value for this parameter only if you have activated Resource Management.
        # 
        # If you leave this parameter empty, the information about all products in the current account is queried.
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_commodity_code is not None:
            result['AliyunCommodityCode'] = self.aliyun_commodity_code
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliyunCommodityCode') is not None:
            self.aliyun_commodity_code = m.get('AliyunCommodityCode')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        return self


class QueryProductListResponseBodyDataListProductInfo(TeaModel):
    def __init__(
        self,
        auth_type: str = None,
        data_format: int = None,
        description: str = None,
        device_count: int = None,
        gmt_create: int = None,
        node_type: int = None,
        product_key: str = None,
        product_name: str = None,
    ):
        # The authentication method that was used to connect the devices of the product to IoT Platform. Valid values:
        # 
        # *   **secret**: DeviceSecrets were used to authenticate the devices.
        # *   **id2**: IoT Internet Device ID was used to authenticate the devices.
        # *   **x509**: X.509 certificates were used to authenticate the devices.
        self.auth_type = auth_type
        # The data format that was used by a communication protocol to transmit data between the devices and IoT Platform. This parameter is available only if the AliyunCommodityCode parameter is set to iothub_senior.
        # 
        # Valid values:
        # 
        # *   **0**: custom. A custom serial data format was used. In this case, the device can submit raw data, such as binary data streams. IoT Platform converts the raw data into standard Alink JSON data by using a specified data parsing script.
        # *   **1**: Alink JSON. Alink JSON data is transmitted between the devices and IoT Platform. Alink is a data exchange protocol that is pre-defined by IoT Platform.
        self.data_format = data_format
        # The description of the product.
        self.description = description
        # The number of devices in the product.
        self.device_count = device_count
        # The time when the product was created. The value is a timestamp in milliseconds.
        self.gmt_create = gmt_create
        # The node type of the product. This parameter is available only if the AliyunCommodityCode parameter is set to iothub_senior. Valid values:
        # 
        # *   **0**: device. Sub-devices cannot be attached to a device. A device can be directly connected to IoT Platform or connected to IoT Platform as a sub-device of a gateway.
        # *   **1**: gateway. Sub-devices can be attached to a gateway. A gateway can manage sub-devices, maintain topological relationships with sub-devices, and synchronize topological relationships to IoT Platform.
        self.node_type = node_type
        # The ProductKey of the product. When you create a product, a ProductKey is a globally unique identifier (GUID) that is issued by IoT Platform to the product.
        self.product_key = product_key
        # The name of the service.
        self.product_name = product_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_type is not None:
            result['AuthType'] = self.auth_type
        if self.data_format is not None:
            result['DataFormat'] = self.data_format
        if self.description is not None:
            result['Description'] = self.description
        if self.device_count is not None:
            result['DeviceCount'] = self.device_count
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.node_type is not None:
            result['NodeType'] = self.node_type
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.product_name is not None:
            result['ProductName'] = self.product_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuthType') is not None:
            self.auth_type = m.get('AuthType')
        if m.get('DataFormat') is not None:
            self.data_format = m.get('DataFormat')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DeviceCount') is not None:
            self.device_count = m.get('DeviceCount')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('NodeType') is not None:
            self.node_type = m.get('NodeType')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('ProductName') is not None:
            self.product_name = m.get('ProductName')
        return self


class QueryProductListResponseBodyDataList(TeaModel):
    def __init__(
        self,
        product_info: List[QueryProductListResponseBodyDataListProductInfo] = None,
    ):
        self.product_info = product_info

    def validate(self):
        if self.product_info:
            for k in self.product_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ProductInfo'] = []
        if self.product_info is not None:
            for k in self.product_info:
                result['ProductInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.product_info = []
        if m.get('ProductInfo') is not None:
            for k in m.get('ProductInfo'):
                temp_model = QueryProductListResponseBodyDataListProductInfo()
                self.product_info.append(temp_model.from_map(k))
        return self


class QueryProductListResponseBodyData(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        list: QueryProductListResponseBodyDataList = None,
        page_count: int = None,
        page_size: int = None,
        total: int = None,
    ):
        # The page number of the returned page.
        self.current_page = current_page
        # The details of the products.
        # 
        # >  The returned product information is sorted in reverse-chronological order based on the time when the products were created.
        self.list = list
        # The total number of returned pages.
        self.page_count = page_count
        # The number of entries returned per page.
        self.page_size = page_size
        # The total number of products.
        self.total = total

    def validate(self):
        if self.list:
            self.list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.list is not None:
            result['List'] = self.list.to_map()
        if self.page_count is not None:
            result['PageCount'] = self.page_count
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('List') is not None:
            temp_model = QueryProductListResponseBodyDataList()
            self.list = temp_model.from_map(m['List'])
        if m.get('PageCount') is not None:
            self.page_count = m.get('PageCount')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class QueryProductListResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryProductListResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The product information returned if the call is successful. For more information, see the following parameters.
        self.data = data
        # The error message returned if the request fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryProductListResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryProductListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryProductListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryProductListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryProductTopicRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        product_key: str = None,
    ):
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The **ProductKey** of the product.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class QueryProductTopicResponseBodyDataProductTopicInfo(TeaModel):
    def __init__(
        self,
        codec: str = None,
        desc: str = None,
        enable_proxy_subscribe: bool = None,
        id: str = None,
        operation: str = None,
        product_key: str = None,
        topic_short_name: str = None,
    ):
        self.codec = codec
        # The description of the topic category.
        self.desc = desc
        self.enable_proxy_subscribe = enable_proxy_subscribe
        # The ID of the topic category.
        self.id = id
        # The operation that devices can perform on the topic category. Valid values:
        # 
        # *   **0**: Publish.
        # *   **1**: Subscribe.
        # *   **2**: Publish and Subscribe.
        self.operation = operation
        # The ProductKey of the product.
        self.product_key = product_key
        # The topic category that does not include the \_productKey\_ and \_deviceName\_ levels.
        self.topic_short_name = topic_short_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.desc is not None:
            result['Desc'] = self.desc
        if self.enable_proxy_subscribe is not None:
            result['EnableProxySubscribe'] = self.enable_proxy_subscribe
        if self.id is not None:
            result['Id'] = self.id
        if self.operation is not None:
            result['Operation'] = self.operation
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.topic_short_name is not None:
            result['TopicShortName'] = self.topic_short_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Desc') is not None:
            self.desc = m.get('Desc')
        if m.get('EnableProxySubscribe') is not None:
            self.enable_proxy_subscribe = m.get('EnableProxySubscribe')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Operation') is not None:
            self.operation = m.get('Operation')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('TopicShortName') is not None:
            self.topic_short_name = m.get('TopicShortName')
        return self


class QueryProductTopicResponseBodyData(TeaModel):
    def __init__(
        self,
        product_topic_info: List[QueryProductTopicResponseBodyDataProductTopicInfo] = None,
    ):
        self.product_topic_info = product_topic_info

    def validate(self):
        if self.product_topic_info:
            for k in self.product_topic_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ProductTopicInfo'] = []
        if self.product_topic_info is not None:
            for k in self.product_topic_info:
                result['ProductTopicInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.product_topic_info = []
        if m.get('ProductTopicInfo') is not None:
            for k in m.get('ProductTopicInfo'):
                temp_model = QueryProductTopicResponseBodyDataProductTopicInfo()
                self.product_topic_info.append(temp_model.from_map(k))
        return self


class QueryProductTopicResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryProductTopicResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The list of topic categories returned if the call is successful. For more information, see **ProductTopicInfo**.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryProductTopicResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryProductTopicResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryProductTopicResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryProductTopicResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryProjectShareDeviceListRequest(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        iot_instance_id: str = None,
        page_id: int = None,
        page_size: int = None,
        product_key: str = None,
    ):
        # The keyword in the DeviceName of the devices that you want to query. Fuzzy match is supported.
        self.device_name = device_name
        # The instance ID. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
        # 
        # >  If your instance has an ID, you must specify this parameter. Otherwise, the request fails. If no Overview page exists or no instance ID is displayed, you do not need to specify this parameter.
        # 
        # For more information, see the [Overview](~~356505~~) topic of IoT instances.
        self.iot_instance_id = iot_instance_id
        # The page number. Valid values: 1 to 10000.
        self.page_id = page_id
        # The number of entries per page. Valid values: 1 to 50. Default value: 20.
        self.page_size = page_size
        # The **ProductKey** of the product to which the devices belong.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.page_id is not None:
            result['PageId'] = self.page_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('PageId') is not None:
            self.page_id = m.get('PageId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class QueryProjectShareDeviceListResponseBodyDataDeviceListItems(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        iot_id: str = None,
        product_key: str = None,
        sharable: int = None,
    ):
        # The DeviceName of the device.
        self.device_name = device_name
        # The ID of the device. The ID is the unique identifier that is issued by IoT Platform to the device.
        self.iot_id = iot_id
        # The **ProductKey** of the product to which the device belongs.
        self.product_key = product_key
        # Indicates whether the project was shared to the device.
        # 
        # *   **1**: The project was shared.
        # *   **0**: The project failed to be shared.
        self.sharable = sharable

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.sharable is not None:
            result['Sharable'] = self.sharable
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('Sharable') is not None:
            self.sharable = m.get('Sharable')
        return self


class QueryProjectShareDeviceListResponseBodyDataDeviceList(TeaModel):
    def __init__(
        self,
        items: List[QueryProjectShareDeviceListResponseBodyDataDeviceListItems] = None,
    ):
        self.items = items

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = QueryProjectShareDeviceListResponseBodyDataDeviceListItems()
                self.items.append(temp_model.from_map(k))
        return self


class QueryProjectShareDeviceListResponseBodyData(TeaModel):
    def __init__(
        self,
        device_list: QueryProjectShareDeviceListResponseBodyDataDeviceList = None,
        page_id: int = None,
        page_size: int = None,
        total: int = None,
    ):
        # The information about devices that you queried.
        self.device_list = device_list
        # The page number.
        self.page_id = page_id
        # The number of entries per page.
        self.page_size = page_size
        # The total number of entries returned.
        self.total = total

    def validate(self):
        if self.device_list:
            self.device_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_list is not None:
            result['DeviceList'] = self.device_list.to_map()
        if self.page_id is not None:
            result['PageId'] = self.page_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceList') is not None:
            temp_model = QueryProjectShareDeviceListResponseBodyDataDeviceList()
            self.device_list = temp_model.from_map(m['DeviceList'])
        if m.get('PageId') is not None:
            self.page_id = m.get('PageId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class QueryProjectShareDeviceListResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryProjectShareDeviceListResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The result of the request.
        self.data = data
        # The error message returned if the request fails.
        self.error_message = error_message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryProjectShareDeviceListResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryProjectShareDeviceListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryProjectShareDeviceListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryProjectShareDeviceListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QuerySceneRuleRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        iot_instance_id: str = None,
        page_size: int = None,
        rule_name: str = None,
    ):
        self.current_page = current_page
        self.iot_instance_id = iot_instance_id
        self.page_size = page_size
        self.rule_name = rule_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        return self


class QuerySceneRuleResponseBodyDataRuleList(TeaModel):
    def __init__(
        self,
        gmt_create: int = None,
        gmt_modified: int = None,
        rule_description: str = None,
        rule_id: str = None,
        rule_name: str = None,
        rule_status: int = None,
    ):
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.rule_description = rule_description
        self.rule_id = rule_id
        self.rule_name = rule_name
        self.rule_status = rule_status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.rule_description is not None:
            result['RuleDescription'] = self.rule_description
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.rule_status is not None:
            result['RuleStatus'] = self.rule_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('RuleDescription') is not None:
            self.rule_description = m.get('RuleDescription')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('RuleStatus') is not None:
            self.rule_status = m.get('RuleStatus')
        return self


class QuerySceneRuleResponseBodyData(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        page_size: int = None,
        rule_list: List[QuerySceneRuleResponseBodyDataRuleList] = None,
        total: int = None,
    ):
        self.current_page = current_page
        self.page_size = page_size
        self.rule_list = rule_list
        self.total = total

    def validate(self):
        if self.rule_list:
            for k in self.rule_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        result['RuleList'] = []
        if self.rule_list is not None:
            for k in self.rule_list:
                result['RuleList'].append(k.to_map() if k else None)
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        self.rule_list = []
        if m.get('RuleList') is not None:
            for k in m.get('RuleList'):
                temp_model = QuerySceneRuleResponseBodyDataRuleList()
                self.rule_list.append(temp_model.from_map(k))
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class QuerySceneRuleResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QuerySceneRuleResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QuerySceneRuleResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QuerySceneRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QuerySceneRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QuerySceneRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QuerySchedulePeriodListRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        page_id: int = None,
        page_size: int = None,
        schedule_code: str = None,
    ):
        self.iot_instance_id = iot_instance_id
        self.page_id = page_id
        self.page_size = page_size
        self.schedule_code = schedule_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.page_id is not None:
            result['PageId'] = self.page_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.schedule_code is not None:
            result['ScheduleCode'] = self.schedule_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('PageId') is not None:
            self.page_id = m.get('PageId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ScheduleCode') is not None:
            self.schedule_code = m.get('ScheduleCode')
        return self


class QuerySchedulePeriodListResponseBodyDataListItems(TeaModel):
    def __init__(
        self,
        description: str = None,
        end_time: str = None,
        period_code: str = None,
        sound_code_content: str = None,
        start_time: str = None,
    ):
        self.description = description
        self.end_time = end_time
        self.period_code = period_code
        self.sound_code_content = sound_code_content
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.period_code is not None:
            result['PeriodCode'] = self.period_code
        if self.sound_code_content is not None:
            result['SoundCodeContent'] = self.sound_code_content
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('PeriodCode') is not None:
            self.period_code = m.get('PeriodCode')
        if m.get('SoundCodeContent') is not None:
            self.sound_code_content = m.get('SoundCodeContent')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class QuerySchedulePeriodListResponseBodyDataList(TeaModel):
    def __init__(
        self,
        items: List[QuerySchedulePeriodListResponseBodyDataListItems] = None,
    ):
        self.items = items

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Items'] = []
        if self.items is not None:
            for k in self.items:
                result['Items'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('Items') is not None:
            for k in m.get('Items'):
                temp_model = QuerySchedulePeriodListResponseBodyDataListItems()
                self.items.append(temp_model.from_map(k))
        return self


class QuerySchedulePeriodListResponseBodyData(TeaModel):
    def __init__(
        self,
        list: QuerySchedulePeriodListResponseBodyDataList = None,
        page_id: int = None,
        page_size: int = None,
        total: int = None,
    ):
        self.list = list
        self.page_id = page_id
        self.page_size = page_size
        self.total = total

    def validate(self):
        if self.list:
            self.list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.list is not None:
            result['List'] = self.list.to_map()
        if self.page_id is not None:
            result['PageId'] = self.page_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('List') is not None:
            temp_model = QuerySchedulePeriodListResponseBodyDataList()
            self.list = temp_model.from_map(m['List'])
        if m.get('PageId') is not None:
            self.page_id = m.get('PageId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class QuerySchedulePeriodListResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QuerySchedulePeriodListResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QuerySchedulePeriodListResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QuerySchedulePeriodListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QuerySchedulePeriodListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QuerySchedulePeriodListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryShareProductNameByProductKeyRequest(TeaModel):
    def __init__(
        self,
        product_key: str = None,
        share_task_code: str = None,
    ):
        self.product_key = product_key
        self.share_task_code = share_task_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.share_task_code is not None:
            result['ShareTaskCode'] = self.share_task_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('ShareTaskCode') is not None:
            self.share_task_code = m.get('ShareTaskCode')
        return self


class QueryShareProductNameByProductKeyResponseBodyData(TeaModel):
    def __init__(
        self,
        product_name: str = None,
    ):
        self.product_name = product_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.product_name is not None:
            result['ProductName'] = self.product_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ProductName') is not None:
            self.product_name = m.get('ProductName')
        return self


class QueryShareProductNameByProductKeyResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryShareProductNameByProductKeyResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryShareProductNameByProductKeyResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryShareProductNameByProductKeyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryShareProductNameByProductKeyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryShareProductNameByProductKeyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QuerySharePromotionActivityAuditResultRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        share_promotion_activity_id: str = None,
        share_task_code: str = None,
    ):
        self.iot_instance_id = iot_instance_id
        self.share_promotion_activity_id = share_promotion_activity_id
        self.share_task_code = share_task_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.share_promotion_activity_id is not None:
            result['SharePromotionActivityId'] = self.share_promotion_activity_id
        if self.share_task_code is not None:
            result['ShareTaskCode'] = self.share_task_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('SharePromotionActivityId') is not None:
            self.share_promotion_activity_id = m.get('SharePromotionActivityId')
        if m.get('ShareTaskCode') is not None:
            self.share_task_code = m.get('ShareTaskCode')
        return self


class QuerySharePromotionActivityAuditResultResponseBodyData(TeaModel):
    def __init__(
        self,
        audit_result: int = None,
    ):
        self.audit_result = audit_result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audit_result is not None:
            result['AuditResult'] = self.audit_result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuditResult') is not None:
            self.audit_result = m.get('AuditResult')
        return self


class QuerySharePromotionActivityAuditResultResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QuerySharePromotionActivityAuditResultResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QuerySharePromotionActivityAuditResultResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QuerySharePromotionActivityAuditResultResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QuerySharePromotionActivityAuditResultResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QuerySharePromotionActivityAuditResultResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryShareTaskDeviceListRequest(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        iot_instance_id: str = None,
        page_id: int = None,
        page_size: int = None,
        share_task_id: str = None,
    ):
        # The keyword in the DeviceName of the device that you want to query. Fuzzy match is supported.
        self.device_name = device_name
        # The instance ID. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
        # 
        # >  If your instance has an ID, you must specify this parameter. Otherwise, the request fails. If no Overview page exists or no instance ID is displayed, you do not need to specify this parameter.
        # 
        # For more information, see [Overview](~~356505~~) of IoT instances.
        self.iot_instance_id = iot_instance_id
        # The page number. Valid values: 1 to 10000.
        self.page_id = page_id
        # The number of entries per page. Valid values: 1 to 50. Default value: 20.
        self.page_size = page_size
        # The ID of the sharing task.
        self.share_task_id = share_task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.page_id is not None:
            result['PageId'] = self.page_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.share_task_id is not None:
            result['ShareTaskId'] = self.share_task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('PageId') is not None:
            self.page_id = m.get('PageId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ShareTaskId') is not None:
            self.share_task_id = m.get('ShareTaskId')
        return self


class QueryShareTaskDeviceListResponseBodyDataDeviceListItems(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        gmt_added: int = None,
        iot_id: str = None,
        product_key: str = None,
    ):
        # The DeviceName of the device.
        self.device_name = device_name
        # The time when the device was added to the sharing task.
        self.gmt_added = gmt_added
        # The ID of the device. The ID is the unique identifier that is issued by IoT Platform to the device.
        self.iot_id = iot_id
        # The **ProductKey** of the product to which the device belongs.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.gmt_added is not None:
            result['GmtAdded'] = self.gmt_added
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('GmtAdded') is not None:
            self.gmt_added = m.get('GmtAdded')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class QueryShareTaskDeviceListResponseBodyDataDeviceList(TeaModel):
    def __init__(
        self,
        items: List[QueryShareTaskDeviceListResponseBodyDataDeviceListItems] = None,
    ):
        self.items = items

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = QueryShareTaskDeviceListResponseBodyDataDeviceListItems()
                self.items.append(temp_model.from_map(k))
        return self


class QueryShareTaskDeviceListResponseBodyData(TeaModel):
    def __init__(
        self,
        device_list: QueryShareTaskDeviceListResponseBodyDataDeviceList = None,
        page_id: int = None,
        page_size: int = None,
        total: int = None,
    ):
        # The devices in the sharing task.
        self.device_list = device_list
        # The page number.
        self.page_id = page_id
        # The number of entries per page.
        self.page_size = page_size
        # The total number of entries returned.
        self.total = total

    def validate(self):
        if self.device_list:
            self.device_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_list is not None:
            result['DeviceList'] = self.device_list.to_map()
        if self.page_id is not None:
            result['PageId'] = self.page_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceList') is not None:
            temp_model = QueryShareTaskDeviceListResponseBodyDataDeviceList()
            self.device_list = temp_model.from_map(m['DeviceList'])
        if m.get('PageId') is not None:
            self.page_id = m.get('PageId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class QueryShareTaskDeviceListResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryShareTaskDeviceListResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The result of the request.
        self.data = data
        # The error message returned if the request fails.
        self.error_message = error_message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryShareTaskDeviceListResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryShareTaskDeviceListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryShareTaskDeviceListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryShareTaskDeviceListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QuerySolutionDeviceGroupPageRequest(TeaModel):
    def __init__(
        self,
        fuzzy_group_name: str = None,
        iot_instance_id: str = None,
        page_id: int = None,
        page_size: int = None,
        project_code: str = None,
    ):
        self.fuzzy_group_name = fuzzy_group_name
        self.iot_instance_id = iot_instance_id
        self.page_id = page_id
        self.page_size = page_size
        self.project_code = project_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fuzzy_group_name is not None:
            result['FuzzyGroupName'] = self.fuzzy_group_name
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.page_id is not None:
            result['PageId'] = self.page_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_code is not None:
            result['ProjectCode'] = self.project_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FuzzyGroupName') is not None:
            self.fuzzy_group_name = m.get('FuzzyGroupName')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('PageId') is not None:
            self.page_id = m.get('PageId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectCode') is not None:
            self.project_code = m.get('ProjectCode')
        return self


class QuerySolutionDeviceGroupPageResponseBodyDataListItemName(TeaModel):
    def __init__(
        self,
        device_count: int = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        group_desc: str = None,
        group_id: str = None,
        group_name: str = None,
    ):
        self.device_count = device_count
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.group_desc = group_desc
        self.group_id = group_id
        self.group_name = group_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_count is not None:
            result['DeviceCount'] = self.device_count
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.group_desc is not None:
            result['GroupDesc'] = self.group_desc
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceCount') is not None:
            self.device_count = m.get('DeviceCount')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('GroupDesc') is not None:
            self.group_desc = m.get('GroupDesc')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        return self


class QuerySolutionDeviceGroupPageResponseBodyDataList(TeaModel):
    def __init__(
        self,
        item_name: List[QuerySolutionDeviceGroupPageResponseBodyDataListItemName] = None,
    ):
        self.item_name = item_name

    def validate(self):
        if self.item_name:
            for k in self.item_name:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['itemName'] = []
        if self.item_name is not None:
            for k in self.item_name:
                result['itemName'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.item_name = []
        if m.get('itemName') is not None:
            for k in m.get('itemName'):
                temp_model = QuerySolutionDeviceGroupPageResponseBodyDataListItemName()
                self.item_name.append(temp_model.from_map(k))
        return self


class QuerySolutionDeviceGroupPageResponseBodyData(TeaModel):
    def __init__(
        self,
        list: QuerySolutionDeviceGroupPageResponseBodyDataList = None,
        page_id: int = None,
        page_size: int = None,
        total: int = None,
    ):
        self.list = list
        self.page_id = page_id
        self.page_size = page_size
        self.total = total

    def validate(self):
        if self.list:
            self.list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.list is not None:
            result['List'] = self.list.to_map()
        if self.page_id is not None:
            result['PageId'] = self.page_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('List') is not None:
            temp_model = QuerySolutionDeviceGroupPageResponseBodyDataList()
            self.list = temp_model.from_map(m['List'])
        if m.get('PageId') is not None:
            self.page_id = m.get('PageId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class QuerySolutionDeviceGroupPageResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QuerySolutionDeviceGroupPageResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QuerySolutionDeviceGroupPageResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QuerySolutionDeviceGroupPageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QuerySolutionDeviceGroupPageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QuerySolutionDeviceGroupPageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QuerySoundCodeLabelBatchFailedResultRequest(TeaModel):
    def __init__(
        self,
        batch_code: str = None,
        iot_instance_id: str = None,
    ):
        self.batch_code = batch_code
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.batch_code is not None:
            result['BatchCode'] = self.batch_code
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BatchCode') is not None:
            self.batch_code = m.get('BatchCode')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class QuerySoundCodeLabelBatchFailedResultResponseBodyDataItems(TeaModel):
    def __init__(
        self,
        error_message: str = None,
        label: str = None,
        result_code: str = None,
    ):
        self.error_message = error_message
        self.label = label
        self.result_code = result_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.label is not None:
            result['Label'] = self.label
        if self.result_code is not None:
            result['ResultCode'] = self.result_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('ResultCode') is not None:
            self.result_code = m.get('ResultCode')
        return self


class QuerySoundCodeLabelBatchFailedResultResponseBodyData(TeaModel):
    def __init__(
        self,
        items: List[QuerySoundCodeLabelBatchFailedResultResponseBodyDataItems] = None,
    ):
        self.items = items

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Items'] = []
        if self.items is not None:
            for k in self.items:
                result['Items'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('Items') is not None:
            for k in m.get('Items'):
                temp_model = QuerySoundCodeLabelBatchFailedResultResponseBodyDataItems()
                self.items.append(temp_model.from_map(k))
        return self


class QuerySoundCodeLabelBatchFailedResultResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QuerySoundCodeLabelBatchFailedResultResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QuerySoundCodeLabelBatchFailedResultResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QuerySoundCodeLabelBatchFailedResultResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QuerySoundCodeLabelBatchFailedResultResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QuerySoundCodeLabelBatchFailedResultResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QuerySoundCodeLabelBatchListRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        page_id: int = None,
        page_size: int = None,
        schedule_code: str = None,
    ):
        self.iot_instance_id = iot_instance_id
        self.page_id = page_id
        self.page_size = page_size
        self.schedule_code = schedule_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.page_id is not None:
            result['PageId'] = self.page_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.schedule_code is not None:
            result['ScheduleCode'] = self.schedule_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('PageId') is not None:
            self.page_id = m.get('PageId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ScheduleCode') is not None:
            self.schedule_code = m.get('ScheduleCode')
        return self


class QuerySoundCodeLabelBatchListResponseBodyDataListItems(TeaModel):
    def __init__(
        self,
        batch_code: str = None,
        description: str = None,
        gmt_create: int = None,
        status: str = None,
        success_num: int = None,
        total: int = None,
    ):
        self.batch_code = batch_code
        self.description = description
        self.gmt_create = gmt_create
        self.status = status
        self.success_num = success_num
        self.total = total

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.batch_code is not None:
            result['BatchCode'] = self.batch_code
        if self.description is not None:
            result['Description'] = self.description
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.status is not None:
            result['Status'] = self.status
        if self.success_num is not None:
            result['SuccessNum'] = self.success_num
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BatchCode') is not None:
            self.batch_code = m.get('BatchCode')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('SuccessNum') is not None:
            self.success_num = m.get('SuccessNum')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class QuerySoundCodeLabelBatchListResponseBodyDataList(TeaModel):
    def __init__(
        self,
        items: List[QuerySoundCodeLabelBatchListResponseBodyDataListItems] = None,
    ):
        self.items = items

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Items'] = []
        if self.items is not None:
            for k in self.items:
                result['Items'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('Items') is not None:
            for k in m.get('Items'):
                temp_model = QuerySoundCodeLabelBatchListResponseBodyDataListItems()
                self.items.append(temp_model.from_map(k))
        return self


class QuerySoundCodeLabelBatchListResponseBodyData(TeaModel):
    def __init__(
        self,
        list: QuerySoundCodeLabelBatchListResponseBodyDataList = None,
        page_id: int = None,
        page_size: int = None,
        total: int = None,
    ):
        self.list = list
        self.page_id = page_id
        self.page_size = page_size
        self.total = total

    def validate(self):
        if self.list:
            self.list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.list is not None:
            result['List'] = self.list.to_map()
        if self.page_id is not None:
            result['PageId'] = self.page_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('List') is not None:
            temp_model = QuerySoundCodeLabelBatchListResponseBodyDataList()
            self.list = temp_model.from_map(m['List'])
        if m.get('PageId') is not None:
            self.page_id = m.get('PageId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class QuerySoundCodeLabelBatchListResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QuerySoundCodeLabelBatchListResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QuerySoundCodeLabelBatchListResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QuerySoundCodeLabelBatchListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QuerySoundCodeLabelBatchListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QuerySoundCodeLabelBatchListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QuerySoundCodeLabelListRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        page_id: int = None,
        page_size: int = None,
        schedule_code: str = None,
    ):
        self.iot_instance_id = iot_instance_id
        self.page_id = page_id
        self.page_size = page_size
        self.schedule_code = schedule_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.page_id is not None:
            result['PageId'] = self.page_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.schedule_code is not None:
            result['ScheduleCode'] = self.schedule_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('PageId') is not None:
            self.page_id = m.get('PageId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ScheduleCode') is not None:
            self.schedule_code = m.get('ScheduleCode')
        return self


class QuerySoundCodeLabelListResponseBodyDataListItems(TeaModel):
    def __init__(
        self,
        label: str = None,
        sound_code: str = None,
    ):
        self.label = label
        self.sound_code = sound_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.label is not None:
            result['Label'] = self.label
        if self.sound_code is not None:
            result['SoundCode'] = self.sound_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('SoundCode') is not None:
            self.sound_code = m.get('SoundCode')
        return self


class QuerySoundCodeLabelListResponseBodyDataList(TeaModel):
    def __init__(
        self,
        items: List[QuerySoundCodeLabelListResponseBodyDataListItems] = None,
    ):
        self.items = items

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Items'] = []
        if self.items is not None:
            for k in self.items:
                result['Items'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('Items') is not None:
            for k in m.get('Items'):
                temp_model = QuerySoundCodeLabelListResponseBodyDataListItems()
                self.items.append(temp_model.from_map(k))
        return self


class QuerySoundCodeLabelListResponseBodyData(TeaModel):
    def __init__(
        self,
        list: QuerySoundCodeLabelListResponseBodyDataList = None,
        page_id: int = None,
        page_size: int = None,
        total: int = None,
    ):
        self.list = list
        self.page_id = page_id
        self.page_size = page_size
        self.total = total

    def validate(self):
        if self.list:
            self.list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.list is not None:
            result['List'] = self.list.to_map()
        if self.page_id is not None:
            result['PageId'] = self.page_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('List') is not None:
            temp_model = QuerySoundCodeLabelListResponseBodyDataList()
            self.list = temp_model.from_map(m['List'])
        if m.get('PageId') is not None:
            self.page_id = m.get('PageId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class QuerySoundCodeLabelListResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QuerySoundCodeLabelListResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QuerySoundCodeLabelListResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QuerySoundCodeLabelListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QuerySoundCodeLabelListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QuerySoundCodeLabelListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QuerySoundCodeListRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        page_id: int = None,
        page_size: int = None,
    ):
        self.iot_instance_id = iot_instance_id
        self.page_id = page_id
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.page_id is not None:
            result['PageId'] = self.page_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('PageId') is not None:
            self.page_id = m.get('PageId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class QuerySoundCodeListResponseBodyDataListItems(TeaModel):
    def __init__(
        self,
        duration: int = None,
        gmt_create: int = None,
        name: str = None,
        open_type: str = None,
        sound_code: str = None,
        sound_code_content: str = None,
    ):
        self.duration = duration
        self.gmt_create = gmt_create
        self.name = name
        self.open_type = open_type
        self.sound_code = sound_code
        self.sound_code_content = sound_code_content

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.name is not None:
            result['Name'] = self.name
        if self.open_type is not None:
            result['OpenType'] = self.open_type
        if self.sound_code is not None:
            result['SoundCode'] = self.sound_code
        if self.sound_code_content is not None:
            result['SoundCodeContent'] = self.sound_code_content
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OpenType') is not None:
            self.open_type = m.get('OpenType')
        if m.get('SoundCode') is not None:
            self.sound_code = m.get('SoundCode')
        if m.get('SoundCodeContent') is not None:
            self.sound_code_content = m.get('SoundCodeContent')
        return self


class QuerySoundCodeListResponseBodyDataList(TeaModel):
    def __init__(
        self,
        items: List[QuerySoundCodeListResponseBodyDataListItems] = None,
    ):
        self.items = items

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Items'] = []
        if self.items is not None:
            for k in self.items:
                result['Items'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('Items') is not None:
            for k in m.get('Items'):
                temp_model = QuerySoundCodeListResponseBodyDataListItems()
                self.items.append(temp_model.from_map(k))
        return self


class QuerySoundCodeListResponseBodyData(TeaModel):
    def __init__(
        self,
        list: QuerySoundCodeListResponseBodyDataList = None,
        page_id: int = None,
        page_size: int = None,
        total: int = None,
    ):
        self.list = list
        self.page_id = page_id
        self.page_size = page_size
        self.total = total

    def validate(self):
        if self.list:
            self.list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.list is not None:
            result['List'] = self.list.to_map()
        if self.page_id is not None:
            result['PageId'] = self.page_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('List') is not None:
            temp_model = QuerySoundCodeListResponseBodyDataList()
            self.list = temp_model.from_map(m['List'])
        if m.get('PageId') is not None:
            self.page_id = m.get('PageId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class QuerySoundCodeListResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QuerySoundCodeListResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QuerySoundCodeListResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QuerySoundCodeListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QuerySoundCodeListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QuerySoundCodeListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QuerySoundCodeScheduleListRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        page_id: int = None,
        page_size: int = None,
    ):
        self.iot_instance_id = iot_instance_id
        self.page_id = page_id
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.page_id is not None:
            result['PageId'] = self.page_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('PageId') is not None:
            self.page_id = m.get('PageId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class QuerySoundCodeScheduleListResponseBodyDataListItems(TeaModel):
    def __init__(
        self,
        description: str = None,
        end_date: str = None,
        end_time: str = None,
        gmt_create: int = None,
        name: str = None,
        open_type: str = None,
        schedule_code: str = None,
        start_date: str = None,
        start_time: str = None,
        status: str = None,
    ):
        self.description = description
        self.end_date = end_date
        self.end_time = end_time
        self.gmt_create = gmt_create
        self.name = name
        self.open_type = open_type
        self.schedule_code = schedule_code
        self.start_date = start_date
        self.start_time = start_time
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.end_date is not None:
            result['EndDate'] = self.end_date
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.name is not None:
            result['Name'] = self.name
        if self.open_type is not None:
            result['OpenType'] = self.open_type
        if self.schedule_code is not None:
            result['ScheduleCode'] = self.schedule_code
        if self.start_date is not None:
            result['StartDate'] = self.start_date
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EndDate') is not None:
            self.end_date = m.get('EndDate')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OpenType') is not None:
            self.open_type = m.get('OpenType')
        if m.get('ScheduleCode') is not None:
            self.schedule_code = m.get('ScheduleCode')
        if m.get('StartDate') is not None:
            self.start_date = m.get('StartDate')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class QuerySoundCodeScheduleListResponseBodyDataList(TeaModel):
    def __init__(
        self,
        items: List[QuerySoundCodeScheduleListResponseBodyDataListItems] = None,
    ):
        self.items = items

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Items'] = []
        if self.items is not None:
            for k in self.items:
                result['Items'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('Items') is not None:
            for k in m.get('Items'):
                temp_model = QuerySoundCodeScheduleListResponseBodyDataListItems()
                self.items.append(temp_model.from_map(k))
        return self


class QuerySoundCodeScheduleListResponseBodyData(TeaModel):
    def __init__(
        self,
        list: QuerySoundCodeScheduleListResponseBodyDataList = None,
        page_id: int = None,
        page_size: int = None,
        total: int = None,
    ):
        self.list = list
        self.page_id = page_id
        self.page_size = page_size
        self.total = total

    def validate(self):
        if self.list:
            self.list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.list is not None:
            result['List'] = self.list.to_map()
        if self.page_id is not None:
            result['PageId'] = self.page_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('List') is not None:
            temp_model = QuerySoundCodeScheduleListResponseBodyDataList()
            self.list = temp_model.from_map(m['List'])
        if m.get('PageId') is not None:
            self.page_id = m.get('PageId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class QuerySoundCodeScheduleListResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QuerySoundCodeScheduleListResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QuerySoundCodeScheduleListResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QuerySoundCodeScheduleListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QuerySoundCodeScheduleListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QuerySoundCodeScheduleListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QuerySpeechRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        speech_code: str = None,
    ):
        self.iot_instance_id = iot_instance_id
        self.speech_code = speech_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.speech_code is not None:
            result['SpeechCode'] = self.speech_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('SpeechCode') is not None:
            self.speech_code = m.get('SpeechCode')
        return self


class QuerySpeechResponseBodyDataSoundCodeConfig(TeaModel):
    def __init__(
        self,
        additional_duration: int = None,
        sound_code_content: str = None,
    ):
        self.additional_duration = additional_duration
        self.sound_code_content = sound_code_content

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.additional_duration is not None:
            result['AdditionalDuration'] = self.additional_duration
        if self.sound_code_content is not None:
            result['SoundCodeContent'] = self.sound_code_content
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AdditionalDuration') is not None:
            self.additional_duration = m.get('AdditionalDuration')
        if m.get('SoundCodeContent') is not None:
            self.sound_code_content = m.get('SoundCodeContent')
        return self


class QuerySpeechResponseBodyData(TeaModel):
    def __init__(
        self,
        audio_format: str = None,
        biz_code: str = None,
        enable_sound_code: bool = None,
        sound_code_config: QuerySpeechResponseBodyDataSoundCodeConfig = None,
        speech_code: str = None,
        speech_rate: int = None,
        speech_type: str = None,
        text: str = None,
        voice: str = None,
        volume: int = None,
    ):
        self.audio_format = audio_format
        self.biz_code = biz_code
        self.enable_sound_code = enable_sound_code
        self.sound_code_config = sound_code_config
        self.speech_code = speech_code
        self.speech_rate = speech_rate
        self.speech_type = speech_type
        self.text = text
        self.voice = voice
        self.volume = volume

    def validate(self):
        if self.sound_code_config:
            self.sound_code_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_format is not None:
            result['AudioFormat'] = self.audio_format
        if self.biz_code is not None:
            result['BizCode'] = self.biz_code
        if self.enable_sound_code is not None:
            result['EnableSoundCode'] = self.enable_sound_code
        if self.sound_code_config is not None:
            result['SoundCodeConfig'] = self.sound_code_config.to_map()
        if self.speech_code is not None:
            result['SpeechCode'] = self.speech_code
        if self.speech_rate is not None:
            result['SpeechRate'] = self.speech_rate
        if self.speech_type is not None:
            result['SpeechType'] = self.speech_type
        if self.text is not None:
            result['Text'] = self.text
        if self.voice is not None:
            result['Voice'] = self.voice
        if self.volume is not None:
            result['Volume'] = self.volume
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioFormat') is not None:
            self.audio_format = m.get('AudioFormat')
        if m.get('BizCode') is not None:
            self.biz_code = m.get('BizCode')
        if m.get('EnableSoundCode') is not None:
            self.enable_sound_code = m.get('EnableSoundCode')
        if m.get('SoundCodeConfig') is not None:
            temp_model = QuerySpeechResponseBodyDataSoundCodeConfig()
            self.sound_code_config = temp_model.from_map(m['SoundCodeConfig'])
        if m.get('SpeechCode') is not None:
            self.speech_code = m.get('SpeechCode')
        if m.get('SpeechRate') is not None:
            self.speech_rate = m.get('SpeechRate')
        if m.get('SpeechType') is not None:
            self.speech_type = m.get('SpeechType')
        if m.get('Text') is not None:
            self.text = m.get('Text')
        if m.get('Voice') is not None:
            self.voice = m.get('Voice')
        if m.get('Volume') is not None:
            self.volume = m.get('Volume')
        return self


class QuerySpeechResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QuerySpeechResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QuerySpeechResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QuerySpeechResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QuerySpeechResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QuerySpeechResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QuerySpeechDeviceRequest(TeaModel):
    def __init__(
        self,
        available_space: str = None,
        available_space_scope: str = None,
        device_name: str = None,
        iot_instance_id: str = None,
        page_id: int = None,
        page_size: int = None,
        project_code: str = None,
    ):
        self.available_space = available_space
        self.available_space_scope = available_space_scope
        self.device_name = device_name
        self.iot_instance_id = iot_instance_id
        self.page_id = page_id
        self.page_size = page_size
        self.project_code = project_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.available_space is not None:
            result['AvailableSpace'] = self.available_space
        if self.available_space_scope is not None:
            result['AvailableSpaceScope'] = self.available_space_scope
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.page_id is not None:
            result['PageId'] = self.page_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_code is not None:
            result['ProjectCode'] = self.project_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvailableSpace') is not None:
            self.available_space = m.get('AvailableSpace')
        if m.get('AvailableSpaceScope') is not None:
            self.available_space_scope = m.get('AvailableSpaceScope')
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('PageId') is not None:
            self.page_id = m.get('PageId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectCode') is not None:
            self.project_code = m.get('ProjectCode')
        return self


class QuerySpeechDeviceResponseBodyDataListItems(TeaModel):
    def __init__(
        self,
        available_space: float = None,
        device_name: str = None,
        iot_id: str = None,
        product_key: str = None,
    ):
        self.available_space = available_space
        self.device_name = device_name
        self.iot_id = iot_id
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.available_space is not None:
            result['AvailableSpace'] = self.available_space
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AvailableSpace') is not None:
            self.available_space = m.get('AvailableSpace')
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class QuerySpeechDeviceResponseBodyDataList(TeaModel):
    def __init__(
        self,
        items: List[QuerySpeechDeviceResponseBodyDataListItems] = None,
    ):
        self.items = items

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Items'] = []
        if self.items is not None:
            for k in self.items:
                result['Items'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('Items') is not None:
            for k in m.get('Items'):
                temp_model = QuerySpeechDeviceResponseBodyDataListItems()
                self.items.append(temp_model.from_map(k))
        return self


class QuerySpeechDeviceResponseBodyData(TeaModel):
    def __init__(
        self,
        list: QuerySpeechDeviceResponseBodyDataList = None,
        page_id: int = None,
        page_size: int = None,
        total: int = None,
    ):
        self.list = list
        self.page_id = page_id
        self.page_size = page_size
        self.total = total

    def validate(self):
        if self.list:
            self.list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.list is not None:
            result['List'] = self.list.to_map()
        if self.page_id is not None:
            result['PageId'] = self.page_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('List') is not None:
            temp_model = QuerySpeechDeviceResponseBodyDataList()
            self.list = temp_model.from_map(m['List'])
        if m.get('PageId') is not None:
            self.page_id = m.get('PageId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class QuerySpeechDeviceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QuerySpeechDeviceResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QuerySpeechDeviceResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QuerySpeechDeviceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QuerySpeechDeviceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QuerySpeechDeviceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QuerySpeechLicenseAvailableQuotaRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
    ):
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class QuerySpeechLicenseAvailableQuotaResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: int = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QuerySpeechLicenseAvailableQuotaResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QuerySpeechLicenseAvailableQuotaResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QuerySpeechLicenseAvailableQuotaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QuerySpeechLicenseDeviceListRequest(TeaModel):
    def __init__(
        self,
        check_group_id: str = None,
        device_name: str = None,
        iot_instance_id: str = None,
        license_status_list: List[str] = None,
        page_id: int = None,
        page_size: int = None,
        product_key: str = None,
    ):
        # The ID of a device group. The InSpecifiedGroup response parameter indicates whether the devices belong to the specified group.
        self.check_group_id = check_group_id
        # The keyword in the DeviceName of the device whose information you want to query. Fuzzy match is supported.
        self.device_name = device_name
        # The instance ID. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
        # 
        # >  You must specify this parameter for a public instance of the new version or an Enterprise Edition instance. You do not need to specify this parameter for a public instance of the previous version.
        # 
        # For more information, see the [Overview](~~356505~~) topic of IoT instances.
        self.iot_instance_id = iot_instance_id
        # The license status.
        # 
        # *   **NORMAL**: The license is valid.
        # *   **EXPIRE**: The license is expired.
        # *   **EXPIRING**: The license is about to expire.
        self.license_status_list = license_status_list
        # The page number. Valid values: 1 to 10000.
        self.page_id = page_id
        # The number of entries per page. Valid values: 1 to 50. Default value: 20.
        self.page_size = page_size
        # The **ProductKey** of the product to which the devices belong.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_group_id is not None:
            result['CheckGroupId'] = self.check_group_id
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.license_status_list is not None:
            result['LicenseStatusList'] = self.license_status_list
        if self.page_id is not None:
            result['PageId'] = self.page_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckGroupId') is not None:
            self.check_group_id = m.get('CheckGroupId')
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('LicenseStatusList') is not None:
            self.license_status_list = m.get('LicenseStatusList')
        if m.get('PageId') is not None:
            self.page_id = m.get('PageId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class QuerySpeechLicenseDeviceListResponseBodyDataDeviceListItem(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        device_status: str = None,
        expiry_time: int = None,
        in_specified_group: bool = None,
        iot_id: str = None,
        license_status: str = None,
        product_key: str = None,
        product_name: str = None,
    ):
        # The DeviceName of the device.
        self.device_name = device_name
        # The status of the device.
        # 
        # *   **ONLINE**: The device is online.
        # *   **OFFLINE**: The device is offline.
        # *   **UNACTIVE**: The device is not activated.
        # *   **DISABLE**: The device is disabled.
        # *   **DELETE**: The device is deleted.
        self.device_status = device_status
        # The expiration time of the license.
        self.expiry_time = expiry_time
        # Indicates whether the device belongs to the specified device group.
        self.in_specified_group = in_specified_group
        # The ID of the device. The ID is the unique identifier that is issued by IoT Platform to the device.
        self.iot_id = iot_id
        # The license status.
        # 
        # *   **NORMAL**: The license is valid.
        # *   **EXPIRE**: The license is expired.
        # *   **EXPIRING**: The license is about to expire.
        self.license_status = license_status
        # The **ProductKey** of the product to which the device belongs.
        self.product_key = product_key
        # The ProductName of the product to which the device belongs.
        self.product_name = product_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.device_status is not None:
            result['DeviceStatus'] = self.device_status
        if self.expiry_time is not None:
            result['ExpiryTime'] = self.expiry_time
        if self.in_specified_group is not None:
            result['InSpecifiedGroup'] = self.in_specified_group
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.license_status is not None:
            result['LicenseStatus'] = self.license_status
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.product_name is not None:
            result['ProductName'] = self.product_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('DeviceStatus') is not None:
            self.device_status = m.get('DeviceStatus')
        if m.get('ExpiryTime') is not None:
            self.expiry_time = m.get('ExpiryTime')
        if m.get('InSpecifiedGroup') is not None:
            self.in_specified_group = m.get('InSpecifiedGroup')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('LicenseStatus') is not None:
            self.license_status = m.get('LicenseStatus')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('ProductName') is not None:
            self.product_name = m.get('ProductName')
        return self


class QuerySpeechLicenseDeviceListResponseBodyDataDeviceList(TeaModel):
    def __init__(
        self,
        item: List[QuerySpeechLicenseDeviceListResponseBodyDataDeviceListItem] = None,
    ):
        self.item = item

    def validate(self):
        if self.item:
            for k in self.item:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['item'] = []
        if self.item is not None:
            for k in self.item:
                result['item'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.item = []
        if m.get('item') is not None:
            for k in m.get('item'):
                temp_model = QuerySpeechLicenseDeviceListResponseBodyDataDeviceListItem()
                self.item.append(temp_model.from_map(k))
        return self


class QuerySpeechLicenseDeviceListResponseBodyData(TeaModel):
    def __init__(
        self,
        device_list: QuerySpeechLicenseDeviceListResponseBodyDataDeviceList = None,
        page_id: int = None,
        page_size: int = None,
        total: int = None,
    ):
        # The information about devices.
        self.device_list = device_list
        # The page number.
        self.page_id = page_id
        # The number of entries per page.
        self.page_size = page_size
        # The total number of entries returned.
        self.total = total

    def validate(self):
        if self.device_list:
            self.device_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_list is not None:
            result['DeviceList'] = self.device_list.to_map()
        if self.page_id is not None:
            result['PageId'] = self.page_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceList') is not None:
            temp_model = QuerySpeechLicenseDeviceListResponseBodyDataDeviceList()
            self.device_list = temp_model.from_map(m['DeviceList'])
        if m.get('PageId') is not None:
            self.page_id = m.get('PageId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class QuerySpeechLicenseDeviceListResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QuerySpeechLicenseDeviceListResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The result of the request.
        self.data = data
        # The error message returned if the request fails.
        self.error_message = error_message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QuerySpeechLicenseDeviceListResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QuerySpeechLicenseDeviceListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QuerySpeechLicenseDeviceListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QuerySpeechLicenseDeviceListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QuerySpeechListRequest(TeaModel):
    def __init__(
        self,
        audio_format: str = None,
        iot_instance_id: str = None,
        page_id: int = None,
        page_size: int = None,
        project_code: str = None,
    ):
        self.audio_format = audio_format
        self.iot_instance_id = iot_instance_id
        self.page_id = page_id
        self.page_size = page_size
        self.project_code = project_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_format is not None:
            result['AudioFormat'] = self.audio_format
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.page_id is not None:
            result['PageId'] = self.page_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_code is not None:
            result['ProjectCode'] = self.project_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioFormat') is not None:
            self.audio_format = m.get('AudioFormat')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('PageId') is not None:
            self.page_id = m.get('PageId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectCode') is not None:
            self.project_code = m.get('ProjectCode')
        return self


class QuerySpeechListResponseBodyDataListItemsSpeechListItems(TeaModel):
    def __init__(
        self,
        biz_code: str = None,
        speech_code: str = None,
        text: str = None,
        voice: str = None,
    ):
        self.biz_code = biz_code
        self.speech_code = speech_code
        self.text = text
        self.voice = voice

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_code is not None:
            result['BizCode'] = self.biz_code
        if self.speech_code is not None:
            result['SpeechCode'] = self.speech_code
        if self.text is not None:
            result['Text'] = self.text
        if self.voice is not None:
            result['Voice'] = self.voice
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BizCode') is not None:
            self.biz_code = m.get('BizCode')
        if m.get('SpeechCode') is not None:
            self.speech_code = m.get('SpeechCode')
        if m.get('Text') is not None:
            self.text = m.get('Text')
        if m.get('Voice') is not None:
            self.voice = m.get('Voice')
        return self


class QuerySpeechListResponseBodyDataListItemsSpeechList(TeaModel):
    def __init__(
        self,
        items: List[QuerySpeechListResponseBodyDataListItemsSpeechListItems] = None,
    ):
        self.items = items

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Items'] = []
        if self.items is not None:
            for k in self.items:
                result['Items'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('Items') is not None:
            for k in m.get('Items'):
                temp_model = QuerySpeechListResponseBodyDataListItemsSpeechListItems()
                self.items.append(temp_model.from_map(k))
        return self


class QuerySpeechListResponseBodyDataListItems(TeaModel):
    def __init__(
        self,
        audio_format: str = None,
        biz_code: str = None,
        speech_code: str = None,
        speech_list: QuerySpeechListResponseBodyDataListItemsSpeechList = None,
        speech_type: str = None,
        text: str = None,
        voice: str = None,
    ):
        self.audio_format = audio_format
        self.biz_code = biz_code
        self.speech_code = speech_code
        self.speech_list = speech_list
        self.speech_type = speech_type
        self.text = text
        self.voice = voice

    def validate(self):
        if self.speech_list:
            self.speech_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_format is not None:
            result['AudioFormat'] = self.audio_format
        if self.biz_code is not None:
            result['BizCode'] = self.biz_code
        if self.speech_code is not None:
            result['SpeechCode'] = self.speech_code
        if self.speech_list is not None:
            result['SpeechList'] = self.speech_list.to_map()
        if self.speech_type is not None:
            result['SpeechType'] = self.speech_type
        if self.text is not None:
            result['Text'] = self.text
        if self.voice is not None:
            result['Voice'] = self.voice
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioFormat') is not None:
            self.audio_format = m.get('AudioFormat')
        if m.get('BizCode') is not None:
            self.biz_code = m.get('BizCode')
        if m.get('SpeechCode') is not None:
            self.speech_code = m.get('SpeechCode')
        if m.get('SpeechList') is not None:
            temp_model = QuerySpeechListResponseBodyDataListItemsSpeechList()
            self.speech_list = temp_model.from_map(m['SpeechList'])
        if m.get('SpeechType') is not None:
            self.speech_type = m.get('SpeechType')
        if m.get('Text') is not None:
            self.text = m.get('Text')
        if m.get('Voice') is not None:
            self.voice = m.get('Voice')
        return self


class QuerySpeechListResponseBodyDataList(TeaModel):
    def __init__(
        self,
        items: List[QuerySpeechListResponseBodyDataListItems] = None,
    ):
        self.items = items

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Items'] = []
        if self.items is not None:
            for k in self.items:
                result['Items'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('Items') is not None:
            for k in m.get('Items'):
                temp_model = QuerySpeechListResponseBodyDataListItems()
                self.items.append(temp_model.from_map(k))
        return self


class QuerySpeechListResponseBodyData(TeaModel):
    def __init__(
        self,
        list: QuerySpeechListResponseBodyDataList = None,
        page_id: int = None,
        page_size: int = None,
        total: int = None,
    ):
        self.list = list
        self.page_id = page_id
        self.page_size = page_size
        self.total = total

    def validate(self):
        if self.list:
            self.list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.list is not None:
            result['List'] = self.list.to_map()
        if self.page_id is not None:
            result['PageId'] = self.page_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('List') is not None:
            temp_model = QuerySpeechListResponseBodyDataList()
            self.list = temp_model.from_map(m['List'])
        if m.get('PageId') is not None:
            self.page_id = m.get('PageId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class QuerySpeechListResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QuerySpeechListResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QuerySpeechListResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QuerySpeechListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QuerySpeechListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QuerySpeechListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QuerySpeechPushJobRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        job_code: str = None,
        page_id: int = None,
        page_size: int = None,
        project_code: str = None,
        push_mode: str = None,
        status_list: List[str] = None,
    ):
        self.iot_instance_id = iot_instance_id
        self.job_code = job_code
        self.page_id = page_id
        self.page_size = page_size
        self.project_code = project_code
        self.push_mode = push_mode
        self.status_list = status_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.job_code is not None:
            result['JobCode'] = self.job_code
        if self.page_id is not None:
            result['PageId'] = self.page_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_code is not None:
            result['ProjectCode'] = self.project_code
        if self.push_mode is not None:
            result['PushMode'] = self.push_mode
        if self.status_list is not None:
            result['StatusList'] = self.status_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('JobCode') is not None:
            self.job_code = m.get('JobCode')
        if m.get('PageId') is not None:
            self.page_id = m.get('PageId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectCode') is not None:
            self.project_code = m.get('ProjectCode')
        if m.get('PushMode') is not None:
            self.push_mode = m.get('PushMode')
        if m.get('StatusList') is not None:
            self.status_list = m.get('StatusList')
        return self


class QuerySpeechPushJobResponseBodyDataListItems(TeaModel):
    def __init__(
        self,
        code: str = None,
        created_time: int = None,
        device_name: str = None,
        expired_time: int = None,
        fail_device_num: int = None,
        group_id: str = None,
        group_name: str = None,
        iot_id: str = None,
        product_key: str = None,
        push_mode: str = None,
        running_device_num: int = None,
        speech_num: int = None,
        speech_status: bool = None,
        status: str = None,
        success_device_num: int = None,
        total_device_num: int = None,
    ):
        self.code = code
        self.created_time = created_time
        self.device_name = device_name
        self.expired_time = expired_time
        self.fail_device_num = fail_device_num
        self.group_id = group_id
        self.group_name = group_name
        self.iot_id = iot_id
        self.product_key = product_key
        self.push_mode = push_mode
        self.running_device_num = running_device_num
        self.speech_num = speech_num
        self.speech_status = speech_status
        self.status = status
        self.success_device_num = success_device_num
        self.total_device_num = total_device_num

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.created_time is not None:
            result['CreatedTime'] = self.created_time
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.expired_time is not None:
            result['ExpiredTime'] = self.expired_time
        if self.fail_device_num is not None:
            result['FailDeviceNum'] = self.fail_device_num
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.push_mode is not None:
            result['PushMode'] = self.push_mode
        if self.running_device_num is not None:
            result['RunningDeviceNum'] = self.running_device_num
        if self.speech_num is not None:
            result['SpeechNum'] = self.speech_num
        if self.speech_status is not None:
            result['SpeechStatus'] = self.speech_status
        if self.status is not None:
            result['Status'] = self.status
        if self.success_device_num is not None:
            result['SuccessDeviceNum'] = self.success_device_num
        if self.total_device_num is not None:
            result['TotalDeviceNum'] = self.total_device_num
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('CreatedTime') is not None:
            self.created_time = m.get('CreatedTime')
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('ExpiredTime') is not None:
            self.expired_time = m.get('ExpiredTime')
        if m.get('FailDeviceNum') is not None:
            self.fail_device_num = m.get('FailDeviceNum')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('PushMode') is not None:
            self.push_mode = m.get('PushMode')
        if m.get('RunningDeviceNum') is not None:
            self.running_device_num = m.get('RunningDeviceNum')
        if m.get('SpeechNum') is not None:
            self.speech_num = m.get('SpeechNum')
        if m.get('SpeechStatus') is not None:
            self.speech_status = m.get('SpeechStatus')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('SuccessDeviceNum') is not None:
            self.success_device_num = m.get('SuccessDeviceNum')
        if m.get('TotalDeviceNum') is not None:
            self.total_device_num = m.get('TotalDeviceNum')
        return self


class QuerySpeechPushJobResponseBodyDataList(TeaModel):
    def __init__(
        self,
        items: List[QuerySpeechPushJobResponseBodyDataListItems] = None,
    ):
        self.items = items

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Items'] = []
        if self.items is not None:
            for k in self.items:
                result['Items'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('Items') is not None:
            for k in m.get('Items'):
                temp_model = QuerySpeechPushJobResponseBodyDataListItems()
                self.items.append(temp_model.from_map(k))
        return self


class QuerySpeechPushJobResponseBodyData(TeaModel):
    def __init__(
        self,
        list: QuerySpeechPushJobResponseBodyDataList = None,
        page_id: int = None,
        page_size: int = None,
        total: int = None,
    ):
        self.list = list
        self.page_id = page_id
        self.page_size = page_size
        self.total = total

    def validate(self):
        if self.list:
            self.list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.list is not None:
            result['List'] = self.list.to_map()
        if self.page_id is not None:
            result['PageId'] = self.page_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('List') is not None:
            temp_model = QuerySpeechPushJobResponseBodyDataList()
            self.list = temp_model.from_map(m['List'])
        if m.get('PageId') is not None:
            self.page_id = m.get('PageId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class QuerySpeechPushJobResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QuerySpeechPushJobResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QuerySpeechPushJobResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QuerySpeechPushJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QuerySpeechPushJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QuerySpeechPushJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QuerySpeechPushJobDeviceRequest(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        iot_instance_id: str = None,
        job_code: str = None,
        page_id: int = None,
        page_size: int = None,
        status: str = None,
    ):
        self.device_name = device_name
        self.iot_instance_id = iot_instance_id
        self.job_code = job_code
        self.page_id = page_id
        self.page_size = page_size
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.job_code is not None:
            result['JobCode'] = self.job_code
        if self.page_id is not None:
            result['PageId'] = self.page_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('JobCode') is not None:
            self.job_code = m.get('JobCode')
        if m.get('PageId') is not None:
            self.page_id = m.get('PageId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class QuerySpeechPushJobDeviceResponseBodyDataListItems(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        error_code: str = None,
        error_message: str = None,
        gmt_modified: int = None,
        status: str = None,
    ):
        self.device_name = device_name
        self.error_code = error_code
        self.error_message = error_message
        self.gmt_modified = gmt_modified
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class QuerySpeechPushJobDeviceResponseBodyDataList(TeaModel):
    def __init__(
        self,
        items: List[QuerySpeechPushJobDeviceResponseBodyDataListItems] = None,
    ):
        self.items = items

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Items'] = []
        if self.items is not None:
            for k in self.items:
                result['Items'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('Items') is not None:
            for k in m.get('Items'):
                temp_model = QuerySpeechPushJobDeviceResponseBodyDataListItems()
                self.items.append(temp_model.from_map(k))
        return self


class QuerySpeechPushJobDeviceResponseBodyData(TeaModel):
    def __init__(
        self,
        list: QuerySpeechPushJobDeviceResponseBodyDataList = None,
        page_id: int = None,
        page_size: int = None,
        total: int = None,
    ):
        self.list = list
        self.page_id = page_id
        self.page_size = page_size
        self.total = total

    def validate(self):
        if self.list:
            self.list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.list is not None:
            result['List'] = self.list.to_map()
        if self.page_id is not None:
            result['PageId'] = self.page_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('List') is not None:
            temp_model = QuerySpeechPushJobDeviceResponseBodyDataList()
            self.list = temp_model.from_map(m['List'])
        if m.get('PageId') is not None:
            self.page_id = m.get('PageId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class QuerySpeechPushJobDeviceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QuerySpeechPushJobDeviceResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QuerySpeechPushJobDeviceResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QuerySpeechPushJobDeviceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QuerySpeechPushJobDeviceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QuerySpeechPushJobDeviceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QuerySpeechPushJobSpeechRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        job_code: str = None,
        page_id: int = None,
        page_size: int = None,
    ):
        self.iot_instance_id = iot_instance_id
        self.job_code = job_code
        self.page_id = page_id
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.job_code is not None:
            result['JobCode'] = self.job_code
        if self.page_id is not None:
            result['PageId'] = self.page_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('JobCode') is not None:
            self.job_code = m.get('JobCode')
        if m.get('PageId') is not None:
            self.page_id = m.get('PageId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class QuerySpeechPushJobSpeechResponseBodyDataListItemsSpeechListItems(TeaModel):
    def __init__(
        self,
        biz_code: str = None,
        text: str = None,
        voice: str = None,
    ):
        self.biz_code = biz_code
        self.text = text
        self.voice = voice

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_code is not None:
            result['BizCode'] = self.biz_code
        if self.text is not None:
            result['Text'] = self.text
        if self.voice is not None:
            result['Voice'] = self.voice
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BizCode') is not None:
            self.biz_code = m.get('BizCode')
        if m.get('Text') is not None:
            self.text = m.get('Text')
        if m.get('Voice') is not None:
            self.voice = m.get('Voice')
        return self


class QuerySpeechPushJobSpeechResponseBodyDataListItemsSpeechList(TeaModel):
    def __init__(
        self,
        items: List[QuerySpeechPushJobSpeechResponseBodyDataListItemsSpeechListItems] = None,
    ):
        self.items = items

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Items'] = []
        if self.items is not None:
            for k in self.items:
                result['Items'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('Items') is not None:
            for k in m.get('Items'):
                temp_model = QuerySpeechPushJobSpeechResponseBodyDataListItemsSpeechListItems()
                self.items.append(temp_model.from_map(k))
        return self


class QuerySpeechPushJobSpeechResponseBodyDataListItems(TeaModel):
    def __init__(
        self,
        biz_code: str = None,
        speech_list: QuerySpeechPushJobSpeechResponseBodyDataListItemsSpeechList = None,
        speech_type: str = None,
        text: str = None,
        voice: str = None,
    ):
        self.biz_code = biz_code
        self.speech_list = speech_list
        self.speech_type = speech_type
        self.text = text
        self.voice = voice

    def validate(self):
        if self.speech_list:
            self.speech_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_code is not None:
            result['BizCode'] = self.biz_code
        if self.speech_list is not None:
            result['SpeechList'] = self.speech_list.to_map()
        if self.speech_type is not None:
            result['SpeechType'] = self.speech_type
        if self.text is not None:
            result['Text'] = self.text
        if self.voice is not None:
            result['Voice'] = self.voice
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BizCode') is not None:
            self.biz_code = m.get('BizCode')
        if m.get('SpeechList') is not None:
            temp_model = QuerySpeechPushJobSpeechResponseBodyDataListItemsSpeechList()
            self.speech_list = temp_model.from_map(m['SpeechList'])
        if m.get('SpeechType') is not None:
            self.speech_type = m.get('SpeechType')
        if m.get('Text') is not None:
            self.text = m.get('Text')
        if m.get('Voice') is not None:
            self.voice = m.get('Voice')
        return self


class QuerySpeechPushJobSpeechResponseBodyDataList(TeaModel):
    def __init__(
        self,
        items: List[QuerySpeechPushJobSpeechResponseBodyDataListItems] = None,
    ):
        self.items = items

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Items'] = []
        if self.items is not None:
            for k in self.items:
                result['Items'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.items = []
        if m.get('Items') is not None:
            for k in m.get('Items'):
                temp_model = QuerySpeechPushJobSpeechResponseBodyDataListItems()
                self.items.append(temp_model.from_map(k))
        return self


class QuerySpeechPushJobSpeechResponseBodyData(TeaModel):
    def __init__(
        self,
        list: QuerySpeechPushJobSpeechResponseBodyDataList = None,
        page_id: int = None,
        page_size: int = None,
        total: int = None,
    ):
        self.list = list
        self.page_id = page_id
        self.page_size = page_size
        self.total = total

    def validate(self):
        if self.list:
            self.list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.list is not None:
            result['List'] = self.list.to_map()
        if self.page_id is not None:
            result['PageId'] = self.page_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('List') is not None:
            temp_model = QuerySpeechPushJobSpeechResponseBodyDataList()
            self.list = temp_model.from_map(m['List'])
        if m.get('PageId') is not None:
            self.page_id = m.get('PageId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class QuerySpeechPushJobSpeechResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QuerySpeechPushJobSpeechResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QuerySpeechPushJobSpeechResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QuerySpeechPushJobSpeechResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QuerySpeechPushJobSpeechResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QuerySpeechPushJobSpeechResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryStudioAppDomainListOpenRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        iot_instance_id: str = None,
        project_id: str = None,
    ):
        self.app_id = app_id
        self.iot_instance_id = iot_instance_id
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class QueryStudioAppDomainListOpenResponseBodyDataListDomainInfo(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        gmt_create: str = None,
        gmt_modified: str = None,
        host: str = None,
        id: int = None,
        is_beian: str = None,
        project_id: str = None,
        protocol: str = None,
        tenant_id: str = None,
    ):
        self.app_id = app_id
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.host = host
        self.id = id
        self.is_beian = is_beian
        self.project_id = project_id
        self.protocol = protocol
        self.tenant_id = tenant_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.host is not None:
            result['Host'] = self.host
        if self.id is not None:
            result['Id'] = self.id
        if self.is_beian is not None:
            result['IsBeian'] = self.is_beian
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.protocol is not None:
            result['Protocol'] = self.protocol
        if self.tenant_id is not None:
            result['TenantId'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('Host') is not None:
            self.host = m.get('Host')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('IsBeian') is not None:
            self.is_beian = m.get('IsBeian')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Protocol') is not None:
            self.protocol = m.get('Protocol')
        if m.get('TenantId') is not None:
            self.tenant_id = m.get('TenantId')
        return self


class QueryStudioAppDomainListOpenResponseBodyDataList(TeaModel):
    def __init__(
        self,
        domain_info: List[QueryStudioAppDomainListOpenResponseBodyDataListDomainInfo] = None,
    ):
        self.domain_info = domain_info

    def validate(self):
        if self.domain_info:
            for k in self.domain_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DomainInfo'] = []
        if self.domain_info is not None:
            for k in self.domain_info:
                result['DomainInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.domain_info = []
        if m.get('DomainInfo') is not None:
            for k in m.get('DomainInfo'):
                temp_model = QueryStudioAppDomainListOpenResponseBodyDataListDomainInfo()
                self.domain_info.append(temp_model.from_map(k))
        return self


class QueryStudioAppDomainListOpenResponseBodyData(TeaModel):
    def __init__(
        self,
        list: QueryStudioAppDomainListOpenResponseBodyDataList = None,
        page_no: int = None,
        page_size: int = None,
        total: int = None,
        total_page: int = None,
    ):
        self.list = list
        self.page_no = page_no
        self.page_size = page_size
        self.total = total
        self.total_page = total_page

    def validate(self):
        if self.list:
            self.list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.list is not None:
            result['List'] = self.list.to_map()
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total is not None:
            result['Total'] = self.total
        if self.total_page is not None:
            result['TotalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('List') is not None:
            temp_model = QueryStudioAppDomainListOpenResponseBodyDataList()
            self.list = temp_model.from_map(m['List'])
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        if m.get('TotalPage') is not None:
            self.total_page = m.get('TotalPage')
        return self


class QueryStudioAppDomainListOpenResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryStudioAppDomainListOpenResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryStudioAppDomainListOpenResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryStudioAppDomainListOpenResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryStudioAppDomainListOpenResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryStudioAppDomainListOpenResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryStudioAppListRequest(TeaModel):
    def __init__(
        self,
        fuzzy_name: str = None,
        iot_instance_id: str = None,
        page_no: int = None,
        page_size: int = None,
        project_id: str = None,
        types: List[str] = None,
    ):
        self.fuzzy_name = fuzzy_name
        self.iot_instance_id = iot_instance_id
        self.page_no = page_no
        self.page_size = page_size
        self.project_id = project_id
        self.types = types

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fuzzy_name is not None:
            result['FuzzyName'] = self.fuzzy_name
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.types is not None:
            result['Types'] = self.types
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FuzzyName') is not None:
            self.fuzzy_name = m.get('FuzzyName')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Types') is not None:
            self.types = m.get('Types')
        return self


class QueryStudioAppListResponseBodyDataListAppInfo(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_key: str = None,
        app_secret: str = None,
        description: str = None,
        gmt_create: str = None,
        gmt_modified: str = None,
        gmt_release: str = None,
        name: str = None,
        project_id: str = None,
        type: str = None,
    ):
        self.app_id = app_id
        self.app_key = app_key
        self.app_secret = app_secret
        self.description = description
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.gmt_release = gmt_release
        self.name = name
        self.project_id = project_id
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.app_key is not None:
            result['AppKey'] = self.app_key
        if self.app_secret is not None:
            result['AppSecret'] = self.app_secret
        if self.description is not None:
            result['Description'] = self.description
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.gmt_release is not None:
            result['GmtRelease'] = self.gmt_release
        if self.name is not None:
            result['Name'] = self.name
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AppKey') is not None:
            self.app_key = m.get('AppKey')
        if m.get('AppSecret') is not None:
            self.app_secret = m.get('AppSecret')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('GmtRelease') is not None:
            self.gmt_release = m.get('GmtRelease')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class QueryStudioAppListResponseBodyDataList(TeaModel):
    def __init__(
        self,
        app_info: List[QueryStudioAppListResponseBodyDataListAppInfo] = None,
    ):
        self.app_info = app_info

    def validate(self):
        if self.app_info:
            for k in self.app_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AppInfo'] = []
        if self.app_info is not None:
            for k in self.app_info:
                result['AppInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.app_info = []
        if m.get('AppInfo') is not None:
            for k in m.get('AppInfo'):
                temp_model = QueryStudioAppListResponseBodyDataListAppInfo()
                self.app_info.append(temp_model.from_map(k))
        return self


class QueryStudioAppListResponseBodyData(TeaModel):
    def __init__(
        self,
        list: QueryStudioAppListResponseBodyDataList = None,
        page_no: int = None,
        page_size: int = None,
        total: int = None,
        total_page: int = None,
    ):
        self.list = list
        self.page_no = page_no
        self.page_size = page_size
        self.total = total
        self.total_page = total_page

    def validate(self):
        if self.list:
            self.list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.list is not None:
            result['List'] = self.list.to_map()
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total is not None:
            result['Total'] = self.total
        if self.total_page is not None:
            result['TotalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('List') is not None:
            temp_model = QueryStudioAppListResponseBodyDataList()
            self.list = temp_model.from_map(m['List'])
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        if m.get('TotalPage') is not None:
            self.total_page = m.get('TotalPage')
        return self


class QueryStudioAppListResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryStudioAppListResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryStudioAppListResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryStudioAppListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryStudioAppListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryStudioAppListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryStudioAppPageListOpenRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        iot_instance_id: str = None,
        is_release: bool = None,
        page_no: int = None,
        page_size: int = None,
        project_id: str = None,
    ):
        self.app_id = app_id
        self.iot_instance_id = iot_instance_id
        self.is_release = is_release
        self.page_no = page_no
        self.page_size = page_size
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.is_release is not None:
            result['IsRelease'] = self.is_release
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('IsRelease') is not None:
            self.is_release = m.get('IsRelease')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class QueryStudioAppPageListOpenResponseBodyDataListPageInfo(TeaModel):
    def __init__(
        self,
        gmt_create: str = None,
        gmt_modified: str = None,
        id: int = None,
        is_hidden: int = None,
        is_home: int = None,
        is_login_page: int = None,
        name: str = None,
        page_id: str = None,
        path: str = None,
    ):
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.id = id
        self.is_hidden = is_hidden
        self.is_home = is_home
        self.is_login_page = is_login_page
        self.name = name
        self.page_id = page_id
        self.path = path

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.id is not None:
            result['Id'] = self.id
        if self.is_hidden is not None:
            result['IsHidden'] = self.is_hidden
        if self.is_home is not None:
            result['IsHome'] = self.is_home
        if self.is_login_page is not None:
            result['IsLoginPage'] = self.is_login_page
        if self.name is not None:
            result['Name'] = self.name
        if self.page_id is not None:
            result['PageId'] = self.page_id
        if self.path is not None:
            result['Path'] = self.path
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('IsHidden') is not None:
            self.is_hidden = m.get('IsHidden')
        if m.get('IsHome') is not None:
            self.is_home = m.get('IsHome')
        if m.get('IsLoginPage') is not None:
            self.is_login_page = m.get('IsLoginPage')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PageId') is not None:
            self.page_id = m.get('PageId')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        return self


class QueryStudioAppPageListOpenResponseBodyDataList(TeaModel):
    def __init__(
        self,
        page_info: List[QueryStudioAppPageListOpenResponseBodyDataListPageInfo] = None,
    ):
        self.page_info = page_info

    def validate(self):
        if self.page_info:
            for k in self.page_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['PageInfo'] = []
        if self.page_info is not None:
            for k in self.page_info:
                result['PageInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.page_info = []
        if m.get('PageInfo') is not None:
            for k in m.get('PageInfo'):
                temp_model = QueryStudioAppPageListOpenResponseBodyDataListPageInfo()
                self.page_info.append(temp_model.from_map(k))
        return self


class QueryStudioAppPageListOpenResponseBodyData(TeaModel):
    def __init__(
        self,
        list: QueryStudioAppPageListOpenResponseBodyDataList = None,
        page_no: int = None,
        page_size: int = None,
        total: int = None,
        total_page: int = None,
    ):
        self.list = list
        self.page_no = page_no
        self.page_size = page_size
        self.total = total
        self.total_page = total_page

    def validate(self):
        if self.list:
            self.list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.list is not None:
            result['List'] = self.list.to_map()
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total is not None:
            result['Total'] = self.total
        if self.total_page is not None:
            result['TotalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('List') is not None:
            temp_model = QueryStudioAppPageListOpenResponseBodyDataList()
            self.list = temp_model.from_map(m['List'])
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        if m.get('TotalPage') is not None:
            self.total_page = m.get('TotalPage')
        return self


class QueryStudioAppPageListOpenResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryStudioAppPageListOpenResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryStudioAppPageListOpenResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryStudioAppPageListOpenResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryStudioAppPageListOpenResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryStudioAppPageListOpenResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryStudioProjectListRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        name: str = None,
        page_no: int = None,
        page_size: int = None,
    ):
        self.iot_instance_id = iot_instance_id
        self.name = name
        self.page_no = page_no
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.name is not None:
            result['Name'] = self.name
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class QueryStudioProjectListResponseBodyDataListProjectInfo(TeaModel):
    def __init__(
        self,
        description: str = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        name: str = None,
        project_id: str = None,
    ):
        self.description = description
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.name = name
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.name is not None:
            result['Name'] = self.name
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class QueryStudioProjectListResponseBodyDataList(TeaModel):
    def __init__(
        self,
        project_info: List[QueryStudioProjectListResponseBodyDataListProjectInfo] = None,
    ):
        self.project_info = project_info

    def validate(self):
        if self.project_info:
            for k in self.project_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ProjectInfo'] = []
        if self.project_info is not None:
            for k in self.project_info:
                result['ProjectInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.project_info = []
        if m.get('ProjectInfo') is not None:
            for k in m.get('ProjectInfo'):
                temp_model = QueryStudioProjectListResponseBodyDataListProjectInfo()
                self.project_info.append(temp_model.from_map(k))
        return self


class QueryStudioProjectListResponseBodyData(TeaModel):
    def __init__(
        self,
        list: QueryStudioProjectListResponseBodyDataList = None,
        page_no: int = None,
        page_size: int = None,
        total: int = None,
        total_page: int = None,
    ):
        self.list = list
        self.page_no = page_no
        self.page_size = page_size
        self.total = total
        self.total_page = total_page

    def validate(self):
        if self.list:
            self.list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.list is not None:
            result['List'] = self.list.to_map()
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total is not None:
            result['Total'] = self.total
        if self.total_page is not None:
            result['TotalPage'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('List') is not None:
            temp_model = QueryStudioProjectListResponseBodyDataList()
            self.list = temp_model.from_map(m['List'])
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        if m.get('TotalPage') is not None:
            self.total_page = m.get('TotalPage')
        return self


class QueryStudioProjectListResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryStudioProjectListResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryStudioProjectListResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryStudioProjectListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryStudioProjectListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryStudioProjectListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QuerySubscribeRelationRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        product_key: str = None,
        type: str = None,
    ):
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The ProductKey of the product that is specified for the subscription.
        self.product_key = product_key
        # The type of the subscription. Valid values:
        # 
        # *   **MNS**\
        # *   **AMQP**\
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class QuerySubscribeRelationResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        consumer_group_ids: List[str] = None,
        device_data_flag: bool = None,
        device_life_cycle_flag: bool = None,
        device_status_change_flag: bool = None,
        device_tag_flag: bool = None,
        device_topo_life_cycle_flag: bool = None,
        error_message: str = None,
        found_device_list_flag: bool = None,
        mns_configuration: str = None,
        ota_event_flag: bool = None,
        ota_job_flag: bool = None,
        ota_version_flag: bool = None,
        product_key: str = None,
        request_id: str = None,
        subscribe_flags: str = None,
        success: bool = None,
        thing_history_flag: bool = None,
        type: str = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The IDs of the consumer groups that are created in the AMQP subscription. This parameter is returned if the **Type** parameter is set to **AMQP**.
        self.consumer_group_ids = consumer_group_ids
        # Indicates whether upstream device messages were pushed.
        # 
        # *   **true**: yes.
        # *   **false**: no.
        self.device_data_flag = device_data_flag
        # Indicates whether messages about device lifecycle changes were pushed.
        # 
        # *   **true**: yes.
        # *   **false**: no.
        self.device_life_cycle_flag = device_life_cycle_flag
        # Indicates whether messages about device status changes were pushed.
        # 
        # *   **true**: yes.
        # *   **false**: no.
        self.device_status_change_flag = device_status_change_flag
        # Indicates whether messages about device tag changes were pushed. Valid values:
        # 
        # *   **true**: yes. This parameter takes effect only if the **Type** parameter is set to **AMQP**.
        # *   **false**: no.
        # 
        # Default value: **false**.
        self.device_tag_flag = device_tag_flag
        # Indicates whether messages about topological relationship changes of devices were pushed.
        # 
        # *   **true**: yes. The value **true** is returned only when you query a gateway product.
        # *   **false**: no.
        self.device_topo_life_cycle_flag = device_topo_life_cycle_flag
        # The error message returned if the call fails.
        self.error_message = error_message
        # Indicates whether messages were pushed if a gateway detected new sub-devices.
        # 
        # *   **true**: yes. The value **true** is returned only when you query a gateway product.
        # *   **false**: no.
        self.found_device_list_flag = found_device_list_flag
        # The configurations of the MNS queue. This parameter is returned if the **Type** parameter is set to **MNS**.
        # 
        # For more information, see the "Definition of the MnsConfiguration parameter" section.
        self.mns_configuration = mns_configuration
        # Indicates whether notifications about the status of OTA update batches were pushed.
        # 
        # *   **true**: yes.
        # *   **false**: no.
        self.ota_event_flag = ota_event_flag
        # Indicates whether notifications about OTA batch updates were pushed. Valid values:
        # 
        # *   **true**: yes. This parameter takes effect only if the **Type** parameter is set to **AMQP**.
        # *   **false**: no.
        # 
        # Default value: **false**.
        self.ota_job_flag = ota_job_flag
        # Indicates whether messages about the version numbers of OTA modules were pushed. Valid values:
        # 
        # *   **true**: yes. This parameter takes effect only if the **Type** parameter is set to **AMQP**.
        # *   **false**: no.
        # 
        # Default value: **false**.
        self.ota_version_flag = ota_version_flag
        # The ProductKey of the product that is specified for the subscription.
        self.product_key = product_key
        # The ID of the request.
        self.request_id = request_id
        self.subscribe_flags = subscribe_flags
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success
        # Indicates whether upstream historical Thing Specification Language (TSL) data was pushed.
        # 
        # *   **true**: yes.
        # *   **false**: no.
        self.thing_history_flag = thing_history_flag
        # The type of the subscription. Valid values:
        # 
        # *   **MNS**\
        # *   **AMQP**\
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.consumer_group_ids is not None:
            result['ConsumerGroupIds'] = self.consumer_group_ids
        if self.device_data_flag is not None:
            result['DeviceDataFlag'] = self.device_data_flag
        if self.device_life_cycle_flag is not None:
            result['DeviceLifeCycleFlag'] = self.device_life_cycle_flag
        if self.device_status_change_flag is not None:
            result['DeviceStatusChangeFlag'] = self.device_status_change_flag
        if self.device_tag_flag is not None:
            result['DeviceTagFlag'] = self.device_tag_flag
        if self.device_topo_life_cycle_flag is not None:
            result['DeviceTopoLifeCycleFlag'] = self.device_topo_life_cycle_flag
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.found_device_list_flag is not None:
            result['FoundDeviceListFlag'] = self.found_device_list_flag
        if self.mns_configuration is not None:
            result['MnsConfiguration'] = self.mns_configuration
        if self.ota_event_flag is not None:
            result['OtaEventFlag'] = self.ota_event_flag
        if self.ota_job_flag is not None:
            result['OtaJobFlag'] = self.ota_job_flag
        if self.ota_version_flag is not None:
            result['OtaVersionFlag'] = self.ota_version_flag
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.subscribe_flags is not None:
            result['SubscribeFlags'] = self.subscribe_flags
        if self.success is not None:
            result['Success'] = self.success
        if self.thing_history_flag is not None:
            result['ThingHistoryFlag'] = self.thing_history_flag
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ConsumerGroupIds') is not None:
            self.consumer_group_ids = m.get('ConsumerGroupIds')
        if m.get('DeviceDataFlag') is not None:
            self.device_data_flag = m.get('DeviceDataFlag')
        if m.get('DeviceLifeCycleFlag') is not None:
            self.device_life_cycle_flag = m.get('DeviceLifeCycleFlag')
        if m.get('DeviceStatusChangeFlag') is not None:
            self.device_status_change_flag = m.get('DeviceStatusChangeFlag')
        if m.get('DeviceTagFlag') is not None:
            self.device_tag_flag = m.get('DeviceTagFlag')
        if m.get('DeviceTopoLifeCycleFlag') is not None:
            self.device_topo_life_cycle_flag = m.get('DeviceTopoLifeCycleFlag')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('FoundDeviceListFlag') is not None:
            self.found_device_list_flag = m.get('FoundDeviceListFlag')
        if m.get('MnsConfiguration') is not None:
            self.mns_configuration = m.get('MnsConfiguration')
        if m.get('OtaEventFlag') is not None:
            self.ota_event_flag = m.get('OtaEventFlag')
        if m.get('OtaJobFlag') is not None:
            self.ota_job_flag = m.get('OtaJobFlag')
        if m.get('OtaVersionFlag') is not None:
            self.ota_version_flag = m.get('OtaVersionFlag')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SubscribeFlags') is not None:
            self.subscribe_flags = m.get('SubscribeFlags')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('ThingHistoryFlag') is not None:
            self.thing_history_flag = m.get('ThingHistoryFlag')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class QuerySubscribeRelationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QuerySubscribeRelationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QuerySubscribeRelationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QuerySummarySceneRuleLogRequest(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        end_time: int = None,
        iot_instance_id: str = None,
        page_size: int = None,
        rule_id: str = None,
        start_time: int = None,
        status: str = None,
    ):
        self.current_page = current_page
        self.end_time = end_time
        self.iot_instance_id = iot_instance_id
        self.page_size = page_size
        self.rule_id = rule_id
        self.start_time = start_time
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class QuerySummarySceneRuleLogResponseBodyDataLogListLogInfo(TeaModel):
    def __init__(
        self,
        log_time: int = None,
        result: str = None,
        trace_id: str = None,
    ):
        self.log_time = log_time
        self.result = result
        self.trace_id = trace_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.log_time is not None:
            result['LogTime'] = self.log_time
        if self.result is not None:
            result['Result'] = self.result
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('LogTime') is not None:
            self.log_time = m.get('LogTime')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class QuerySummarySceneRuleLogResponseBodyDataLogList(TeaModel):
    def __init__(
        self,
        log_info: List[QuerySummarySceneRuleLogResponseBodyDataLogListLogInfo] = None,
    ):
        self.log_info = log_info

    def validate(self):
        if self.log_info:
            for k in self.log_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LogInfo'] = []
        if self.log_info is not None:
            for k in self.log_info:
                result['LogInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.log_info = []
        if m.get('LogInfo') is not None:
            for k in m.get('LogInfo'):
                temp_model = QuerySummarySceneRuleLogResponseBodyDataLogListLogInfo()
                self.log_info.append(temp_model.from_map(k))
        return self


class QuerySummarySceneRuleLogResponseBodyData(TeaModel):
    def __init__(
        self,
        current_page: int = None,
        log_list: QuerySummarySceneRuleLogResponseBodyDataLogList = None,
        page_size: int = None,
        total: int = None,
    ):
        self.current_page = current_page
        self.log_list = log_list
        self.page_size = page_size
        self.total = total

    def validate(self):
        if self.log_list:
            self.log_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.log_list is not None:
            result['LogList'] = self.log_list.to_map()
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('LogList') is not None:
            temp_model = QuerySummarySceneRuleLogResponseBodyDataLogList()
            self.log_list = temp_model.from_map(m['LogList'])
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class QuerySummarySceneRuleLogResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QuerySummarySceneRuleLogResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QuerySummarySceneRuleLogResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QuerySummarySceneRuleLogResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QuerySummarySceneRuleLogResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QuerySummarySceneRuleLogResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QuerySuperDeviceGroupRequest(TeaModel):
    def __init__(
        self,
        group_id: str = None,
        iot_instance_id: str = None,
    ):
        # The ID of the subgroup. The ID is the globally unique identifier (GUID) for the group.
        self.group_id = group_id
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class QuerySuperDeviceGroupResponseBodyDataGroupInfo(TeaModel):
    def __init__(
        self,
        group_desc: str = None,
        group_id: str = None,
        group_name: str = None,
    ):
        # The description of the parent group.
        self.group_desc = group_desc
        # The ID of the parent group.
        self.group_id = group_id
        # The name of the parent group.
        self.group_name = group_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_desc is not None:
            result['GroupDesc'] = self.group_desc
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupDesc') is not None:
            self.group_desc = m.get('GroupDesc')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        return self


class QuerySuperDeviceGroupResponseBodyData(TeaModel):
    def __init__(
        self,
        group_info: List[QuerySuperDeviceGroupResponseBodyDataGroupInfo] = None,
    ):
        self.group_info = group_info

    def validate(self):
        if self.group_info:
            for k in self.group_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['GroupInfo'] = []
        if self.group_info is not None:
            for k in self.group_info:
                result['GroupInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.group_info = []
        if m.get('GroupInfo') is not None:
            for k in m.get('GroupInfo'):
                temp_model = QuerySuperDeviceGroupResponseBodyDataGroupInfo()
                self.group_info.append(temp_model.from_map(k))
        return self


class QuerySuperDeviceGroupResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QuerySuperDeviceGroupResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The parent group information returned if the call succeeds. For more information, see the following **GroupInfo** parameter.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QuerySuperDeviceGroupResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QuerySuperDeviceGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QuerySuperDeviceGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QuerySuperDeviceGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryTaskRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        task_id: str = None,
    ):
        self.iot_instance_id = iot_instance_id
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class QueryTaskResponseBodyData(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        iot_id: str = None,
        job_id: str = None,
        job_name: str = None,
        message: str = None,
        product_key: str = None,
        progress: str = None,
        status: str = None,
        status_detail: str = None,
        task_id: str = None,
        utc_modified: str = None,
        utc_queue_time: str = None,
    ):
        self.device_name = device_name
        self.iot_id = iot_id
        self.job_id = job_id
        self.job_name = job_name
        self.message = message
        self.product_key = product_key
        self.progress = progress
        self.status = status
        self.status_detail = status_detail
        self.task_id = task_id
        self.utc_modified = utc_modified
        self.utc_queue_time = utc_queue_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.job_name is not None:
            result['JobName'] = self.job_name
        if self.message is not None:
            result['Message'] = self.message
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.progress is not None:
            result['Progress'] = self.progress
        if self.status is not None:
            result['Status'] = self.status
        if self.status_detail is not None:
            result['StatusDetail'] = self.status_detail
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.utc_modified is not None:
            result['UtcModified'] = self.utc_modified
        if self.utc_queue_time is not None:
            result['UtcQueueTime'] = self.utc_queue_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('JobName') is not None:
            self.job_name = m.get('JobName')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('Progress') is not None:
            self.progress = m.get('Progress')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StatusDetail') is not None:
            self.status_detail = m.get('StatusDetail')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('UtcModified') is not None:
            self.utc_modified = m.get('UtcModified')
        if m.get('UtcQueueTime') is not None:
            self.utc_queue_time = m.get('UtcQueueTime')
        return self


class QueryTaskResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryTaskResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryTaskResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryTaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryTaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryThingModelRequest(TeaModel):
    def __init__(
        self,
        function_block_id: str = None,
        iot_instance_id: str = None,
        model_version: str = None,
        product_key: str = None,
        resource_group_id: str = None,
    ):
        # The identifier of the custom TSL module. Each identifier is unique in a product.
        # 
        # If you do not specify this parameter, the default module is queried.
        self.function_block_id = function_block_id
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The version number of the TSL model.
        # 
        # You can call the [ListThingModelVersion](~~150318~~) operation to view the version numbers of the TSL model for a product.
        # 
        # If you do not specify this parameter, the TSL model that is in the draft status is queried. If you specify this parameter, the TSL model of the specified version is queried.
        self.model_version = model_version
        # The **ProductKey** of the product.
        self.product_key = product_key
        # The ID of the resource group.
        # 
        # >  You cannot specify this parameter.
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.function_block_id is not None:
            result['FunctionBlockId'] = self.function_block_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.model_version is not None:
            result['ModelVersion'] = self.model_version
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FunctionBlockId') is not None:
            self.function_block_id = m.get('FunctionBlockId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ModelVersion') is not None:
            self.model_version = m.get('ModelVersion')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        return self


class QueryThingModelResponseBodyData(TeaModel):
    def __init__(
        self,
        thing_model_json: str = None,
    ):
        # The features of the TSL model. The TSL data format of the default module is different from the TSL data format of a custom module.
        # 
        # For more information about the data format of the ThingModelJson parameter, see [Data structure of ThingModelJson](~~150457~~).
        self.thing_model_json = thing_model_json

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.thing_model_json is not None:
            result['ThingModelJson'] = self.thing_model_json
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ThingModelJson') is not None:
            self.thing_model_json = m.get('ThingModelJson')
        return self


class QueryThingModelResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryThingModelResponseBodyData = None,
        error_message: str = None,
        product_key: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The data returned if the call is successful.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The **ProductKey** of the product.
        self.product_key = product_key
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryThingModelResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryThingModelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryThingModelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryThingModelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryThingModelExtendConfigRequest(TeaModel):
    def __init__(
        self,
        function_block_id: str = None,
        iot_instance_id: str = None,
        model_version: str = None,
        product_key: str = None,
        resource_group_id: str = None,
    ):
        # The identifier of the custom TSL module. Each identifier is unique in a product.
        # 
        # If you do not specify this parameter, the system exports the data of the default module.
        self.function_block_id = function_block_id
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The version number of the TSL model.
        # 
        # You can call the [ListThingModelVersion](~~150318~~) operation to view the version numbers of the TSL model for a product.
        # 
        # If you do not specify this parameter, the last published TSL version is returned.
        self.model_version = model_version
        # The ProductKey of the product.
        self.product_key = product_key
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.function_block_id is not None:
            result['FunctionBlockId'] = self.function_block_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.model_version is not None:
            result['ModelVersion'] = self.model_version
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FunctionBlockId') is not None:
            self.function_block_id = m.get('FunctionBlockId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ModelVersion') is not None:
            self.model_version = m.get('ModelVersion')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        return self


class QueryThingModelExtendConfigResponseBodyData(TeaModel):
    def __init__(
        self,
        configuration: str = None,
    ):
        # The information of the extended TSL parameters. For more information about the definition of extended parameters, see [CreateThingModel](~~150323~~).
        self.configuration = configuration

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.configuration is not None:
            result['Configuration'] = self.configuration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Configuration') is not None:
            self.configuration = m.get('Configuration')
        return self


class QueryThingModelExtendConfigResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryThingModelExtendConfigResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The data returned if the call is successful.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryThingModelExtendConfigResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryThingModelExtendConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryThingModelExtendConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryThingModelExtendConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryThingModelExtendConfigPublishedRequest(TeaModel):
    def __init__(
        self,
        function_block_id: str = None,
        iot_instance_id: str = None,
        model_version: str = None,
        product_key: str = None,
    ):
        # The identifier of the custom TSL module. Each identifier is unique in a product.
        # 
        # If you do not specify this parameter, the default module is queried.
        self.function_block_id = function_block_id
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The version number of the TSL model. If you do not specify this parameter, the last published TSL model is returned.
        self.model_version = model_version
        # The **ProductKey** of the product.
        # 
        # You can view the ProductKey on the Product Details page of the IoT Platform console. You can also obtain the ProductKey by calling the [QueryProductList](~~69271~~) operation.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.function_block_id is not None:
            result['FunctionBlockId'] = self.function_block_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.model_version is not None:
            result['ModelVersion'] = self.model_version
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FunctionBlockId') is not None:
            self.function_block_id = m.get('FunctionBlockId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ModelVersion') is not None:
            self.model_version = m.get('ModelVersion')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class QueryThingModelExtendConfigPublishedResponseBodyData(TeaModel):
    def __init__(
        self,
        configuration: str = None,
    ):
        # The information about the extended TSL parameters. For more information about the definition of extended parameters, see [CreateThingModel](~~150323~~).
        # 
        # For more information, see [Data structure of ThingModelJson](~~150457~~).
        self.configuration = configuration

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.configuration is not None:
            result['Configuration'] = self.configuration
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Configuration') is not None:
            self.configuration = m.get('Configuration')
        return self


class QueryThingModelExtendConfigPublishedResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryThingModelExtendConfigPublishedResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The data returned if the call is successful.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryThingModelExtendConfigPublishedResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryThingModelExtendConfigPublishedResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryThingModelExtendConfigPublishedResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryThingModelExtendConfigPublishedResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryThingModelPublishedRequest(TeaModel):
    def __init__(
        self,
        function_block_id: str = None,
        iot_instance_id: str = None,
        model_version: str = None,
        product_key: str = None,
        resource_group_id: str = None,
    ):
        # The identifier of the custom TSL module. Each identifier is unique in a product.
        # 
        # If you do not specify this parameter, the default module is queried.
        self.function_block_id = function_block_id
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The version number of the TSL model.
        # 
        # You can call the [ListThingModelVersion](~~150318~~) operation to view the version numbers of the TSL model for a product.
        # 
        # If you do not specify this parameter, the last published TSL model version is returned.
        self.model_version = model_version
        # The ProductKey of the product.
        self.product_key = product_key
        self.resource_group_id = resource_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.function_block_id is not None:
            result['FunctionBlockId'] = self.function_block_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.model_version is not None:
            result['ModelVersion'] = self.model_version
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FunctionBlockId') is not None:
            self.function_block_id = m.get('FunctionBlockId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ModelVersion') is not None:
            self.model_version = m.get('ModelVersion')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        return self


class QueryThingModelPublishedResponseBodyData(TeaModel):
    def __init__(
        self,
        thing_model_json: str = None,
    ):
        # Define features for the TSL model. For more information about the data format of the ThingModelJson parameter, see [Data structure of ThingModelJson](~~150457~~).
        self.thing_model_json = thing_model_json

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.thing_model_json is not None:
            result['ThingModelJson'] = self.thing_model_json
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ThingModelJson') is not None:
            self.thing_model_json = m.get('ThingModelJson')
        return self


class QueryThingModelPublishedResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryThingModelPublishedResponseBodyData = None,
        error_message: str = None,
        product_key: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The returned data.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ProductKey of the product.
        self.product_key = product_key
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryThingModelPublishedResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryThingModelPublishedResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryThingModelPublishedResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryThingModelPublishedResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryTopicConfigRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        product_key: str = None,
    ):
        self.iot_instance_id = iot_instance_id
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class QueryTopicConfigResponseBodyDataTopicConfigInfo(TeaModel):
    def __init__(
        self,
        codec: str = None,
        description: str = None,
        enable_broadcast: bool = None,
        enable_proxy_subscribe: bool = None,
        operation: str = None,
        product_key: str = None,
        topic_full_name: str = None,
    ):
        self.codec = codec
        self.description = description
        self.enable_broadcast = enable_broadcast
        self.enable_proxy_subscribe = enable_proxy_subscribe
        self.operation = operation
        self.product_key = product_key
        self.topic_full_name = topic_full_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.description is not None:
            result['Description'] = self.description
        if self.enable_broadcast is not None:
            result['EnableBroadcast'] = self.enable_broadcast
        if self.enable_proxy_subscribe is not None:
            result['EnableProxySubscribe'] = self.enable_proxy_subscribe
        if self.operation is not None:
            result['Operation'] = self.operation
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.topic_full_name is not None:
            result['TopicFullName'] = self.topic_full_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EnableBroadcast') is not None:
            self.enable_broadcast = m.get('EnableBroadcast')
        if m.get('EnableProxySubscribe') is not None:
            self.enable_proxy_subscribe = m.get('EnableProxySubscribe')
        if m.get('Operation') is not None:
            self.operation = m.get('Operation')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('TopicFullName') is not None:
            self.topic_full_name = m.get('TopicFullName')
        return self


class QueryTopicConfigResponseBodyData(TeaModel):
    def __init__(
        self,
        topic_config_info: List[QueryTopicConfigResponseBodyDataTopicConfigInfo] = None,
    ):
        self.topic_config_info = topic_config_info

    def validate(self):
        if self.topic_config_info:
            for k in self.topic_config_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['TopicConfigInfo'] = []
        if self.topic_config_info is not None:
            for k in self.topic_config_info:
                result['TopicConfigInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.topic_config_info = []
        if m.get('TopicConfigInfo') is not None:
            for k in m.get('TopicConfigInfo'):
                temp_model = QueryTopicConfigResponseBodyDataTopicConfigInfo()
                self.topic_config_info.append(temp_model.from_map(k))
        return self


class QueryTopicConfigResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryTopicConfigResponseBodyData = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryTopicConfigResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryTopicConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryTopicConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryTopicConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryTopicReverseRouteTableRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        region_id: str = None,
        topic: str = None,
    ):
        # The region where your devices reside. The region you specify must match the region that is specified in the console. Example: cn-shanghai.
        # 
        # >  This parameter is no longer used as an operation-specific request parameter. It is included in common request parameters.
        self.iot_instance_id = iot_instance_id
        # The destination topic that receives messages.
        self.region_id = region_id
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.topic = topic

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.topic is not None:
            result['Topic'] = self.topic
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Topic') is not None:
            self.topic = m.get('Topic')
        return self


class QueryTopicReverseRouteTableResponseBodySrcTopics(TeaModel):
    def __init__(
        self,
        topic: List[Dict[str, Any]] = None,
    ):
        self.topic = topic

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.topic is not None:
            result['Topic'] = self.topic
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Topic') is not None:
            self.topic = m.get('Topic')
        return self


class QueryTopicReverseRouteTableResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        src_topics: QueryTopicReverseRouteTableResponseBodySrcTopics = None,
        success: bool = None,
    ):
        # The error message returned if the call fails.
        self.code = code
        # The ID of the request.
        self.error_message = error_message
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.request_id = request_id
        self.src_topics = src_topics
        # The list of source topics returned if the call is successful.
        self.success = success

    def validate(self):
        if self.src_topics:
            self.src_topics.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.src_topics is not None:
            result['SrcTopics'] = self.src_topics.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SrcTopics') is not None:
            temp_model = QueryTopicReverseRouteTableResponseBodySrcTopics()
            self.src_topics = temp_model.from_map(m['SrcTopics'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryTopicReverseRouteTableResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryTopicReverseRouteTableResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryTopicReverseRouteTableResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryTopicRouteTableRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        topic: str = None,
    ):
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The source topic that publishes messages.
        self.topic = topic

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.topic is not None:
            result['Topic'] = self.topic
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('Topic') is not None:
            self.topic = m.get('Topic')
        return self


class QueryTopicRouteTableResponseBodyDstTopics(TeaModel):
    def __init__(
        self,
        topic: List[Dict[str, Any]] = None,
    ):
        self.topic = topic

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.topic is not None:
            result['Topic'] = self.topic
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Topic') is not None:
            self.topic = m.get('Topic')
        return self


class QueryTopicRouteTableResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        dst_topics: QueryTopicRouteTableResponseBodyDstTopics = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The list of destination topics returned if the call is successful.
        self.dst_topics = dst_topics
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.dst_topics:
            self.dst_topics.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.dst_topics is not None:
            result['DstTopics'] = self.dst_topics.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('DstTopics') is not None:
            temp_model = QueryTopicRouteTableResponseBodyDstTopics()
            self.dst_topics = temp_model.from_map(m['DstTopics'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryTopicRouteTableResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryTopicRouteTableResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryTopicRouteTableResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryVehicleDeviceRequest(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        iot_instance_id: str = None,
        product_key: str = None,
    ):
        # The DeviceName of the device.
        self.device_name = device_name
        # The ID of the instance. You can view the **ID** of the instance on the **Instance Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.****\
        # >*   If no **Overview** page or **ID** is generated for your instance, you do not need to configure this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The **ProductKey** of the gateway product to which the device belongs.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class QueryVehicleDeviceResponseBodyDataJtProtocolDeviceData(TeaModel):
    def __init__(
        self,
        auth_code: str = None,
        city: str = None,
        device_id: str = None,
        device_model: str = None,
        manufacturer: str = None,
        province: str = None,
        register_time: str = None,
        status: str = None,
        vehicle_colour: str = None,
        vehicle_number: str = None,
    ):
        self.auth_code = auth_code
        self.city = city
        self.device_id = device_id
        self.device_model = device_model
        self.manufacturer = manufacturer
        self.province = province
        self.register_time = register_time
        self.status = status
        self.vehicle_colour = vehicle_colour
        self.vehicle_number = vehicle_number

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_code is not None:
            result['AuthCode'] = self.auth_code
        if self.city is not None:
            result['City'] = self.city
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.device_model is not None:
            result['DeviceModel'] = self.device_model
        if self.manufacturer is not None:
            result['Manufacturer'] = self.manufacturer
        if self.province is not None:
            result['Province'] = self.province
        if self.register_time is not None:
            result['RegisterTime'] = self.register_time
        if self.status is not None:
            result['Status'] = self.status
        if self.vehicle_colour is not None:
            result['VehicleColour'] = self.vehicle_colour
        if self.vehicle_number is not None:
            result['VehicleNumber'] = self.vehicle_number
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuthCode') is not None:
            self.auth_code = m.get('AuthCode')
        if m.get('City') is not None:
            self.city = m.get('City')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('DeviceModel') is not None:
            self.device_model = m.get('DeviceModel')
        if m.get('Manufacturer') is not None:
            self.manufacturer = m.get('Manufacturer')
        if m.get('Province') is not None:
            self.province = m.get('Province')
        if m.get('RegisterTime') is not None:
            self.register_time = m.get('RegisterTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('VehicleColour') is not None:
            self.vehicle_colour = m.get('VehicleColour')
        if m.get('VehicleNumber') is not None:
            self.vehicle_number = m.get('VehicleNumber')
        return self


class QueryVehicleDeviceResponseBodyData(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        device_name: str = None,
        iot_id: str = None,
        jt_protocol_device_data: QueryVehicleDeviceResponseBodyDataJtProtocolDeviceData = None,
        modified_time: int = None,
        product_key: str = None,
        protocol: str = None,
    ):
        # The timestamp when the device was created. Unit: milliseconds.
        self.create_time = create_time
        # The DeviceName of the device.
        self.device_name = device_name
        # The ID is a unique identifier that is issued by IoT Platform to the device.
        self.iot_id = iot_id
        self.jt_protocol_device_data = jt_protocol_device_data
        # The timestamp when the device was last updated. Unit: milliseconds.
        self.modified_time = modified_time
        # The **ProductKey** of the gateway product to which the device belongs.
        self.product_key = product_key
        self.protocol = protocol

    def validate(self):
        if self.jt_protocol_device_data:
            self.jt_protocol_device_data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.jt_protocol_device_data is not None:
            result['JtProtocolDeviceData'] = self.jt_protocol_device_data.to_map()
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.protocol is not None:
            result['Protocol'] = self.protocol
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('JtProtocolDeviceData') is not None:
            temp_model = QueryVehicleDeviceResponseBodyDataJtProtocolDeviceData()
            self.jt_protocol_device_data = temp_model.from_map(m['JtProtocolDeviceData'])
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('Protocol') is not None:
            self.protocol = m.get('Protocol')
        return self


class QueryVehicleDeviceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: QueryVehicleDeviceResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see the "**Error codes**" section of this topic.
        self.code = code
        # The device information returned.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful. Valid values:
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = QueryVehicleDeviceResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class QueryVehicleDeviceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: QueryVehicleDeviceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryVehicleDeviceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RRpcRequest(TeaModel):
    def __init__(
        self,
        content_type: str = None,
        device_name: str = None,
        iot_instance_id: str = None,
        product_key: str = None,
        request_base_64byte: str = None,
        timeout: int = None,
        topic: str = None,
    ):
        self.content_type = content_type
        # The name of the device that receives the request.
        self.device_name = device_name
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The ProductKey of the product to which the device belongs.
        self.product_key = product_key
        self.request_base_64byte = request_base_64byte
        # The timeout period of a response. Unit: milliseconds. Valid values: 1000 to 8000.
        self.timeout = timeout
        # The custom revert-RPC (RRPC) topic. Before you can use a custom RRPC topic, you must configure the device. For more information, see [Use custom topics](~~90570~~).
        # 
        # If you do not configure this parameter, the default RRPC topic is used.
        self.topic = topic

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content_type is not None:
            result['ContentType'] = self.content_type
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.request_base_64byte is not None:
            result['RequestBase64Byte'] = self.request_base_64byte
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.topic is not None:
            result['Topic'] = self.topic
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ContentType') is not None:
            self.content_type = m.get('ContentType')
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('RequestBase64Byte') is not None:
            self.request_base_64byte = m.get('RequestBase64Byte')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('Topic') is not None:
            self.topic = m.get('Topic')
        return self


class RRpcResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        message_id: int = None,
        payload_base_64byte: str = None,
        request_id: str = None,
        rrpc_code: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request. The request ID is generated by IoT Platform after the request is sent.
        self.message_id = message_id
        # The Base64 encoded payload that is returned by the device.
        self.payload_base_64byte = payload_base_64byte
        # The ID of the request.
        self.request_id = request_id
        # The response code returned if the call is successful. Valid values:
        # 
        # *   **UNKNOWN**: A system error occurred.
        # *   **SUCCESS**: The request is successful.
        # *   **TIMEOUT**: The request times out.
        # *   **OFFLINE**: The device is offline.
        # *   **HALFCONN**: The device is offline. If the status of the device is HALFCONN, the device is offline but does not remain offline for a full heartbeat cycle.
        self.rrpc_code = rrpc_code
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.message_id is not None:
            result['MessageId'] = self.message_id
        if self.payload_base_64byte is not None:
            result['PayloadBase64Byte'] = self.payload_base_64byte
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.rrpc_code is not None:
            result['RrpcCode'] = self.rrpc_code
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('MessageId') is not None:
            self.message_id = m.get('MessageId')
        if m.get('PayloadBase64Byte') is not None:
            self.payload_base_64byte = m.get('PayloadBase64Byte')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RrpcCode') is not None:
            self.rrpc_code = m.get('RrpcCode')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class RRpcResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RRpcResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RRpcResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ReBindLicenseDeviceRequest(TeaModel):
    def __init__(
        self,
        device_name_list: List[str] = None,
        iot_instance_id: str = None,
        license_code: str = None,
        product_key: str = None,
    ):
        # The **DeviceNames** of all devices to which you want to rebind a license.
        # 
        # You can call the [QueryDevice](~~69905~~) operation to query the **DeviceNames** of all devices that belong to a specific product.
        self.device_name_list = device_name_list
        # The instance ID. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
        # 
        # >  You must specify the ID of a public instance of the new version or an Enterprise Edition instance. Otherwise, the request fails. You do not need to specify the ID of a public instance of the previous version.
        # 
        # For more information, see [Overview](~~356505~~) of IoT instances.
        self.iot_instance_id = iot_instance_id
        # The license type. Set the value to **LINK_SPEECH_COMMON_LICENSE**.
        self.license_code = license_code
        # The **ProductKey** of the product to which the devices belong.
        # 
        # You can go to the IoT Platform console or call the [QueryProductList](~~69271~~) operation to view the information about all products of the instance.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name_list is not None:
            result['DeviceNameList'] = self.device_name_list
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.license_code is not None:
            result['LicenseCode'] = self.license_code
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceNameList') is not None:
            self.device_name_list = m.get('DeviceNameList')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('LicenseCode') is not None:
            self.license_code = m.get('LicenseCode')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class ReBindLicenseDeviceResponseBodyData(TeaModel):
    def __init__(
        self,
        check_progress_id: str = None,
        fail_sum: int = None,
        progress: int = None,
        result_csv_file: str = None,
        success_sum: int = None,
    ):
        # The unique ID that can be used to query the progress of the batch rebinding operation.
        self.check_progress_id = check_progress_id
        # The number of devices that failed to be rebound to the license.
        self.fail_sum = fail_sum
        # The progress of the batch rebinding operation. The progress is a percentage. Valid values: 1 to 100.
        self.progress = progress
        # The URL of the file that contains unbound devices. The devices failed to be rebound with the license.
        self.result_csv_file = result_csv_file
        # The number of devices to which the license is rebound.
        self.success_sum = success_sum

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_progress_id is not None:
            result['CheckProgressId'] = self.check_progress_id
        if self.fail_sum is not None:
            result['FailSum'] = self.fail_sum
        if self.progress is not None:
            result['Progress'] = self.progress
        if self.result_csv_file is not None:
            result['ResultCsvFile'] = self.result_csv_file
        if self.success_sum is not None:
            result['SuccessSum'] = self.success_sum
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CheckProgressId') is not None:
            self.check_progress_id = m.get('CheckProgressId')
        if m.get('FailSum') is not None:
            self.fail_sum = m.get('FailSum')
        if m.get('Progress') is not None:
            self.progress = m.get('Progress')
        if m.get('ResultCsvFile') is not None:
            self.result_csv_file = m.get('ResultCsvFile')
        if m.get('SuccessSum') is not None:
            self.success_sum = m.get('SuccessSum')
        return self


class ReBindLicenseDeviceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: ReBindLicenseDeviceResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The result of the batch rebinding operation.
        self.data = data
        # The error message returned if the request fails.
        self.error_message = error_message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ReBindLicenseDeviceResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ReBindLicenseDeviceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ReBindLicenseDeviceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ReBindLicenseDeviceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RecognizeCarNumRequest(TeaModel):
    def __init__(
        self,
        url: str = None,
    ):
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class RecognizeCarNumResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class RecognizeCarNumResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RecognizeCarNumResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RecognizeCarNumResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RecognizePictureGeneralRequest(TeaModel):
    def __init__(
        self,
        url: str = None,
    ):
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class RecognizePictureGeneralResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class RecognizePictureGeneralResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RecognizePictureGeneralResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RecognizePictureGeneralResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RefreshDeviceTunnelSharePasswordRequest(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        iot_instance_id: str = None,
        product_key: str = None,
    ):
        self.device_name = device_name
        self.iot_instance_id = iot_instance_id
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class RefreshDeviceTunnelSharePasswordResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        password: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.password = password
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.password is not None:
            result['Password'] = self.password
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Password') is not None:
            self.password = m.get('Password')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class RefreshDeviceTunnelSharePasswordResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RefreshDeviceTunnelSharePasswordResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RefreshDeviceTunnelSharePasswordResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RefreshStudioAppTokenOpenRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        iot_instance_id: str = None,
        project_id: str = None,
    ):
        self.app_id = app_id
        self.iot_instance_id = iot_instance_id
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class RefreshStudioAppTokenOpenResponseBodyData(TeaModel):
    def __init__(
        self,
        biz_id: str = None,
        biz_type: str = None,
        is_enable: str = None,
        token: str = None,
        type: str = None,
    ):
        self.biz_id = biz_id
        self.biz_type = biz_type
        self.is_enable = is_enable
        self.token = token
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_id is not None:
            result['BizId'] = self.biz_id
        if self.biz_type is not None:
            result['BizType'] = self.biz_type
        if self.is_enable is not None:
            result['IsEnable'] = self.is_enable
        if self.token is not None:
            result['Token'] = self.token
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BizId') is not None:
            self.biz_id = m.get('BizId')
        if m.get('BizType') is not None:
            self.biz_type = m.get('BizType')
        if m.get('IsEnable') is not None:
            self.is_enable = m.get('IsEnable')
        if m.get('Token') is not None:
            self.token = m.get('Token')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class RefreshStudioAppTokenOpenResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: RefreshStudioAppTokenOpenResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = RefreshStudioAppTokenOpenResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class RefreshStudioAppTokenOpenResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RefreshStudioAppTokenOpenResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RefreshStudioAppTokenOpenResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RegisterDeviceRequest(TeaModel):
    def __init__(
        self,
        app_key: str = None,
        dev_eui: str = None,
        device_name: str = None,
        iot_instance_id: str = None,
        join_eui: str = None,
        lora_node_type: str = None,
        nickname: str = None,
        pin_code: str = None,
        product_key: str = None,
    ):
        # The AppKey of the LoRaWAN device.
        # 
        # When you create a LoRaWAN device, set **LoraNodeType** to **USERDEFINED**. This parameter is required.
        self.app_key = app_key
        # The DevEUI of the LoRaWAN device.
        # 
        # This parameter is required when you create a LoRaWAN device.
        self.dev_eui = dev_eui
        # The DeviceName of the device. The name must be 4 to 32 characters in length, and can contain letters, digits, hyphens (-), underscores (\_), at signs (@), periods (.), and colons (:).
        # 
        # You can use a combination of the DeviceName and ProductKey parameters to identify a device.
        # 
        # >  If you do not specify this parameter, IoT Platform randomly generates a DeviceName.
        self.device_name = device_name
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The JoinEUI of the LoRaWAN device.
        # 
        # When you create a LoRaWAN device, set **LoraNodeType** to **USERDEFINED**. This parameter is required.
        self.join_eui = join_eui
        # The type of the LoRaWAN device. Valid values:
        # 
        # *   **ALIYUNDEFINED**: The device is issued by Alibaba Cloud. You must specify **DevEui** and **PinCode**.
        # *   **USERDEFINED**: The device is user-defined. You must specify **DevEui**, **JoinEui**, and **AppKey**.
        self.lora_node_type = lora_node_type
        # The alias of the device. The alias must be 4 to 64 characters in length, and can contain letters, digits, and underscores (\_).
        # 
        # >  If you do not specify this parameter, IoT Platform does not generate an alias for the device.
        self.nickname = nickname
        # The PIN code of the LoRaWAN device. This parameter is used to verify the DevEUI.
        # 
        # When you create a LoRaWAN device, set **LoraNodeType** to **ALIYUNDEFINED**. This parameter is required.
        self.pin_code = pin_code
        # The ProductKey of the product to which the device belongs. A ProductKey is a GUID that is issued by IoT Platform to a product.
        # 
        # You can use the IoT Platform console or call the [QueryProductList](~~69271~~) operation to view the information about all products within the current account.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_key is not None:
            result['AppKey'] = self.app_key
        if self.dev_eui is not None:
            result['DevEui'] = self.dev_eui
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.join_eui is not None:
            result['JoinEui'] = self.join_eui
        if self.lora_node_type is not None:
            result['LoraNodeType'] = self.lora_node_type
        if self.nickname is not None:
            result['Nickname'] = self.nickname
        if self.pin_code is not None:
            result['PinCode'] = self.pin_code
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppKey') is not None:
            self.app_key = m.get('AppKey')
        if m.get('DevEui') is not None:
            self.dev_eui = m.get('DevEui')
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('JoinEui') is not None:
            self.join_eui = m.get('JoinEui')
        if m.get('LoraNodeType') is not None:
            self.lora_node_type = m.get('LoraNodeType')
        if m.get('Nickname') is not None:
            self.nickname = m.get('Nickname')
        if m.get('PinCode') is not None:
            self.pin_code = m.get('PinCode')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class RegisterDeviceResponseBodyData(TeaModel):
    def __init__(
        self,
        dev_eui: str = None,
        device_name: str = None,
        device_secret: str = None,
        iot_id: str = None,
        join_eui: str = None,
        nickname: str = None,
        product_key: str = None,
    ):
        # The DevEUI of the LoRaWAN device. This parameter is returned only when you create a LoRaWAN device.
        self.dev_eui = dev_eui
        # The DeviceName of the device.
        # 
        # > Keep the information confidential.
        self.device_name = device_name
        # The DeviceSecret of the device.
        # 
        # > Keep the information confidential.
        self.device_secret = device_secret
        # The ID of the device. The ID is the unique identifier that is issued by IoT Platform to the device.
        # 
        # > Keep the information confidential.
        self.iot_id = iot_id
        # The JoinEUI of the LoRaWAN device. This parameter is returned only when you create a LoRaWAN device.
        self.join_eui = join_eui
        # The alias of the device.
        # 
        # If you do not specify an alias for the device, this parameter is empty.
        self.nickname = nickname
        # The ProductKey of the product to which the device belongs.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dev_eui is not None:
            result['DevEui'] = self.dev_eui
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.device_secret is not None:
            result['DeviceSecret'] = self.device_secret
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.join_eui is not None:
            result['JoinEui'] = self.join_eui
        if self.nickname is not None:
            result['Nickname'] = self.nickname
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DevEui') is not None:
            self.dev_eui = m.get('DevEui')
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('DeviceSecret') is not None:
            self.device_secret = m.get('DeviceSecret')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('JoinEui') is not None:
            self.join_eui = m.get('JoinEui')
        if m.get('Nickname') is not None:
            self.nickname = m.get('Nickname')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class RegisterDeviceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: RegisterDeviceResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The device information returned if the call is successful.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = RegisterDeviceResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class RegisterDeviceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RegisterDeviceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RegisterDeviceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ReleaseEdgeDriverVersionRequest(TeaModel):
    def __init__(
        self,
        driver_id: str = None,
        driver_version: str = None,
        iot_instance_id: str = None,
    ):
        self.driver_id = driver_id
        self.driver_version = driver_version
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.driver_id is not None:
            result['DriverId'] = self.driver_id
        if self.driver_version is not None:
            result['DriverVersion'] = self.driver_version
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DriverId') is not None:
            self.driver_id = m.get('DriverId')
        if m.get('DriverVersion') is not None:
            self.driver_version = m.get('DriverVersion')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class ReleaseEdgeDriverVersionResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ReleaseEdgeDriverVersionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ReleaseEdgeDriverVersionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ReleaseEdgeDriverVersionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ReleaseProductRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        product_key: str = None,
    ):
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The **ProductKey** of the product to be published.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class ReleaseProductResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ReleaseProductResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ReleaseProductResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ReleaseProductResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RemoveThingTopoRequest(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        iot_id: str = None,
        iot_instance_id: str = None,
        product_key: str = None,
    ):
        # The DeviceName of the device.
        # 
        # >  If you specify a value for this parameter, you must also specify a value for the **ProductKey** parameter.
        self.device_name = device_name
        # The ID of the device. The ID is a unique identifier that is issued by IoT Platform to the device.
        # 
        # >  If you specify a value for this parameter, you do not need to specify a value for the **ProductKey** or **DeviceName** parameter. The IotId parameter specifies a globally unique identifier (GUID) for the device. The value of the **IotId** parameter corresponds to a combination of the values of the **ProductKey** and **DeviceName** parameters. If you specify a value for the **IotId** parameter and values for the **ProductKey** and **DeviceName** parameters, the value of the **IotId** parameter takes precedence.
        self.iot_id = iot_id
        # The ID of the instance. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
        # 
        # 
        # **Important**\
        # 
        # *   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.
        # *   If no **Overview** page or ID is generated for your instance, you do not need to configure this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The **ProductKey** of the product to which the device belongs.
        # 
        # >  If you specify a value for this parameter, you must also specify a value for the **DeviceName** parameter.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class RemoveThingTopoResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: bool = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # Indicates whether the topological relationship was deleted.
        # 
        # *   **true**: The topological relationship was deleted.
        # *   **false**: The topological relationship failed to be deleted.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class RemoveThingTopoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RemoveThingTopoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RemoveThingTopoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ReplaceEdgeInstanceGatewayRequest(TeaModel):
    def __init__(
        self,
        current_gateway_id: str = None,
        instance_id: str = None,
        iot_instance_id: str = None,
        new_gateway_id: str = None,
    ):
        self.current_gateway_id = current_gateway_id
        self.instance_id = instance_id
        self.iot_instance_id = iot_instance_id
        self.new_gateway_id = new_gateway_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_gateway_id is not None:
            result['CurrentGatewayId'] = self.current_gateway_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.new_gateway_id is not None:
            result['NewGatewayId'] = self.new_gateway_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('CurrentGatewayId') is not None:
            self.current_gateway_id = m.get('CurrentGatewayId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('NewGatewayId') is not None:
            self.new_gateway_id = m.get('NewGatewayId')
        return self


class ReplaceEdgeInstanceGatewayResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ReplaceEdgeInstanceGatewayResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ReplaceEdgeInstanceGatewayResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ReplaceEdgeInstanceGatewayResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RerunJobRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        job_id: str = None,
    ):
        self.iot_instance_id = iot_instance_id
        self.job_id = job_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class RerunJobResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class RerunJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RerunJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RerunJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ResetConsumerGroupPositionRequest(TeaModel):
    def __init__(
        self,
        group_id: str = None,
        iot_instance_id: str = None,
    ):
        # The ID of the consumer group. After you call the [CreateConsumerGroup](~~170388~~) operation to create a consumer group, the consumer group ID is returned. You can call the [QueryConsumerGroupList](~~170419~~) operation to query the consumer group ID by group name. You can also go to the IoT Platform console,and choose **Rules** > **Server-side Subscription** > **Consumer Groups** to view the consumer group ID.
        self.group_id = group_id
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class ResetConsumerGroupPositionResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ResetConsumerGroupPositionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ResetConsumerGroupPositionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ResetConsumerGroupPositionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ResetDeviceTimelineRequest(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        iot_instance_id: str = None,
        product_key: str = None,
    ):
        self.device_name = device_name
        self.iot_instance_id = iot_instance_id
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class ResetDeviceTimelineResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ResetDeviceTimelineResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ResetDeviceTimelineResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ResetDeviceTimelineResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ResetThingRequest(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        iot_id: str = None,
        iot_instance_id: str = None,
        product_key: str = None,
    ):
        # The DeviceName of the device.
        # 
        # >  If you specify a value for this parameter, you must also specify a value for the **ProductKey** parameter.
        self.device_name = device_name
        # The ID of the device.
        # 
        # >  If you specify a value for this parameter, you do not need to specify a value for the **ProductKey** or **DeviceName** parameter. The **IotId** parameter specifies a globally unique identifier (GUID) for the device. The value of the IotId parameter corresponds to a combination of the values of the **ProductKey** and **DeviceName** parameters. If you specify a value for the **IotId** parameter and values for the **ProductKey** and **DeviceName** parameters, the value of the **IotId** parameter takes precedence.
        self.iot_id = iot_id
        # The ID of the instance. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.
        # >*   If no **Overview** page or ID is generated for your instance, you do not need to configure this parameter.
        # 
        # For more information, see [Instance overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The ProductKey of the product to which the device belongs.
        # 
        # >  If you specify a value for this parameter, you must also specify a value for the **DeviceName** parameter.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class ResetThingResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        job_id: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the device job.
        self.job_id = job_id
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful. Valid values: **true** indicates that the call was successful. **false** indicates that the call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ResetThingResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ResetThingResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ResetThingResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RetrySoundCodeLabelBatchRequest(TeaModel):
    def __init__(
        self,
        batch_code: str = None,
        iot_instance_id: str = None,
    ):
        self.batch_code = batch_code
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.batch_code is not None:
            result['BatchCode'] = self.batch_code
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BatchCode') is not None:
            self.batch_code = m.get('BatchCode')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class RetrySoundCodeLabelBatchResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class RetrySoundCodeLabelBatchResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RetrySoundCodeLabelBatchResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RetrySoundCodeLabelBatchResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ReupgradeOTATaskRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        job_id: str = None,
        task_id: List[str] = None,
    ):
        # The ID of the instance. You can view the ID of an instance on the **Overview** page in the IoT Platform console.****\
        # 
        # >*   If the instance has an ID, you must specify the **IotInstanceId** parameter. If you do not specify this parameter, the call fails.
        # >*   If the instance does not have an **ID** or no **Overview** page is displayed for the instance, you do not need to specify this parameter.
        # 
        # For more information, see [Instance overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The ID of the update batch.
        # 
        # After you call the [CreateOTAStaticUpgradeJob](~~147496~~) or [CreateOTADynamicUpgradeJob](~~147887~~) operation to create an update batch, the **JobId** parameter is returned.
        # 
        # You can also view the **batch ID** on the **Firmware Details** page in the IoT Platform console.
        self.job_id = job_id
        self.task_id = task_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class ReupgradeOTATaskResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails.
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call is successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ReupgradeOTATaskResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ReupgradeOTATaskResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ReupgradeOTATaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SaveDevicePropRequest(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        iot_id: str = None,
        iot_instance_id: str = None,
        product_key: str = None,
        props: str = None,
    ):
        # The DeviceName of the device.
        # 
        # >  If you specify this parameter, you must also specify the **ProductKey** parameter.
        self.device_name = device_name
        # The ID of the device. The ID is a unique identifier that is issued by IoT Platform to the device.
        # 
        # >  If you specify this parameter, you do not need to specify the **ProductKey** or **DeviceName** parameters. The **IotId** parameter specifies a globally unique identifier (GUID) for the device. The value of the IotId parameter corresponds to a combination of the values of the **ProductKey** and **DeviceName** parameters. If you specify the **IotId**, **ProductKey**, and **DeviceName** parameters, the value of the **IotId** parameter takes precedence.
        self.iot_id = iot_id
        # The ID of the instance. On the **Overview** page in the IoT Platform console, you can view the **ID** of the instance.
        # 
        # 
        # **Important**\
        # 
        # *   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.
        # *   If the **Overview** page or instance ID is not displayed in the IoT Platform console, you do not need to configure this parameter.
        # 
        # For more information about the instance, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The ProductKey of the product to which the device belongs.
        # 
        # >  If you specify this parameter, you must also specify the **DeviceName** parameter.
        self.product_key = product_key
        # The tag that you want to specify for the device. You can specify multiple tags.
        # 
        # The tags must be JSON data in the **Key:Value** format. **Key** indicates the tag name, and **Value** indicates the tag value.
        # 
        # Separate multiple tags with commas (,). Example: **Props={"color":"red","shape":"round"}**\
        # 
        # 
        # **Important**\
        # 
        # *   The maximum size of the **Props** parameter is 5 KB.
        # *   `abc` is a **key** that is reserved by IoT Platform. You cannot set **Key** to abc. If you set `Key` to abc, the abc tag is automatically filtered when you query tags.
        self.props = props

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.props is not None:
            result['Props'] = self.props
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('Props') is not None:
            self.props = m.get('Props')
        return self


class SaveDevicePropResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information about error codes, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SaveDevicePropResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SaveDevicePropResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SaveDevicePropResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SaveScriptRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        parser_id: int = None,
        script_draft: str = None,
    ):
        self.iot_instance_id = iot_instance_id
        self.parser_id = parser_id
        self.script_draft = script_draft

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.parser_id is not None:
            result['ParserId'] = self.parser_id
        if self.script_draft is not None:
            result['ScriptDraft'] = self.script_draft
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ParserId') is not None:
            self.parser_id = m.get('ParserId')
        if m.get('ScriptDraft') is not None:
            self.script_draft = m.get('ScriptDraft')
        return self


class SaveScriptResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SaveScriptResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SaveScriptResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SaveScriptResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetDeviceDesiredPropertyRequest(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        iot_id: str = None,
        iot_instance_id: str = None,
        items: str = None,
        product_key: str = None,
        versions: str = None,
    ):
        # The name of the device.
        # 
        # > If you specify a value for this parameter, you must also specify a value for the **ProductKey** parameter.
        self.device_name = device_name
        # The ID of the device. The ID is a unique identifier that is issued by IoT Platform to the device.
        # 
        # > The IotId parameter specifies a globally unique identifier (GUID) for the device. The value of the **IotId** parameter corresponds to a combination of the values of the **ProductKey** and **DeviceName** parameters. If you specify a value for this parameter, you do not need to specify the **ProductKey** or **DeviceName** parameters. If you specify values for the **IotId**, **ProductKey**, and **DeviceName** parameters, the value of the **IotId** parameter takes precedence.
        self.iot_id = iot_id
        # The ID of the instance. You can view the ID of the instance on the **Overview** page in the IoT Platform console.****\
        # 
        # >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.****\
        # >*   If no **Overview** page or **ID** is generated for your instance, you do not need to configure this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The property value that you want to specify. The value of this parameter is a JSON string. Format: **Key:Value**. Example: {"Temperature":35}. You can specify up to 10 desired property values.
        # 
        # *   **Key** specifies the identifier of the property. You can view the property identifier on the **Define Feature**[ tab of the Product Details page in the IoT Platform console. You can also call the ](~~150321~~)QueryThingModel operation and view the property identifier in the returned TSL data.
        # 
        #     If the temperature property belongs to a custom module named testFb, this parameter is set to **{"testFb:temperature":35}**.
        # 
        # >The specified property must allow read/write access. If you specify a read-only property, the setting fails. The property identifier must be unique.
        # 
        # *   **Value** specifies the desired value of the property. The value must match the data type and value range that are defined for the property.
        # 
        # > If you set Value to null, the desired value of the property is cleared.
        self.items = items
        # The ProductKey of the product to which the device belongs.
        # 
        # > If you configure this parameter, you must also specify a value for the **DeviceName** parameter.
        self.product_key = product_key
        # The version number of the desired property value. The value of this parameter is a JSON string. Format: Key:Value. Example: {"Temperature":2}.
        # 
        # *   **Key** specifies the identifier of the property. You can view the property identifier on the Define Feature tab of the Product Details page in the IoT Platform console.
        # 
        # > The property identifier must be unique.
        # 
        # *   **Value** specifies the version number of the desired property value.
        # 
        #     The first time you specify a desired property value, set the Value parameter to 0. After you set the property value, the version number changes to 1. Each time you specify a desired property value, IoT Platform automatically increases the version number by 1. The second time that you specify a desired property value, the version number changes to 2. The third time that you specify a desired property value, set the version number to 2. After you specify the desired property value, the version number changes to 3.
        # 
        # > If the version number that you specify for this parameter is not the current version number, the server rejects the request. If you are not sure about the current version number, you do not need to specify a version number. However, you must enter a valid JSON object {}.
        self.versions = versions

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.items is not None:
            result['Items'] = self.items
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.versions is not None:
            result['Versions'] = self.versions
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('Items') is not None:
            self.items = m.get('Items')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('Versions') is not None:
            self.versions = m.get('Versions')
        return self


class SetDeviceDesiredPropertyResponseBodyData(TeaModel):
    def __init__(
        self,
        message_id: str = None,
        versions: str = None,
    ):
        # The ID of the message that IoT Platform sends to the device to specify desired property values.
        self.message_id = message_id
        # The current version numbers of the desired property values.
        self.versions = versions

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.message_id is not None:
            result['MessageId'] = self.message_id
        if self.versions is not None:
            result['Versions'] = self.versions
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MessageId') is not None:
            self.message_id = m.get('MessageId')
        if m.get('Versions') is not None:
            self.versions = m.get('Versions')
        return self


class SetDeviceDesiredPropertyResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: SetDeviceDesiredPropertyResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The data returned if the call is successful. For more information, see the following parameters.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful. Valid values:
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = SetDeviceDesiredPropertyResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SetDeviceDesiredPropertyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SetDeviceDesiredPropertyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetDeviceDesiredPropertyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetDeviceGroupTagsRequest(TeaModel):
    def __init__(
        self,
        group_id: str = None,
        group_type: str = None,
        iot_instance_id: str = None,
        tag_string: str = None,
    ):
        # The ID of the group. The ID is the globally unique identifier (GUID) for the group.
        self.group_id = group_id
        # The type of the group.
        # 
        # You do not need to configure this parameter.
        self.group_type = group_type
        # The ID of the instance. On the **Overview** page in the IoT Platform console, you can view the **ID** of the instance.
        # 
        # 
        # >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.
        # >*   If the **Overview** page or instance ID is not displayed in the IoT Platform console, you do not need to configure this parameter.
        # 
        # For more information about the instance, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The tag data in the JSON format. The TagString parameter specifies multiple tags in the format of key-value pairs. You must specify **tagKey** and **tagValue** for each tag.
        # 
        # *   **tagKey**: the tag key. The key must be 2 to 30 characters in length, and can contain letters, digits, and periods (.).
        # *   **tagValue**: the tag value. Each value can contain letters, digits, underscores (\_), and hyphens (-). The value must be 1 to 128 characters in length.
        # 
        # Separate multiple tags with commas (,). Example: `[{"tagKey":"h1","tagValue":"rr"},{"tagKey":"7h","tagValue":"rr"}]`
        # 
        # If you specify a new value for an existing tag, the new tag value overwrites the original value.
        # 
        # If you want to delete a tag, you do not need to specify the key and value for the tag.
        # 
        # **\
        # 
        # **Important** `abc` is a key that is reserved by IoT Platform. You cannot set **tagKey** to abc. If you set `tagKey` to abc, the abc tag is automatically filtered when you query tags.
        self.tag_string = tag_string

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_type is not None:
            result['GroupType'] = self.group_type
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.tag_string is not None:
            result['TagString'] = self.tag_string
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupType') is not None:
            self.group_type = m.get('GroupType')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('TagString') is not None:
            self.tag_string = m.get('TagString')
        return self


class SetDeviceGroupTagsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information about the error codes, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful. Valid values:
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SetDeviceGroupTagsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SetDeviceGroupTagsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetDeviceGroupTagsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetDevicePropertyRequest(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        iot_id: str = None,
        iot_instance_id: str = None,
        items: str = None,
        product_key: str = None,
        qos: int = None,
    ):
        # The DeviceName of the device.
        # 
        # > If you configure this parameter, you must specify a value for the **ProductKey** parameter.
        self.device_name = device_name
        # The ID of the device. The ID is a unique identifier that is issued by IoT Platform to the device.
        # 
        # > The IotId parameter specifies a globally unique identifier (GUID) for the device. The value of the **IotId** parameter corresponds to a combination of the values of the **ProductKey** and **DeviceName** parameters. If you specify a value for this parameter, you do not need to configure the **ProductKey** or **DeviceName** parameter. If you specify values for the **IotId**, **ProductKey**, and **DeviceName** parameters, the value of the **IotId** parameter takes precedence.
        self.iot_id = iot_id
        # The ID of the elastic container instance. You can view the ID of the instance on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.****\
        # >*   If no **Overview** page or **ID** is generated for your instance, you do not need to configure this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The properties that you want to specify. The properties must be in the JSON format.
        # 
        # Each property consists of a **key-value pair in the key:value format**. Separate multiple properties with commas (,).
        # 
        # For example, you can configure the following properties for a smart lamp:
        # 
        # *   A switch property whose key is **Switch** and whose data type is **BOOLEAN**. The value is **1**. The value 1 indicates that the light is on.
        # *   A color property whose key is **Color** and whose data type is **STRING**. The value is **blue**.
        # 
        # In this case, you can specify the following properties in the JSON format:
        # 
        # `Items={"Switch":1,"Color":"blue"}`
        # 
        # >  If you specify properties for the custom module testFb, set the Items parameter to `{"testFb:Switch":1,"testFb:Color":"blue"}`. The testFb module is not the default module.
        self.items = items
        # The ProductKey of the product to which the device belongs.
        # 
        # > If you configure this parameter, you must also specify a value for the **DeviceName** parameter.
        self.product_key = product_key
        self.qos = qos

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.items is not None:
            result['Items'] = self.items
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.qos is not None:
            result['Qos'] = self.qos
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('Items') is not None:
            self.items = m.get('Items')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('Qos') is not None:
            self.qos = m.get('Qos')
        return self


class SetDevicePropertyResponseBodyData(TeaModel):
    def __init__(
        self,
        message_id: str = None,
    ):
        # The ID of the message that IoT Platform sends to the device.
        self.message_id = message_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.message_id is not None:
            result['MessageId'] = self.message_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('MessageId') is not None:
            self.message_id = m.get('MessageId')
        return self


class SetDevicePropertyResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: SetDevicePropertyResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The data returned if the call is successful.
        self.data = data
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = SetDevicePropertyResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SetDevicePropertyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SetDevicePropertyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetDevicePropertyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetDevicesPropertyRequest(TeaModel):
    def __init__(
        self,
        device_name: List[str] = None,
        iot_instance_id: str = None,
        items: str = None,
        product_key: str = None,
        qos: int = None,
    ):
        self.device_name = device_name
        # The ID of the instance. You can view the ID of the instance on the **Overview** page in the IoT Platform console.****\
        # 
        # >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.****\
        # >*   If no **Overview** page or **ID** is generated for your instance, you do not need to configure this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The properties that you want to specify. The properties must be in the JSON format.
        # 
        # Each property consists of a **key-value pair in the key:value format**. Separate multiple properties with commas (,).
        # 
        # For example, you can configure the following properties for a smart lamp:
        # 
        # *   A switch property whose key is **Switch** and whose data type is **BOOLEAN**. The value is **1**. The value 1 indicates that the light is on.
        # *   A color property whose key is **Color** and whose data type is **STRING**. The value is **blue**.
        # 
        # In this case, you can specify the following properties in the JSON format:
        # 
        # `Items={"Switch":1,"Color":"blue"}`
        # 
        # >  If you configure properties for the custom module testFb, set the Items parameter to `{"testFb:Switch":1,"testFb:Color":"blue"}`. The testFb module is not the default module.
        self.items = items
        # The **ProductKey** of the product to which the device belongs.
        self.product_key = product_key
        self.qos = qos

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.items is not None:
            result['Items'] = self.items
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.qos is not None:
            result['Qos'] = self.qos
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('Items') is not None:
            self.items = m.get('Items')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('Qos') is not None:
            self.qos = m.get('Qos')
        return self


class SetDevicesPropertyResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information about the error codes, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SetDevicesPropertyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SetDevicesPropertyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetDevicesPropertyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetEdgeInstanceDriverConfigsRequestConfigs(TeaModel):
    def __init__(
        self,
        content: str = None,
        format: str = None,
        key: str = None,
    ):
        self.content = content
        self.format = format
        self.key = key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.format is not None:
            result['Format'] = self.format
        if self.key is not None:
            result['Key'] = self.key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('Format') is not None:
            self.format = m.get('Format')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        return self


class SetEdgeInstanceDriverConfigsRequest(TeaModel):
    def __init__(
        self,
        configs: List[SetEdgeInstanceDriverConfigsRequestConfigs] = None,
        driver_id: str = None,
        instance_id: str = None,
        iot_instance_id: str = None,
    ):
        self.configs = configs
        self.driver_id = driver_id
        self.instance_id = instance_id
        self.iot_instance_id = iot_instance_id

    def validate(self):
        if self.configs:
            for k in self.configs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Configs'] = []
        if self.configs is not None:
            for k in self.configs:
                result['Configs'].append(k.to_map() if k else None)
        if self.driver_id is not None:
            result['DriverId'] = self.driver_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.configs = []
        if m.get('Configs') is not None:
            for k in m.get('Configs'):
                temp_model = SetEdgeInstanceDriverConfigsRequestConfigs()
                self.configs.append(temp_model.from_map(k))
        if m.get('DriverId') is not None:
            self.driver_id = m.get('DriverId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class SetEdgeInstanceDriverConfigsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SetEdgeInstanceDriverConfigsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SetEdgeInstanceDriverConfigsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetEdgeInstanceDriverConfigsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetProductCertInfoRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        issue_model: int = None,
        product_key: str = None,
    ):
        # The ID of the instance. You can view the ID of the instance on the **Overview** page in the IoT Platform console.****\
        # 
        # >  If your instance has an ID, you must specify the ID for the parameter. Otherwise, the call fails. If no Overview page or ID is generated for your instance, you do not need configure this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The source from which the X.509 certificate is issued.
        # 
        # *   **1**: The X.509 certificate is issued by IoT Platform.
        # *   **3**: The X.509 certificate is issued by a third-party platform.
        self.issue_model = issue_model
        # The **ProductKey** of the product.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.issue_model is not None:
            result['IssueModel'] = self.issue_model
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('IssueModel') is not None:
            self.issue_model = m.get('IssueModel')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class SetProductCertInfoResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful. Valid values:
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SetProductCertInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SetProductCertInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetProductCertInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetStudioProjectCooperationRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        status: str = None,
    ):
        self.iot_instance_id = iot_instance_id
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class SetStudioProjectCooperationResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: bool = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SetStudioProjectCooperationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SetStudioProjectCooperationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetStudioProjectCooperationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetupStudioAppAuthModeOpenRequest(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        auth_mode: int = None,
        iot_instance_id: str = None,
        project_id: str = None,
    ):
        self.app_id = app_id
        self.auth_mode = auth_mode
        self.iot_instance_id = iot_instance_id
        self.project_id = project_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.auth_mode is not None:
            result['AuthMode'] = self.auth_mode
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AuthMode') is not None:
            self.auth_mode = m.get('AuthMode')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class SetupStudioAppAuthModeOpenResponseBodyDataTokenInfo(TeaModel):
    def __init__(
        self,
        biz_id: str = None,
        biz_type: str = None,
        is_enable: str = None,
        token: str = None,
        type: str = None,
    ):
        self.biz_id = biz_id
        self.biz_type = biz_type
        self.is_enable = is_enable
        self.token = token
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_id is not None:
            result['BizId'] = self.biz_id
        if self.biz_type is not None:
            result['BizType'] = self.biz_type
        if self.is_enable is not None:
            result['IsEnable'] = self.is_enable
        if self.token is not None:
            result['Token'] = self.token
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BizId') is not None:
            self.biz_id = m.get('BizId')
        if m.get('BizType') is not None:
            self.biz_type = m.get('BizType')
        if m.get('IsEnable') is not None:
            self.is_enable = m.get('IsEnable')
        if m.get('Token') is not None:
            self.token = m.get('Token')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SetupStudioAppAuthModeOpenResponseBodyData(TeaModel):
    def __init__(
        self,
        auth_mode: int = None,
        token_info: SetupStudioAppAuthModeOpenResponseBodyDataTokenInfo = None,
    ):
        self.auth_mode = auth_mode
        self.token_info = token_info

    def validate(self):
        if self.token_info:
            self.token_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_mode is not None:
            result['AuthMode'] = self.auth_mode
        if self.token_info is not None:
            result['TokenInfo'] = self.token_info.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AuthMode') is not None:
            self.auth_mode = m.get('AuthMode')
        if m.get('TokenInfo') is not None:
            temp_model = SetupStudioAppAuthModeOpenResponseBodyDataTokenInfo()
            self.token_info = temp_model.from_map(m['TokenInfo'])
        return self


class SetupStudioAppAuthModeOpenResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: SetupStudioAppAuthModeOpenResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = SetupStudioAppAuthModeOpenResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SetupStudioAppAuthModeOpenResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SetupStudioAppAuthModeOpenResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetupStudioAppAuthModeOpenResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ShareSpeechByCombinationRequest(TeaModel):
    def __init__(
        self,
        audio_format: str = None,
        combination_list: List[str] = None,
        device_name: str = None,
        iot_id: str = None,
        iot_instance_id: str = None,
        product_key: str = None,
        speech_id: str = None,
    ):
        # The audio format. Valid values: **wav**, **mp3**, and **amr**.
        self.audio_format = audio_format
        # The combined content that you want to broadcast. The following types of content can be broadcasted:
        # 
        # *   The speeches that are pushed to the device. You must specify the identifiers of the speeches.
        # 
        # *   The custom content that you specify based on the supported format of the device.
        # 
        #     For example, you can create a custom speech about the amount of money in the format of `{$xxx}`. xxx is the specific amount. If you specify `{$1000}`, the device broadcasts **CNY 1000**.
        # 
        # The device broadcasts the audio files in the sequence of the values that you specify in CombinationList.
        self.combination_list = combination_list
        # The **DeviceName** of the device. If you specify this parameter, you must also specify the **ProductKey** parameter.
        self.device_name = device_name
        # The ID of the device. You can call the [QuerySpeechDevice](~~280408~~) operation to obtain the ID.
        # 
        # > If you specify this parameter, you do not need to specify the **ProductKey** and **DeviceName** parameters. **IotId** specifies a globally unique identifier (GUID) of the device, which corresponds to a combination of **ProductKey** and **DeviceName**. If you specify the **IotId**, **ProductKey**, and **DeviceName** parameters, the value of the **IotId** parameter takes precedence.
        self.iot_id = iot_id
        # The instance ID. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
        # 
        # >  If your instance has an ID, you must specify this parameter. Otherwise, the request fails. If no Overview page exists or no instance ID is displayed, you do not need to specify this parameter.
        # 
        # For more information, see the [Overview](~~356505~~) topic of IoT instances.
        self.iot_instance_id = iot_instance_id
        # The **ProductKey** of the product to which the device belongs. If you specify this parameter, you must also specify the **DeviceName** parameter.
        self.product_key = product_key
        # The unique ID of the combined speech that you want to broadcast. This ID is issued by IoT Platform to the device.
        # 
        # >  If you do not specify this parameter, IoT Platform automatically generates an ID. If you need to retry broadcasting the speech, you must specify the ID to prevent repeated broadcasting.
        self.speech_id = speech_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_format is not None:
            result['AudioFormat'] = self.audio_format
        if self.combination_list is not None:
            result['CombinationList'] = self.combination_list
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.speech_id is not None:
            result['SpeechId'] = self.speech_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioFormat') is not None:
            self.audio_format = m.get('AudioFormat')
        if m.get('CombinationList') is not None:
            self.combination_list = m.get('CombinationList')
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('SpeechId') is not None:
            self.speech_id = m.get('SpeechId')
        return self


class ShareSpeechByCombinationResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the request fails.
        self.error_message = error_message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ShareSpeechByCombinationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ShareSpeechByCombinationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ShareSpeechByCombinationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SpeechByCombinationRequest(TeaModel):
    def __init__(
        self,
        audio_format: str = None,
        combination_list: List[str] = None,
        device_name: str = None,
        enforce_flag: bool = None,
        iot_id: str = None,
        iot_instance_id: str = None,
        product_key: str = None,
        speech_id: str = None,
    ):
        self.audio_format = audio_format
        self.combination_list = combination_list
        self.device_name = device_name
        self.enforce_flag = enforce_flag
        self.iot_id = iot_id
        self.iot_instance_id = iot_instance_id
        self.product_key = product_key
        self.speech_id = speech_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_format is not None:
            result['AudioFormat'] = self.audio_format
        if self.combination_list is not None:
            result['CombinationList'] = self.combination_list
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.enforce_flag is not None:
            result['EnforceFlag'] = self.enforce_flag
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.speech_id is not None:
            result['SpeechId'] = self.speech_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioFormat') is not None:
            self.audio_format = m.get('AudioFormat')
        if m.get('CombinationList') is not None:
            self.combination_list = m.get('CombinationList')
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('EnforceFlag') is not None:
            self.enforce_flag = m.get('EnforceFlag')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('SpeechId') is not None:
            self.speech_id = m.get('SpeechId')
        return self


class SpeechByCombinationResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SpeechByCombinationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SpeechByCombinationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SpeechByCombinationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SpeechBySynthesisRequest(TeaModel):
    def __init__(
        self,
        audio_format: str = None,
        device_name: str = None,
        iot_id: str = None,
        iot_instance_id: str = None,
        product_key: str = None,
        speech_id: str = None,
        speech_rate: int = None,
        text: str = None,
        voice: str = None,
        volume: int = None,
    ):
        self.audio_format = audio_format
        self.device_name = device_name
        self.iot_id = iot_id
        self.iot_instance_id = iot_instance_id
        self.product_key = product_key
        self.speech_id = speech_id
        self.speech_rate = speech_rate
        self.text = text
        self.voice = voice
        self.volume = volume

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_format is not None:
            result['AudioFormat'] = self.audio_format
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.speech_id is not None:
            result['SpeechId'] = self.speech_id
        if self.speech_rate is not None:
            result['SpeechRate'] = self.speech_rate
        if self.text is not None:
            result['Text'] = self.text
        if self.voice is not None:
            result['Voice'] = self.voice
        if self.volume is not None:
            result['Volume'] = self.volume
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioFormat') is not None:
            self.audio_format = m.get('AudioFormat')
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('SpeechId') is not None:
            self.speech_id = m.get('SpeechId')
        if m.get('SpeechRate') is not None:
            self.speech_rate = m.get('SpeechRate')
        if m.get('Text') is not None:
            self.text = m.get('Text')
        if m.get('Voice') is not None:
            self.voice = m.get('Voice')
        if m.get('Volume') is not None:
            self.volume = m.get('Volume')
        return self


class SpeechBySynthesisResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SpeechBySynthesisResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SpeechBySynthesisResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SpeechBySynthesisResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartPTDetectionRequest(TeaModel):
    def __init__(
        self,
        algorithm_instance_uid: str = None,
        data: str = None,
        data_collection_time: int = None,
        file_name: str = None,
        iot_instance_id: str = None,
        power_plants_number: int = None,
        power_station_uid: str = None,
        sensitivity: int = None,
    ):
        self.algorithm_instance_uid = algorithm_instance_uid
        self.data = data
        self.data_collection_time = data_collection_time
        self.file_name = file_name
        self.iot_instance_id = iot_instance_id
        self.power_plants_number = power_plants_number
        self.power_station_uid = power_station_uid
        self.sensitivity = sensitivity

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.algorithm_instance_uid is not None:
            result['AlgorithmInstanceUid'] = self.algorithm_instance_uid
        if self.data is not None:
            result['Data'] = self.data
        if self.data_collection_time is not None:
            result['DataCollectionTime'] = self.data_collection_time
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.power_plants_number is not None:
            result['PowerPlantsNumber'] = self.power_plants_number
        if self.power_station_uid is not None:
            result['PowerStationUid'] = self.power_station_uid
        if self.sensitivity is not None:
            result['Sensitivity'] = self.sensitivity
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AlgorithmInstanceUid') is not None:
            self.algorithm_instance_uid = m.get('AlgorithmInstanceUid')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('DataCollectionTime') is not None:
            self.data_collection_time = m.get('DataCollectionTime')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('PowerPlantsNumber') is not None:
            self.power_plants_number = m.get('PowerPlantsNumber')
        if m.get('PowerStationUid') is not None:
            self.power_station_uid = m.get('PowerStationUid')
        if m.get('Sensitivity') is not None:
            self.sensitivity = m.get('Sensitivity')
        return self


class StartPTDetectionResponseBodyData(TeaModel):
    def __init__(
        self,
        data: str = None,
        err_msg: str = None,
        input_data: str = None,
        status: str = None,
        success: bool = None,
    ):
        self.data = data
        self.err_msg = err_msg
        self.input_data = input_data
        self.status = status
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.err_msg is not None:
            result['ErrMsg'] = self.err_msg
        if self.input_data is not None:
            result['InputData'] = self.input_data
        if self.status is not None:
            result['Status'] = self.status
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrMsg') is not None:
            self.err_msg = m.get('ErrMsg')
        if m.get('InputData') is not None:
            self.input_data = m.get('InputData')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class StartPTDetectionResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: StartPTDetectionResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = StartPTDetectionResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class StartPTDetectionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StartPTDetectionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartPTDetectionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartParserRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        parser_id: int = None,
    ):
        self.iot_instance_id = iot_instance_id
        self.parser_id = parser_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.parser_id is not None:
            result['ParserId'] = self.parser_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ParserId') is not None:
            self.parser_id = m.get('ParserId')
        return self


class StartParserResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class StartParserResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StartParserResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartParserResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartRuleRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        rule_id: int = None,
    ):
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The ID of the rule that you want to enable. You can log on to the IoT Platform console and choose **Rules** > **Data Forwarding** to view the rule ID. You can also call the [ListRule](~~69486~~) operation and view the rule ID in the response.
        self.rule_id = rule_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        return self


class StartRuleResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class StartRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StartRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StopParserRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        parser_id: int = None,
    ):
        self.iot_instance_id = iot_instance_id
        self.parser_id = parser_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.parser_id is not None:
            result['ParserId'] = self.parser_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ParserId') is not None:
            self.parser_id = m.get('ParserId')
        return self


class StopParserResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class StopParserResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StopParserResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StopParserResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StopRuleRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        rule_id: int = None,
    ):
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The ID of the rule that you want to disable. You can log on to the IoT Platform console and choose **Rules** > **Data Forwarding** to view the rule ID. You can also call the [ListRule](~~69486~~) operation and view the rule ID in the response.
        self.rule_id = rule_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        return self


class StopRuleResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class StopRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StopRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StopRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubscribeTopicRequest(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        iot_instance_id: str = None,
        product_key: str = None,
        topic: List[str] = None,
    ):
        # The **DeviceName** of the device to which the topic belongs.
        self.device_name = device_name
        # The ID of the instance. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.
        # >*   If no **Overview** page or ID is generated for your instance, you do not need to configure this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The **ProductKey** of the product to which the device belongs.
        self.product_key = product_key
        self.topic = topic

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.topic is not None:
            result['Topic'] = self.topic
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('Topic') is not None:
            self.topic = m.get('Topic')
        return self


class SubscribeTopicResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the request fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SubscribeTopicResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SubscribeTopicResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubscribeTopicResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SyncSpeechByCombinationRequest(TeaModel):
    def __init__(
        self,
        audio_format: str = None,
        combination_list: List[str] = None,
        device_name: str = None,
        enforce_flag: bool = None,
        iot_id: str = None,
        iot_instance_id: str = None,
        product_key: str = None,
        speech_id: str = None,
    ):
        self.audio_format = audio_format
        self.combination_list = combination_list
        self.device_name = device_name
        self.enforce_flag = enforce_flag
        self.iot_id = iot_id
        self.iot_instance_id = iot_instance_id
        self.product_key = product_key
        self.speech_id = speech_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_format is not None:
            result['AudioFormat'] = self.audio_format
        if self.combination_list is not None:
            result['CombinationList'] = self.combination_list
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.enforce_flag is not None:
            result['EnforceFlag'] = self.enforce_flag
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.speech_id is not None:
            result['SpeechId'] = self.speech_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioFormat') is not None:
            self.audio_format = m.get('AudioFormat')
        if m.get('CombinationList') is not None:
            self.combination_list = m.get('CombinationList')
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('EnforceFlag') is not None:
            self.enforce_flag = m.get('EnforceFlag')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('SpeechId') is not None:
            self.speech_id = m.get('SpeechId')
        return self


class SyncSpeechByCombinationResponseBodyData(TeaModel):
    def __init__(
        self,
        detail: str = None,
        device_error_code: str = None,
        device_error_message: str = None,
        id: str = None,
        max_retry_count: int = None,
        retry_count: int = None,
        success: bool = None,
    ):
        self.detail = detail
        self.device_error_code = device_error_code
        self.device_error_message = device_error_message
        self.id = id
        self.max_retry_count = max_retry_count
        self.retry_count = retry_count
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.detail is not None:
            result['Detail'] = self.detail
        if self.device_error_code is not None:
            result['DeviceErrorCode'] = self.device_error_code
        if self.device_error_message is not None:
            result['DeviceErrorMessage'] = self.device_error_message
        if self.id is not None:
            result['Id'] = self.id
        if self.max_retry_count is not None:
            result['MaxRetryCount'] = self.max_retry_count
        if self.retry_count is not None:
            result['RetryCount'] = self.retry_count
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Detail') is not None:
            self.detail = m.get('Detail')
        if m.get('DeviceErrorCode') is not None:
            self.device_error_code = m.get('DeviceErrorCode')
        if m.get('DeviceErrorMessage') is not None:
            self.device_error_message = m.get('DeviceErrorMessage')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('MaxRetryCount') is not None:
            self.max_retry_count = m.get('MaxRetryCount')
        if m.get('RetryCount') is not None:
            self.retry_count = m.get('RetryCount')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SyncSpeechByCombinationResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: SyncSpeechByCombinationResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = SyncSpeechByCombinationResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SyncSpeechByCombinationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SyncSpeechByCombinationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SyncSpeechByCombinationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class TestSpeechRequest(TeaModel):
    def __init__(
        self,
        audio_format: str = None,
        enable_sound_code: bool = None,
        iot_instance_id: str = None,
        project_code: str = None,
        sound_code_config: Dict[str, Any] = None,
        speech_rate: int = None,
        speech_type: str = None,
        text: str = None,
        voice: str = None,
        volume: int = None,
    ):
        self.audio_format = audio_format
        self.enable_sound_code = enable_sound_code
        self.iot_instance_id = iot_instance_id
        self.project_code = project_code
        self.sound_code_config = sound_code_config
        self.speech_rate = speech_rate
        self.speech_type = speech_type
        self.text = text
        self.voice = voice
        self.volume = volume

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_format is not None:
            result['AudioFormat'] = self.audio_format
        if self.enable_sound_code is not None:
            result['EnableSoundCode'] = self.enable_sound_code
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.project_code is not None:
            result['ProjectCode'] = self.project_code
        if self.sound_code_config is not None:
            result['SoundCodeConfig'] = self.sound_code_config
        if self.speech_rate is not None:
            result['SpeechRate'] = self.speech_rate
        if self.speech_type is not None:
            result['SpeechType'] = self.speech_type
        if self.text is not None:
            result['Text'] = self.text
        if self.voice is not None:
            result['Voice'] = self.voice
        if self.volume is not None:
            result['Volume'] = self.volume
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioFormat') is not None:
            self.audio_format = m.get('AudioFormat')
        if m.get('EnableSoundCode') is not None:
            self.enable_sound_code = m.get('EnableSoundCode')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProjectCode') is not None:
            self.project_code = m.get('ProjectCode')
        if m.get('SoundCodeConfig') is not None:
            self.sound_code_config = m.get('SoundCodeConfig')
        if m.get('SpeechRate') is not None:
            self.speech_rate = m.get('SpeechRate')
        if m.get('SpeechType') is not None:
            self.speech_type = m.get('SpeechType')
        if m.get('Text') is not None:
            self.text = m.get('Text')
        if m.get('Voice') is not None:
            self.voice = m.get('Voice')
        if m.get('Volume') is not None:
            self.volume = m.get('Volume')
        return self


class TestSpeechShrinkRequest(TeaModel):
    def __init__(
        self,
        audio_format: str = None,
        enable_sound_code: bool = None,
        iot_instance_id: str = None,
        project_code: str = None,
        sound_code_config_shrink: str = None,
        speech_rate: int = None,
        speech_type: str = None,
        text: str = None,
        voice: str = None,
        volume: int = None,
    ):
        self.audio_format = audio_format
        self.enable_sound_code = enable_sound_code
        self.iot_instance_id = iot_instance_id
        self.project_code = project_code
        self.sound_code_config_shrink = sound_code_config_shrink
        self.speech_rate = speech_rate
        self.speech_type = speech_type
        self.text = text
        self.voice = voice
        self.volume = volume

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_format is not None:
            result['AudioFormat'] = self.audio_format
        if self.enable_sound_code is not None:
            result['EnableSoundCode'] = self.enable_sound_code
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.project_code is not None:
            result['ProjectCode'] = self.project_code
        if self.sound_code_config_shrink is not None:
            result['SoundCodeConfig'] = self.sound_code_config_shrink
        if self.speech_rate is not None:
            result['SpeechRate'] = self.speech_rate
        if self.speech_type is not None:
            result['SpeechType'] = self.speech_type
        if self.text is not None:
            result['Text'] = self.text
        if self.voice is not None:
            result['Voice'] = self.voice
        if self.volume is not None:
            result['Volume'] = self.volume
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AudioFormat') is not None:
            self.audio_format = m.get('AudioFormat')
        if m.get('EnableSoundCode') is not None:
            self.enable_sound_code = m.get('EnableSoundCode')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProjectCode') is not None:
            self.project_code = m.get('ProjectCode')
        if m.get('SoundCodeConfig') is not None:
            self.sound_code_config_shrink = m.get('SoundCodeConfig')
        if m.get('SpeechRate') is not None:
            self.speech_rate = m.get('SpeechRate')
        if m.get('SpeechType') is not None:
            self.speech_type = m.get('SpeechType')
        if m.get('Text') is not None:
            self.text = m.get('Text')
        if m.get('Voice') is not None:
            self.voice = m.get('Voice')
        if m.get('Volume') is not None:
            self.volume = m.get('Volume')
        return self


class TestSpeechResponseBodyData(TeaModel):
    def __init__(
        self,
        items: List[str] = None,
    ):
        self.items = items

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.items is not None:
            result['items'] = self.items
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('items') is not None:
            self.items = m.get('items')
        return self


class TestSpeechResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: TestSpeechResponseBodyData = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = TestSpeechResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class TestSpeechResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: TestSpeechResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = TestSpeechResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class TestSwitchRequest(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        iot_instance_id: str = None,
        product_key: str = None,
    ):
        self.device_name = device_name
        self.iot_instance_id = iot_instance_id
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class TestSwitchResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        iot_id: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.iot_id = iot_id
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class TestSwitchResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: TestSwitchResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = TestSwitchResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class TransformClientIdRequest(TeaModel):
    def __init__(
        self,
        client_id: str = None,
        iot_id: str = None,
        iot_instance_id: str = None,
    ):
        # The ClientID of the device.
        self.client_id = client_id
        # The ID of the device.
        self.iot_id = iot_id
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_id is not None:
            result['ClientId'] = self.client_id
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ClientId') is not None:
            self.client_id = m.get('ClientId')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class TransformClientIdResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The response code. The value Success indicates that the call was successful. Other values indicate that errors occurred. For more information about error codes, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class TransformClientIdResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: TransformClientIdResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = TransformClientIdResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class TriggerSceneRuleRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        iot_instance_id: str = None,
        rule_id: str = None,
    ):
        self.instance_id = instance_id
        self.iot_instance_id = iot_instance_id
        self.rule_id = rule_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        return self


class TriggerSceneRuleResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class TriggerSceneRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: TriggerSceneRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = TriggerSceneRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UnbindApplicationFromEdgeInstanceRequest(TeaModel):
    def __init__(
        self,
        application_id: str = None,
        instance_id: str = None,
        iot_instance_id: str = None,
    ):
        self.application_id = application_id
        self.instance_id = instance_id
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.application_id is not None:
            result['ApplicationId'] = self.application_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ApplicationId') is not None:
            self.application_id = m.get('ApplicationId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class UnbindApplicationFromEdgeInstanceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UnbindApplicationFromEdgeInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UnbindApplicationFromEdgeInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UnbindApplicationFromEdgeInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UnbindDriverFromEdgeInstanceRequest(TeaModel):
    def __init__(
        self,
        driver_id: str = None,
        instance_id: str = None,
        iot_instance_id: str = None,
    ):
        # The ID of the driver that you want to unbind. To obtain the driver ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Drivers** page, move the pointer over the name of the driver that you want to unbind and obtain the driver ID.
        # 
        # You can also call the [QueryEdgeDriver](~~155776~~) operation to query the driver ID.
        self.driver_id = driver_id
        # The ID of the edge instance. To obtain the instance ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Edge Instances** page, move the pointer over the name of the edge instance from which you want to unbind a driver and obtain the instance ID.
        # 
        # You can also call the [QueryEdgeInstance](~~135214~~) operation to query the instance ID.
        self.instance_id = instance_id
        # The ID of the Internet of Things (IoT) service instance. This parameter is not required for the public instance but required for Enterprise Edition instances.
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.driver_id is not None:
            result['DriverId'] = self.driver_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DriverId') is not None:
            self.driver_id = m.get('DriverId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class UnbindDriverFromEdgeInstanceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The return code of the operation. A value of Success indicates that the call was successful. Other values indicate that specific errors occurred. For more information, see [Error codes](~~135200~~).
        self.code = code
        # The error message that is returned if the call failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful. A value of true indicates that the call was successful. A value of false indicates that the call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UnbindDriverFromEdgeInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UnbindDriverFromEdgeInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UnbindDriverFromEdgeInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UnbindLicenseProductRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        license_code: str = None,
        product_key: str = None,
    ):
        # The ID of the Enterprise Edition instance. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
        self.iot_instance_id = iot_instance_id
        # The license type that specifies the audio and video specifications. Valid values: **480P** and **720P**.
        # 
        # To view the license type of a product, choose **License Management > Product Authorization** in the **Real-time Communication Service** console.
        self.license_code = license_code
        # The ProductKey of the product from which you want to unbind the license.
        # 
        # You can choose **License Management > Product Authorization** in the **Real-Time Communication Service** console to view the **ProductKey** of the product.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.license_code is not None:
            result['LicenseCode'] = self.license_code
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('LicenseCode') is not None:
            self.license_code = m.get('LicenseCode')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class UnbindLicenseProductResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: bool = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request fails. For more information, see the **Error codes** section of this topic.
        self.code = code
        # Indicates whether the license was unbound from the product.
        # 
        # *   **true**\
        # *   **false**\
        self.data = data
        # The error message returned if the request fails.
        self.error_message = error_message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful.
        # 
        # *   **true**\
        # *   **false**\
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UnbindLicenseProductResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UnbindLicenseProductResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UnbindLicenseProductResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UnbindRoleFromEdgeInstanceRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        iot_instance_id: str = None,
    ):
        self.instance_id = instance_id
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class UnbindRoleFromEdgeInstanceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UnbindRoleFromEdgeInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UnbindRoleFromEdgeInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UnbindRoleFromEdgeInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UnbindSceneRuleFromEdgeInstanceRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        iot_instance_id: str = None,
        rule_id: str = None,
    ):
        self.instance_id = instance_id
        self.iot_instance_id = iot_instance_id
        self.rule_id = rule_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        return self


class UnbindSceneRuleFromEdgeInstanceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UnbindSceneRuleFromEdgeInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UnbindSceneRuleFromEdgeInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UnbindSceneRuleFromEdgeInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UnsubscribeTopicRequest(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        iot_instance_id: str = None,
        product_key: str = None,
        topic: List[str] = None,
    ):
        self.device_name = device_name
        self.iot_instance_id = iot_instance_id
        self.product_key = product_key
        self.topic = topic

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.topic is not None:
            result['Topic'] = self.topic
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('Topic') is not None:
            self.topic = m.get('Topic')
        return self


class UnsubscribeTopicResponseBodyFailureTopics(TeaModel):
    def __init__(
        self,
        topic: List[Dict[str, Any]] = None,
    ):
        self.topic = topic

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.topic is not None:
            result['topic'] = self.topic
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('topic') is not None:
            self.topic = m.get('topic')
        return self


class UnsubscribeTopicResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        failure_topics: UnsubscribeTopicResponseBodyFailureTopics = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.failure_topics = failure_topics
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.failure_topics:
            self.failure_topics.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.failure_topics is not None:
            result['FailureTopics'] = self.failure_topics.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('FailureTopics') is not None:
            temp_model = UnsubscribeTopicResponseBodyFailureTopics()
            self.failure_topics = temp_model.from_map(m['FailureTopics'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UnsubscribeTopicResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UnsubscribeTopicResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UnsubscribeTopicResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateConsumerGroupRequest(TeaModel):
    def __init__(
        self,
        group_id: str = None,
        iot_instance_id: str = None,
        new_group_name: str = None,
    ):
        # The consumer group ID. After you call the [CreateConsumerGroup](~~170388~~) operation to create a consumer group, the consumer group ID is returned. You can call the [QueryConsumerGroupList](~~170419~~) operation to query the consumer group ID by group name. You can also go to the IoT Platform console,and choose **Rules** > **Server-side Subscription** > **Consumer Groups** to view the consumer group ID.
        self.group_id = group_id
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The new name of the consumer group. The name must be 4 to 30 characters in length and can contain letters, digits, and underscores (\_).
        self.new_group_name = new_group_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.new_group_name is not None:
            result['NewGroupName'] = self.new_group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('NewGroupName') is not None:
            self.new_group_name = m.get('NewGroupName')
        return self


class UpdateConsumerGroupResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateConsumerGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateConsumerGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateConsumerGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateDestinationRequest(TeaModel):
    def __init__(
        self,
        configuration: str = None,
        description: str = None,
        destination_id: int = None,
        iot_instance_id: str = None,
        name: str = None,
        type: str = None,
    ):
        self.configuration = configuration
        self.description = description
        self.destination_id = destination_id
        self.iot_instance_id = iot_instance_id
        self.name = name
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.configuration is not None:
            result['Configuration'] = self.configuration
        if self.description is not None:
            result['Description'] = self.description
        if self.destination_id is not None:
            result['DestinationId'] = self.destination_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Configuration') is not None:
            self.configuration = m.get('Configuration')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DestinationId') is not None:
            self.destination_id = m.get('DestinationId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class UpdateDestinationResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateDestinationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateDestinationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateDestinationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateDeviceGroupRequest(TeaModel):
    def __init__(
        self,
        group_desc: str = None,
        group_id: str = None,
        group_type: str = None,
        iot_instance_id: str = None,
    ):
        # The description of the group. The description must be 1 to 100 characters in length.
        self.group_desc = group_desc
        # The ID of the group. The ID is the globally unique identifier (GUID) for the group.
        self.group_id = group_id
        # The type of the group.
        # 
        # If you set the value to **LINK_PLATFORM_DYNAMIC**, a dynamic group is queried. If you do not specify this parameter, a static group is queried by default.
        self.group_type = group_type
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_desc is not None:
            result['GroupDesc'] = self.group_desc
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_type is not None:
            result['GroupType'] = self.group_type
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('GroupDesc') is not None:
            self.group_desc = m.get('GroupDesc')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupType') is not None:
            self.group_type = m.get('GroupType')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class UpdateDeviceGroupResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateDeviceGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateDeviceGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateDeviceGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateDeviceShadowRequest(TeaModel):
    def __init__(
        self,
        delta_update: bool = None,
        device_name: str = None,
        iot_instance_id: str = None,
        product_key: str = None,
        shadow_message: str = None,
    ):
        # Specifies whether to perform an incremental update on the **desired** parameter. Valid values:
        # 
        # *   **true**: performs an incremental update.
        # *   **false**: performs a full update. This is the default value.
        self.delta_update = delta_update
        # The name of the device whose shadow information you want to modify.
        self.device_name = device_name
        # The ID of the elastic container instance. You can view the ID of the instance on the **Overview** page in the IoT Platform console.****\
        # 
        # >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.****\
        # >*   If no **Overview** page or **ID** is generated for your instance, you do not need to configure this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The ProductKey of the product to which the device belongs.
        self.product_key = product_key
        # The information that you want to specify for the device shadow.
        # 
        # The information includes the following parameters:
        # 
        # *   **method**: the type of the operation. Data type: string. Set the value to **update**.
        # 
        # *   **state**: the status of the device shadow. Data type: string. The **desired** parameter specifies the expected shadow status.
        # 
        # *   **version**: the version of the device shadow. Data type: long.
        # 
        #     *   If versioning is not required, set this parameter to 0.
        #     *   If versioning is required, specify a version that is later than the current version.
        # 
        # **\
        # 
        # **Important** If versioning is required, do not query the version of a device shadow in the IoT Platform console. If a large number of update and query operations are concurrently performed, multiple update operations may return the same version. In this case, the most recent update operation may first be completed. As a result, the current shadow information is not the latest shadow information. We recommend that you maintain the versions of device shadows on the on-premises device. When you call this operation, use an on-premises application to obtain the latest version of the device shadow.
        self.shadow_message = shadow_message

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.delta_update is not None:
            result['DeltaUpdate'] = self.delta_update
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.shadow_message is not None:
            result['ShadowMessage'] = self.shadow_message
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeltaUpdate') is not None:
            self.delta_update = m.get('DeltaUpdate')
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('ShadowMessage') is not None:
            self.shadow_message = m.get('ShadowMessage')
        return self


class UpdateDeviceShadowResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful. Valid values:
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateDeviceShadowResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateDeviceShadowResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateDeviceShadowResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateEdgeDriverVersionRequest(TeaModel):
    def __init__(
        self,
        argument: str = None,
        config_check_rule: str = None,
        container_config: str = None,
        description: str = None,
        driver_config: str = None,
        driver_id: str = None,
        driver_version: str = None,
        edge_version: str = None,
        iot_instance_id: str = None,
        source_config: str = None,
    ):
        # The Java Virtual Machine (JVM) startup parameter.
        self.argument = argument
        # The rule for verifying configurations. Set this parameter to a JSON string in the following format:
        # 
        # `{"deviceConfig":{"required":false},"driverConfig":{"required":false}`
        # 
        # The JSON string contains the following parameters:
        # 
        # *   driverConfig: the rule for verifying the configuration of the driver when the driver is to be deployed in an edge instance.
        # *   deviceConfig: the rule for verifying the configurations of devices that use the driver when the driver is to be deployed in an edge instance.
        # 
        # `required`: A value of true indicates that the corresponding parameter is required. A value of false indicates that the corresponding parameter is optional.
        self.config_check_rule = config_check_rule
        # The configuration of the container where the driver runs. Set this parameter to a JSON string. For more information about parameters in the JSON string, see the following parameter description of ContainerConfig.
        self.container_config = container_config
        # The description of the driver. The description can be a maximum of 256 bytes in length.
        self.description = description
        # The configuration of the driver. Set this parameter to a JSON string in the following format:
        # 
        # `{"format":"JSON","content":"{}"}`
        # 
        # The JSON string contains the following parameters:
        # 
        # *   format: the format of the driver configuration. Valid values: KV (key-value pair), JSON (JSON string), and FILE (configuration file).
        # 
        # *   content: the content of the driver configuration. If you set the format parameter to KV or JSON, set this parameter to the configuration content of the driver. If you set the format parameter to FILE, set this parameter to the URL of the driver configuration file stored in OSS.
        # 
        # >To obtain the URL of the driver configuration file stored in OSS, call the [CreateOssPreSignedAddress](~~155858~~) operation.
        self.driver_config = driver_config
        # The ID of the driver. To obtain the driver ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Drivers** page, move the pointer over the name of the driver for which you want to update a driver version and obtain the driver ID.
        # 
        # You can also call the [QueryEdgeDriver](~~155776~~) operation to query the driver ID.
        self.driver_id = driver_id
        # The version number of the driver.
        self.driver_version = driver_version
        # The earliest version of Link IoT Edge that is supported by the driver. The driver can run on gateways of only this version and later. For example, if you set this parameter to 2.4.0, the driver can run on gateways of only version 2.4.0 and later.
        self.edge_version = edge_version
        # The ID of the Internet of Things (IoT) service instance. This parameter is not required for the public instance but required for Enterprise Edition instances.
        self.iot_instance_id = iot_instance_id
        self.source_config = source_config

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.argument is not None:
            result['Argument'] = self.argument
        if self.config_check_rule is not None:
            result['ConfigCheckRule'] = self.config_check_rule
        if self.container_config is not None:
            result['ContainerConfig'] = self.container_config
        if self.description is not None:
            result['Description'] = self.description
        if self.driver_config is not None:
            result['DriverConfig'] = self.driver_config
        if self.driver_id is not None:
            result['DriverId'] = self.driver_id
        if self.driver_version is not None:
            result['DriverVersion'] = self.driver_version
        if self.edge_version is not None:
            result['EdgeVersion'] = self.edge_version
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.source_config is not None:
            result['SourceConfig'] = self.source_config
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Argument') is not None:
            self.argument = m.get('Argument')
        if m.get('ConfigCheckRule') is not None:
            self.config_check_rule = m.get('ConfigCheckRule')
        if m.get('ContainerConfig') is not None:
            self.container_config = m.get('ContainerConfig')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DriverConfig') is not None:
            self.driver_config = m.get('DriverConfig')
        if m.get('DriverId') is not None:
            self.driver_id = m.get('DriverId')
        if m.get('DriverVersion') is not None:
            self.driver_version = m.get('DriverVersion')
        if m.get('EdgeVersion') is not None:
            self.edge_version = m.get('EdgeVersion')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('SourceConfig') is not None:
            self.source_config = m.get('SourceConfig')
        return self


class UpdateEdgeDriverVersionResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The return code of the operation. A value of Success indicates that the call was successful. Other values indicate that specific errors occurred. For more information, see [Error codes](~~135200~~).
        self.code = code
        # The error message that is returned if the call failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful. A value of true indicates that the call was successful. A value of false indicates that the call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateEdgeDriverVersionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateEdgeDriverVersionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateEdgeDriverVersionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateEdgeInstanceRequest(TeaModel):
    def __init__(
        self,
        biz_enable: bool = None,
        instance_id: str = None,
        iot_instance_id: str = None,
        name: str = None,
        spec: int = None,
        tags: str = None,
    ):
        # Specifies whether to enable the edge instance. Valid values:
        # 
        # *   true: enables the edge instance.
        # *   false: disables the edge instance.
        # 
        # If you do not set this parameter, this parameter is not updated.
        self.biz_enable = biz_enable
        # The ID of the edge instance. To obtain the instance ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Edge Instances** page, move the pointer over the name of the edge instance that you want to update and obtain the instance ID.
        # 
        # You can also call the [QueryEdgeInstance](~~135214~~) operation to query the instance ID.
        self.instance_id = instance_id
        # The ID of the Internet of Things (IoT) service instance. This parameter is not required for the public instance but required for Enterprise Edition instances.
        self.iot_instance_id = iot_instance_id
        # The name of the edge instance.
        # 
        # The name can be up to 20 characters in length and can contain letters, digits, underscores (\_), and hyphens (-).
        self.name = name
        # The specifications of the edge instance. Valid values:
        # 
        # *   10: Lite Edition
        # *   20: Standard Edition
        # *   30: Pro Edition
        # 
        # If you do not set this parameter, this parameter is not updated.
        self.spec = spec
        # The tags of the edge instance. Each tag is a key-value pair. Multiple tags are separated with commas (,). Example: `k1:v1,k2:v2`.
        # 
        # *   Take note of the following limits on tag keys:
        # 
        #     *   Tag keys cannot be left empty.
        #     *   Tag keys must be unique in the edge instance.
        #     *   Tag keys support only letters.
        #     *   Each tag key can be up to 20 characters in length.
        # 
        # *   Take note of the following limits on tag values:
        # 
        #     *   Tag values cannot be left empty.
        #     *   A tag value can contain letters, digits, underscores (\_), and hyphens (-).
        #     *   Each tag value can be up to 20 characters in length.
        # 
        # If you do not set this parameter, this parameter is not updated.
        self.tags = tags

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_enable is not None:
            result['BizEnable'] = self.biz_enable
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.name is not None:
            result['Name'] = self.name
        if self.spec is not None:
            result['Spec'] = self.spec
        if self.tags is not None:
            result['Tags'] = self.tags
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('BizEnable') is not None:
            self.biz_enable = m.get('BizEnable')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Spec') is not None:
            self.spec = m.get('Spec')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        return self


class UpdateEdgeInstanceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The return code of the operation.
        self.code = code
        # The error message that is returned if the call failed.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful. A value of true indicates that the call was successful. A value of false indicates that the call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateEdgeInstanceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateEdgeInstanceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateEdgeInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateEdgeInstanceChannelRequestConfigs(TeaModel):
    def __init__(
        self,
        content: str = None,
        format: str = None,
        key: str = None,
    ):
        self.content = content
        self.format = format
        self.key = key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.format is not None:
            result['Format'] = self.format
        if self.key is not None:
            result['Key'] = self.key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('Format') is not None:
            self.format = m.get('Format')
        if m.get('Key') is not None:
            self.key = m.get('Key')
        return self


class UpdateEdgeInstanceChannelRequest(TeaModel):
    def __init__(
        self,
        channel_id: str = None,
        channel_name: str = None,
        configs: List[UpdateEdgeInstanceChannelRequestConfigs] = None,
        driver_id: str = None,
        instance_id: str = None,
        iot_instance_id: str = None,
    ):
        self.channel_id = channel_id
        self.channel_name = channel_name
        self.configs = configs
        self.driver_id = driver_id
        self.instance_id = instance_id
        self.iot_instance_id = iot_instance_id

    def validate(self):
        if self.configs:
            for k in self.configs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_id is not None:
            result['ChannelId'] = self.channel_id
        if self.channel_name is not None:
            result['ChannelName'] = self.channel_name
        result['Configs'] = []
        if self.configs is not None:
            for k in self.configs:
                result['Configs'].append(k.to_map() if k else None)
        if self.driver_id is not None:
            result['DriverId'] = self.driver_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ChannelId') is not None:
            self.channel_id = m.get('ChannelId')
        if m.get('ChannelName') is not None:
            self.channel_name = m.get('ChannelName')
        self.configs = []
        if m.get('Configs') is not None:
            for k in m.get('Configs'):
                temp_model = UpdateEdgeInstanceChannelRequestConfigs()
                self.configs.append(temp_model.from_map(k))
        if m.get('DriverId') is not None:
            self.driver_id = m.get('DriverId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        return self


class UpdateEdgeInstanceChannelResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateEdgeInstanceChannelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateEdgeInstanceChannelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateEdgeInstanceChannelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateEdgeInstanceMessageRoutingRequest(TeaModel):
    def __init__(
        self,
        instance_id: str = None,
        iot_instance_id: str = None,
        name: str = None,
        route_id: int = None,
        source_data: str = None,
        source_type: str = None,
        target_data: str = None,
        target_iot_hub_qos: int = None,
        target_type: str = None,
        topic_filter: str = None,
    ):
        self.instance_id = instance_id
        self.iot_instance_id = iot_instance_id
        self.name = name
        self.route_id = route_id
        self.source_data = source_data
        self.source_type = source_type
        self.target_data = target_data
        self.target_iot_hub_qos = target_iot_hub_qos
        self.target_type = target_type
        self.topic_filter = topic_filter

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.name is not None:
            result['Name'] = self.name
        if self.route_id is not None:
            result['RouteId'] = self.route_id
        if self.source_data is not None:
            result['SourceData'] = self.source_data
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        if self.target_data is not None:
            result['TargetData'] = self.target_data
        if self.target_iot_hub_qos is not None:
            result['TargetIotHubQos'] = self.target_iot_hub_qos
        if self.target_type is not None:
            result['TargetType'] = self.target_type
        if self.topic_filter is not None:
            result['TopicFilter'] = self.topic_filter
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RouteId') is not None:
            self.route_id = m.get('RouteId')
        if m.get('SourceData') is not None:
            self.source_data = m.get('SourceData')
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        if m.get('TargetData') is not None:
            self.target_data = m.get('TargetData')
        if m.get('TargetIotHubQos') is not None:
            self.target_iot_hub_qos = m.get('TargetIotHubQos')
        if m.get('TargetType') is not None:
            self.target_type = m.get('TargetType')
        if m.get('TopicFilter') is not None:
            self.topic_filter = m.get('TopicFilter')
        return self


class UpdateEdgeInstanceMessageRoutingResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateEdgeInstanceMessageRoutingResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateEdgeInstanceMessageRoutingResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateEdgeInstanceMessageRoutingResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateJobRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        iot_instance_id: str = None,
        job_id: str = None,
        rollout_config: Dict[str, Any] = None,
        timeout_config: Dict[str, Any] = None,
    ):
        self.description = description
        self.iot_instance_id = iot_instance_id
        self.job_id = job_id
        self.rollout_config = rollout_config
        self.timeout_config = timeout_config

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.rollout_config is not None:
            result['RolloutConfig'] = self.rollout_config
        if self.timeout_config is not None:
            result['TimeoutConfig'] = self.timeout_config
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('RolloutConfig') is not None:
            self.rollout_config = m.get('RolloutConfig')
        if m.get('TimeoutConfig') is not None:
            self.timeout_config = m.get('TimeoutConfig')
        return self


class UpdateJobShrinkRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        iot_instance_id: str = None,
        job_id: str = None,
        rollout_config_shrink: str = None,
        timeout_config_shrink: str = None,
    ):
        self.description = description
        self.iot_instance_id = iot_instance_id
        self.job_id = job_id
        self.rollout_config_shrink = rollout_config_shrink
        self.timeout_config_shrink = timeout_config_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.rollout_config_shrink is not None:
            result['RolloutConfig'] = self.rollout_config_shrink
        if self.timeout_config_shrink is not None:
            result['TimeoutConfig'] = self.timeout_config_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('RolloutConfig') is not None:
            self.rollout_config_shrink = m.get('RolloutConfig')
        if m.get('TimeoutConfig') is not None:
            self.timeout_config_shrink = m.get('TimeoutConfig')
        return self


class UpdateJobResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateOTAJobRequestTags(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        self.key = key
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class UpdateOTAJobRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        job_id: str = None,
        maximum_per_minute: int = None,
        src_version_list: List[str] = None,
        tags: List[UpdateOTAJobRequestTags] = None,
        target_selection: str = None,
        timeout_in_minutes: int = None,
        upgrade_type: str = None,
    ):
        self.iot_instance_id = iot_instance_id
        self.job_id = job_id
        self.maximum_per_minute = maximum_per_minute
        self.src_version_list = src_version_list
        self.tags = tags
        self.target_selection = target_selection
        self.timeout_in_minutes = timeout_in_minutes
        self.upgrade_type = upgrade_type

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.maximum_per_minute is not None:
            result['MaximumPerMinute'] = self.maximum_per_minute
        if self.src_version_list is not None:
            result['SrcVersionList'] = self.src_version_list
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        if self.target_selection is not None:
            result['TargetSelection'] = self.target_selection
        if self.timeout_in_minutes is not None:
            result['TimeoutInMinutes'] = self.timeout_in_minutes
        if self.upgrade_type is not None:
            result['UpgradeType'] = self.upgrade_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('MaximumPerMinute') is not None:
            self.maximum_per_minute = m.get('MaximumPerMinute')
        if m.get('SrcVersionList') is not None:
            self.src_version_list = m.get('SrcVersionList')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = UpdateOTAJobRequestTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('TargetSelection') is not None:
            self.target_selection = m.get('TargetSelection')
        if m.get('TimeoutInMinutes') is not None:
            self.timeout_in_minutes = m.get('TimeoutInMinutes')
        if m.get('UpgradeType') is not None:
            self.upgrade_type = m.get('UpgradeType')
        return self


class UpdateOTAJobResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateOTAJobResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateOTAJobResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateOTAJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateOTAModuleRequest(TeaModel):
    def __init__(
        self,
        alias_name: str = None,
        desc: str = None,
        iot_instance_id: str = None,
        module_name: str = None,
        product_key: str = None,
    ):
        # The new alias of the OTA module. The alias must be 1 to 64 characters in length, and can contain letters, digits, periods(.), hyphens (-), and underscores (\_).
        self.alias_name = alias_name
        # The new description of the OTA module. The description can be up to 100 characters in length.
        self.desc = desc
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The name of the OTA module.
        self.module_name = module_name
        # The **ProductKey** of the product to which the OTA module belongs.
        self.product_key = product_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias_name is not None:
            result['AliasName'] = self.alias_name
        if self.desc is not None:
            result['Desc'] = self.desc
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.module_name is not None:
            result['ModuleName'] = self.module_name
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('AliasName') is not None:
            self.alias_name = m.get('AliasName')
        if m.get('Desc') is not None:
            self.desc = m.get('Desc')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ModuleName') is not None:
            self.module_name = m.get('ModuleName')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        return self


class UpdateOTAModuleResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateOTAModuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateOTAModuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateOTAModuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateParserRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        iot_instance_id: str = None,
        name: str = None,
        parser_id: int = None,
    ):
        self.description = description
        self.iot_instance_id = iot_instance_id
        self.name = name
        self.parser_id = parser_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.name is not None:
            result['Name'] = self.name
        if self.parser_id is not None:
            result['ParserId'] = self.parser_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ParserId') is not None:
            self.parser_id = m.get('ParserId')
        return self


class UpdateParserResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateParserResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateParserResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateParserResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateParserDataSourceRequest(TeaModel):
    def __init__(
        self,
        data_source_id: int = None,
        description: str = None,
        iot_instance_id: str = None,
        name: str = None,
    ):
        self.data_source_id = data_source_id
        self.description = description
        self.iot_instance_id = iot_instance_id
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_source_id is not None:
            result['DataSourceId'] = self.data_source_id
        if self.description is not None:
            result['Description'] = self.description
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DataSourceId') is not None:
            self.data_source_id = m.get('DataSourceId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class UpdateParserDataSourceResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateParserDataSourceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateParserDataSourceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateParserDataSourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateProductRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        iot_instance_id: str = None,
        product_key: str = None,
        product_name: str = None,
    ):
        # The description of the product. The description must be 1 to 100 characters in length.
        self.description = description
        # The ID of the instance. You can view the ID of the instance on the **Overview** page in the IoT Platform console.
        # 
        # 
        # 
        # **Important**\
        # 
        # *   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.****\
        # *   If no **Overview** page or **ID** is generated for your instance, you do not need to configure this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The ProductKey of the product. A ProductKey is a GUID that is issued by IoT Platform to the product.****\
        # 
        # You can use the IoT Platform console or call the [QueryProductList](~~69271~~) operation to view the information about all products within the current Alibaba Cloud account.
        self.product_key = product_key
        # The new product name that you want to use.
        # 
        # The name must be 4 to 30 characters in length, and can contain letters, digits, and underscores (\_).
        # 
        # 
        # **Important** Each product name must be unique within the current Alibaba Cloud account.
        self.product_name = product_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.product_name is not None:
            result['ProductName'] = self.product_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('ProductName') is not None:
            self.product_name = m.get('ProductName')
        return self


class UpdateProductResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful. Valid values:
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateProductResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateProductResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateProductResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateProductFilterConfigRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        product_key: str = None,
        property_timestamp_filter: bool = None,
        property_value_filter: bool = None,
    ):
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The ProductKey of the product. A ProductKey is a GUID that is issued by IoT Platform to a product.
        # 
        # You can use the IoT Platform console or call the [QueryProductList](~~69271~~) operation to view the information about all products within the current account.
        self.product_key = product_key
        # Specifies whether to deduplicate messages based on the submission time of each property. Valid values:
        # 
        # *   **true**: deduplicates property messages that have the same timestamp.
        # *   **false**: does not deduplicate messages based on timestamps.
        self.property_timestamp_filter = property_timestamp_filter
        # Specifies whether to deduplicate messages based on the value of each property. Valid values:
        # 
        # *   **true**: deduplicates property messages that have the same property value.
        # *   **false**: does not deduplicate messages based on property values.
        self.property_value_filter = property_value_filter

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.property_timestamp_filter is not None:
            result['PropertyTimestampFilter'] = self.property_timestamp_filter
        if self.property_value_filter is not None:
            result['PropertyValueFilter'] = self.property_value_filter
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('PropertyTimestampFilter') is not None:
            self.property_timestamp_filter = m.get('PropertyTimestampFilter')
        if m.get('PropertyValueFilter') is not None:
            self.property_value_filter = m.get('PropertyValueFilter')
        return self


class UpdateProductFilterConfigResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateProductFilterConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateProductFilterConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateProductFilterConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateProductTagsRequestProductTag(TeaModel):
    def __init__(
        self,
        tag_key: str = None,
        tag_value: str = None,
    ):
        # The keys of the product tags. Each key must be 1 to 30 characters in length, and can contain letters, digits, and periods (.).
        # 
        # >  Each tag key that you specify must already exist. Each tag value that you specify must be unique.
        self.tag_key = tag_key
        # The new values of the product tags. Each tag value must be 1 to 128 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-).
        self.tag_value = tag_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        return self


class UpdateProductTagsRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        product_key: str = None,
        product_tag: List[UpdateProductTagsRequestProductTag] = None,
    ):
        # The ID of the instance. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
        # 
        # 
        # >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.
        # >*   If no **Overview** page or ID is generated for your instance, you do not need to configure this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The ProductKey of the product. A ProductKey is a GUID that is issued by IoT Platform to a product. You can use the IoT Platform console or call the [QueryProductList](~~69271~~) operation to view the information about all products within the current account.
        self.product_key = product_key
        self.product_tag = product_tag

    def validate(self):
        if self.product_tag:
            for k in self.product_tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        result['ProductTag'] = []
        if self.product_tag is not None:
            for k in self.product_tag:
                result['ProductTag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        self.product_tag = []
        if m.get('ProductTag') is not None:
            for k in m.get('ProductTag'):
                temp_model = UpdateProductTagsRequestProductTag()
                self.product_tag.append(temp_model.from_map(k))
        return self


class UpdateProductTagsResponseBodyInvalidProductTagsProductTag(TeaModel):
    def __init__(
        self,
        tag_key: str = None,
        tag_value: str = None,
    ):
        # The key of the tag.
        self.tag_key = tag_key
        # The value of the tag.
        self.tag_value = tag_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        return self


class UpdateProductTagsResponseBodyInvalidProductTags(TeaModel):
    def __init__(
        self,
        product_tag: List[UpdateProductTagsResponseBodyInvalidProductTagsProductTag] = None,
    ):
        self.product_tag = product_tag

    def validate(self):
        if self.product_tag:
            for k in self.product_tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ProductTag'] = []
        if self.product_tag is not None:
            for k in self.product_tag:
                result['ProductTag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.product_tag = []
        if m.get('ProductTag') is not None:
            for k in m.get('ProductTag'):
                temp_model = UpdateProductTagsResponseBodyInvalidProductTagsProductTag()
                self.product_tag.append(temp_model.from_map(k))
        return self


class UpdateProductTagsResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        invalid_product_tags: UpdateProductTagsResponseBodyInvalidProductTags = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the request fails.
        self.error_message = error_message
        # The invalid product tags returned if the call fails. The details are included in the **ProductTag** parameter.
        self.invalid_product_tags = invalid_product_tags
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**\
        # *   **false**\
        self.success = success

    def validate(self):
        if self.invalid_product_tags:
            self.invalid_product_tags.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.invalid_product_tags is not None:
            result['InvalidProductTags'] = self.invalid_product_tags.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('InvalidProductTags') is not None:
            temp_model = UpdateProductTagsResponseBodyInvalidProductTags()
            self.invalid_product_tags = temp_model.from_map(m['InvalidProductTags'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateProductTagsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateProductTagsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateProductTagsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateProductTopicRequest(TeaModel):
    def __init__(
        self,
        codec: str = None,
        desc: str = None,
        enable_proxy_subscribe: bool = None,
        iot_instance_id: str = None,
        operation: str = None,
        topic_id: str = None,
        topic_short_name: str = None,
    ):
        self.codec = codec
        # The description of the topic category. The description must be 1 to 100 characters in length.
        self.desc = desc
        self.enable_proxy_subscribe = enable_proxy_subscribe
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The operation permissions of the device on the topic category. Valid values:
        # 
        # *   **SUB**: Subscribe.
        # *   **PUB**: Publish.
        # *   **ALL**: Publish and Subscribe.
        self.operation = operation
        # The ID of the topic category that you want to modify.
        self.topic_id = topic_id
        # The name of the user-defined category level that you want to set. By default, a topic category includes the following levels: \_productkey\_ and \_devicename\_. Separate the two levels with slashes (/). Format of a topic category: `productKey/deviceName/topicShortName`.
        # 
        # >  Each level can contain letters, digits, and underscores (\_), and cannot be empty.
        self.topic_short_name = topic_short_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.desc is not None:
            result['Desc'] = self.desc
        if self.enable_proxy_subscribe is not None:
            result['EnableProxySubscribe'] = self.enable_proxy_subscribe
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.operation is not None:
            result['Operation'] = self.operation
        if self.topic_id is not None:
            result['TopicId'] = self.topic_id
        if self.topic_short_name is not None:
            result['TopicShortName'] = self.topic_short_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Desc') is not None:
            self.desc = m.get('Desc')
        if m.get('EnableProxySubscribe') is not None:
            self.enable_proxy_subscribe = m.get('EnableProxySubscribe')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('Operation') is not None:
            self.operation = m.get('Operation')
        if m.get('TopicId') is not None:
            self.topic_id = m.get('TopicId')
        if m.get('TopicShortName') is not None:
            self.topic_short_name = m.get('TopicShortName')
        return self


class UpdateProductTopicResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateProductTopicResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateProductTopicResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateProductTopicResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateRuleRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        name: str = None,
        product_key: str = None,
        rule_desc: str = None,
        rule_id: int = None,
        select: str = None,
        short_topic: str = None,
        topic: str = None,
        topic_type: int = None,
        where: str = None,
    ):
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The name of the rule. The rule name must be 1 to 30 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-).
        self.name = name
        # The **ProductKey** of the product to which the rule applies.
        self.product_key = product_key
        # The description of the rule. The description can be up to 100 characters in length.
        self.rule_desc = rule_desc
        # The ID of the rule that you want to modify. You can log on to the IoT Platform console and choose **Rules** > **Data Forwarding** to view the rule ID. You can also call the [ListRule](~~69486~~) operation and view the rule ID in the response.
        self.rule_id = rule_id
        # The SQL SELECT statement to be executed. For more information, see [SQL expressions](~~30554~~).
        # 
        # >  Specify the content that follows the SELECT keyword for this parameter. For example, if the SELECT statement is `SELECT a,b,c`, specify `a,b,c` for this parameter.
        self.select = select
        # The topic to which this rule is applied. Syntax: `${deviceName}/topicShortName`. `${deviceName}` specifies the name of the device, and `topicShortName` specifies the custom name of the topic.
        # 
        # *   Basic communication topics or Thing Specification Language (TSL)-based communication topics. Syntax: `${deviceName}/topicShortName`. You can replace `${deviceName}` with the `+` wildcard. The wildcard indicates that the topic applies to all devices under the product. Valid values of `topicShortName`:
        # 
        #     *   `/thing/event/property/post`: submits the property data of a device.
        # 
        #     *   `/thing/event/${tsl.event.identifier}/post`: submits the event data of a device. `${tsl.event.identifier}` specifies the identifier of an event in the TSL model.
        # 
        #     *   `/thing/lifecycle`: submits device lifecycle changes.
        # 
        #     *   `/thing/downlink/reply/message`: sends a response to a request from IoT Platform.
        # 
        #     *   `/thing/list/found`: submits the data when a gateway detects a new sub-device.
        # 
        #     *   `/thing/topo/lifecycle`: submits device topology changes.
        # 
        #     *   `/thing/event/property/history/post`: submits historical property data of a device.
        # 
        #     *   `/thing/event/${tsl.event.identifier}/post`: submits the historical event data of a device. `${tsl.event.identifier}` specifies the identifier of an event in the TSL.
        # 
        #     *   `/ota/upgrade`: submits OTA update statuses.
        # 
        #     *   `/ota/version/post`: submits OTA module versions.
        # 
        #     *   `/thing/deviceinfo/update`: submits device tag changes.
        # 
        #     *   `/edge/driver/${driver_id}/point_post`: submits pass-through data from Link IoT Edge. `${driver_id}` specifies the ID of the driver that a device uses to access Link IoT Edge.
        # 
        #         `${packageId}/${jobId}/ota/job/status`: submits the statuses of OTA update batches. This topic is a basic communication topic. `${packageId}` specifies the ID of the update package. `${jobId}` specifies the ID of the update batch.
        # 
        # *   Custom topics. Example: `${deviceName}/user/get`.
        # 
        #     You can call the [QueryProductTopic](~~69647~~) operation to view all custom topics of the product.
        # 
        #     When you specify a custom topic, you can use the `+` and `#` wildcards.
        # 
        #     *   You can replace `${deviceName}` with the `+` wildcard. The wildcard indicates that the topic applies to all devices under the product.
        # 
        #     *   You can replace the fields that follow ${deviceName} with `/user/#`. The `#` wildcard indicates that the topic applies whatever values are specified for the fields that follow`/user`.
        # 
        #         For more information about how to use wildcards, see [Wildcards in topics](~~85539~~).
        # 
        # *   Topic that is used to submit device status changes: `${deviceName}`.
        # 
        #     You can use the `+` wildcard. In this case, the status changes of all devices under the product are submitted.
        self.short_topic = short_topic
        # The complete topic to which the rule applies.
        # 
        # If you specify this parameter, you do not need to specify the **ProductKey**, **ShortTopic**, and **TopicType** parameters.
        self.topic = topic
        # *   **0**: The topic is a basic communication topic or TSL-based communication topic.****\
        # *   **1**: The topic is a custom topic.
        # *   **2**: The topic is used to submit device status changes. Syntax: `/as/mqtt/status/${productKey}/${deviceName}`.
        self.topic_type = topic_type
        # The condition that is used to trigger the rule. For more information, see [SQL expressions](~~30554~~).
        # 
        # >  Specify the content that follows the WHERE keyword for this parameter. For example, if the WHERE statement is `WHERE a>10`, specify `a>10` for this parameter.
        self.where = where

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.name is not None:
            result['Name'] = self.name
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.rule_desc is not None:
            result['RuleDesc'] = self.rule_desc
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.select is not None:
            result['Select'] = self.select
        if self.short_topic is not None:
            result['ShortTopic'] = self.short_topic
        if self.topic is not None:
            result['Topic'] = self.topic
        if self.topic_type is not None:
            result['TopicType'] = self.topic_type
        if self.where is not None:
            result['Where'] = self.where
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('RuleDesc') is not None:
            self.rule_desc = m.get('RuleDesc')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('Select') is not None:
            self.select = m.get('Select')
        if m.get('ShortTopic') is not None:
            self.short_topic = m.get('ShortTopic')
        if m.get('Topic') is not None:
            self.topic = m.get('Topic')
        if m.get('TopicType') is not None:
            self.topic_type = m.get('TopicType')
        if m.get('Where') is not None:
            self.where = m.get('Where')
        return self


class UpdateRuleResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateRuleActionRequest(TeaModel):
    def __init__(
        self,
        action_id: int = None,
        configuration: str = None,
        iot_instance_id: str = None,
        type: str = None,
    ):
        # The ID of the rule action to be modified.
        # 
        # After you call the [CreateRuleAction](~~69586~~) operation to create a rule action, the rule action ID is returned. You can call the [ListRuleActions](~~69517~~) operation to view the rule action ID.
        self.action_id = action_id
        # The configurations of the rule action. The configurations for different rule action types are different. For more information about the configurations for different rule action types, see [CreateRuleAction](~~69586~~).
        self.configuration = configuration
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The type of the rule action. Valid values:
        # 
        # *   **MNS**: forwards topic data that is processed by the rules engine to MNS.
        # *   **FC**: forwards topic data that is processed by the rules engine to Function Compute for event computing.
        # *   **REPUBLISH**: forwards topic data that is processed by the rules engine to another IoT Platform topic.
        # *   **AMQP**: forwards data to an AMQP consumer group.
        # *   **OTS**: forwards topic data that is processed by the rules engine to Tablestore for NoSQL data storage.
        # 
        # > *   If you set the **DataType** parameter to **BINARY**, rules are created in the binary format. These rules cannot be used to forward data to Tablestore.
        # >*   Destination Alibaba Cloud services that are supported by the rules engine vary based on regions. For more information about the regions and destination cloud services that are supported by the rules engine, see [Regions and zones](~~85669~~).
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_id is not None:
            result['ActionId'] = self.action_id
        if self.configuration is not None:
            result['Configuration'] = self.configuration
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ActionId') is not None:
            self.action_id = m.get('ActionId')
        if m.get('Configuration') is not None:
            self.configuration = m.get('Configuration')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class UpdateRuleActionResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateRuleActionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateRuleActionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateRuleActionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateSceneRuleRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        rule_content: str = None,
        rule_description: str = None,
        rule_id: str = None,
        rule_name: str = None,
    ):
        self.iot_instance_id = iot_instance_id
        self.rule_content = rule_content
        self.rule_description = rule_description
        self.rule_id = rule_id
        self.rule_name = rule_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.rule_content is not None:
            result['RuleContent'] = self.rule_content
        if self.rule_description is not None:
            result['RuleDescription'] = self.rule_description
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('RuleContent') is not None:
            self.rule_content = m.get('RuleContent')
        if m.get('RuleDescription') is not None:
            self.rule_description = m.get('RuleDescription')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        return self


class UpdateSceneRuleResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateSceneRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateSceneRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateSceneRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateSchedulePeriodRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        end_time: str = None,
        iot_instance_id: str = None,
        period_code: str = None,
        sound_code_content: str = None,
        start_time: str = None,
    ):
        self.description = description
        self.end_time = end_time
        self.iot_instance_id = iot_instance_id
        self.period_code = period_code
        self.sound_code_content = sound_code_content
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.period_code is not None:
            result['PeriodCode'] = self.period_code
        if self.sound_code_content is not None:
            result['SoundCodeContent'] = self.sound_code_content
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('PeriodCode') is not None:
            self.period_code = m.get('PeriodCode')
        if m.get('SoundCodeContent') is not None:
            self.sound_code_content = m.get('SoundCodeContent')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class UpdateSchedulePeriodResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateSchedulePeriodResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateSchedulePeriodResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateSchedulePeriodResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateSoundCodeRequest(TeaModel):
    def __init__(
        self,
        duration: int = None,
        iot_instance_id: str = None,
        name: str = None,
        sound_code: str = None,
        sound_code_content: str = None,
    ):
        self.duration = duration
        self.iot_instance_id = iot_instance_id
        self.name = name
        self.sound_code = sound_code
        self.sound_code_content = sound_code_content

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.name is not None:
            result['Name'] = self.name
        if self.sound_code is not None:
            result['SoundCode'] = self.sound_code
        if self.sound_code_content is not None:
            result['SoundCodeContent'] = self.sound_code_content
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('SoundCode') is not None:
            self.sound_code = m.get('SoundCode')
        if m.get('SoundCodeContent') is not None:
            self.sound_code_content = m.get('SoundCodeContent')
        return self


class UpdateSoundCodeResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateSoundCodeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateSoundCodeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateSoundCodeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateSoundCodeLabelRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        label: str = None,
        sound_code: str = None,
    ):
        self.iot_instance_id = iot_instance_id
        self.label = label
        self.sound_code = sound_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.label is not None:
            result['Label'] = self.label
        if self.sound_code is not None:
            result['SoundCode'] = self.sound_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('SoundCode') is not None:
            self.sound_code = m.get('SoundCode')
        return self


class UpdateSoundCodeLabelResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateSoundCodeLabelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateSoundCodeLabelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateSoundCodeLabelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateSoundCodeScheduleRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        end_date: str = None,
        end_time: str = None,
        iot_instance_id: str = None,
        name: str = None,
        schedule_code: str = None,
        start_date: str = None,
        start_time: str = None,
        status: str = None,
    ):
        self.description = description
        self.end_date = end_date
        self.end_time = end_time
        self.iot_instance_id = iot_instance_id
        self.name = name
        self.schedule_code = schedule_code
        self.start_date = start_date
        self.start_time = start_time
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.end_date is not None:
            result['EndDate'] = self.end_date
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.name is not None:
            result['Name'] = self.name
        if self.schedule_code is not None:
            result['ScheduleCode'] = self.schedule_code
        if self.start_date is not None:
            result['StartDate'] = self.start_date
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EndDate') is not None:
            self.end_date = m.get('EndDate')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ScheduleCode') is not None:
            self.schedule_code = m.get('ScheduleCode')
        if m.get('StartDate') is not None:
            self.start_date = m.get('StartDate')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class UpdateSoundCodeScheduleResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateSoundCodeScheduleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateSoundCodeScheduleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateSoundCodeScheduleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateSpeechRequest(TeaModel):
    def __init__(
        self,
        enable_sound_code: bool = None,
        iot_instance_id: str = None,
        project_code: str = None,
        sound_code_config: Dict[str, Any] = None,
        speech_code: str = None,
        speech_rate: int = None,
        voice: str = None,
        volume: int = None,
    ):
        self.enable_sound_code = enable_sound_code
        self.iot_instance_id = iot_instance_id
        self.project_code = project_code
        self.sound_code_config = sound_code_config
        self.speech_code = speech_code
        self.speech_rate = speech_rate
        self.voice = voice
        self.volume = volume

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable_sound_code is not None:
            result['EnableSoundCode'] = self.enable_sound_code
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.project_code is not None:
            result['ProjectCode'] = self.project_code
        if self.sound_code_config is not None:
            result['SoundCodeConfig'] = self.sound_code_config
        if self.speech_code is not None:
            result['SpeechCode'] = self.speech_code
        if self.speech_rate is not None:
            result['SpeechRate'] = self.speech_rate
        if self.voice is not None:
            result['Voice'] = self.voice
        if self.volume is not None:
            result['Volume'] = self.volume
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnableSoundCode') is not None:
            self.enable_sound_code = m.get('EnableSoundCode')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProjectCode') is not None:
            self.project_code = m.get('ProjectCode')
        if m.get('SoundCodeConfig') is not None:
            self.sound_code_config = m.get('SoundCodeConfig')
        if m.get('SpeechCode') is not None:
            self.speech_code = m.get('SpeechCode')
        if m.get('SpeechRate') is not None:
            self.speech_rate = m.get('SpeechRate')
        if m.get('Voice') is not None:
            self.voice = m.get('Voice')
        if m.get('Volume') is not None:
            self.volume = m.get('Volume')
        return self


class UpdateSpeechShrinkRequest(TeaModel):
    def __init__(
        self,
        enable_sound_code: bool = None,
        iot_instance_id: str = None,
        project_code: str = None,
        sound_code_config_shrink: str = None,
        speech_code: str = None,
        speech_rate: int = None,
        voice: str = None,
        volume: int = None,
    ):
        self.enable_sound_code = enable_sound_code
        self.iot_instance_id = iot_instance_id
        self.project_code = project_code
        self.sound_code_config_shrink = sound_code_config_shrink
        self.speech_code = speech_code
        self.speech_rate = speech_rate
        self.voice = voice
        self.volume = volume

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable_sound_code is not None:
            result['EnableSoundCode'] = self.enable_sound_code
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.project_code is not None:
            result['ProjectCode'] = self.project_code
        if self.sound_code_config_shrink is not None:
            result['SoundCodeConfig'] = self.sound_code_config_shrink
        if self.speech_code is not None:
            result['SpeechCode'] = self.speech_code
        if self.speech_rate is not None:
            result['SpeechRate'] = self.speech_rate
        if self.voice is not None:
            result['Voice'] = self.voice
        if self.volume is not None:
            result['Volume'] = self.volume
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('EnableSoundCode') is not None:
            self.enable_sound_code = m.get('EnableSoundCode')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProjectCode') is not None:
            self.project_code = m.get('ProjectCode')
        if m.get('SoundCodeConfig') is not None:
            self.sound_code_config_shrink = m.get('SoundCodeConfig')
        if m.get('SpeechCode') is not None:
            self.speech_code = m.get('SpeechCode')
        if m.get('SpeechRate') is not None:
            self.speech_rate = m.get('SpeechRate')
        if m.get('Voice') is not None:
            self.voice = m.get('Voice')
        if m.get('Volume') is not None:
            self.volume = m.get('Volume')
        return self


class UpdateSpeechResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateSpeechResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateSpeechResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateSpeechResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateSubscribeRelationRequest(TeaModel):
    def __init__(
        self,
        consumer_group_ids: List[str] = None,
        device_data_flag: bool = None,
        device_life_cycle_flag: bool = None,
        device_status_change_flag: bool = None,
        device_tag_flag: bool = None,
        device_topo_life_cycle_flag: bool = None,
        found_device_list_flag: bool = None,
        iot_instance_id: str = None,
        mns_configuration: str = None,
        ota_event_flag: bool = None,
        ota_job_flag: bool = None,
        ota_version_flag: bool = None,
        product_key: str = None,
        subscribe_flags: str = None,
        thing_history_flag: bool = None,
        type: str = None,
    ):
        self.consumer_group_ids = consumer_group_ids
        # Specifies whether to push upstream device messages. Valid values:
        # 
        # *   **true**: yes.
        # *   **false**: no.
        # 
        # Default value: **false**.
        self.device_data_flag = device_data_flag
        # Specifies whether to push messages about device lifecycle changes. Valid values:
        # 
        # *   **true**: yes.
        # *   **false**: no.
        # 
        # Default value: **false**.
        self.device_life_cycle_flag = device_life_cycle_flag
        # Specifies whether to push messages about device status changes. Valid values:
        # 
        # *   **true**: yes.
        # *   **false**: no.
        # 
        # Default value: **false**.
        self.device_status_change_flag = device_status_change_flag
        # Specifies whether to push messages about topological relationship changes of devices. Valid values:
        # 
        # *   **true**: yes. This parameter takes effect only if the **Type** parameter is set to **AMQP**.
        # *   **false**: no.
        # 
        # Default value: **false**.
        self.device_tag_flag = device_tag_flag
        # Specifies whether to push messages about topological relationship changes of devices. Valid values:
        # 
        # *   **true**: yes. This parameter is valid only for gateway products.
        # *   **false**: no.
        # 
        # Default value: **false**.
        self.device_topo_life_cycle_flag = device_topo_life_cycle_flag
        # Specifies whether to push messages if a gateway detects new sub-devices. Valid values:
        # 
        # *   **true**: yes. This parameter is valid only for gateway products.
        # *   **false**: no.
        # 
        # Default value: **false**.
        self.found_device_list_flag = found_device_list_flag
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The configurations of the MNS queue. This parameter is required if the **Type** parameter is set to **AMQP**.
        # 
        # For more information, see the "Definition of the MnsConfiguration parameter" section.
        self.mns_configuration = mns_configuration
        # Specifies whether to push notifications about the status of OTA update batches. Valid values:
        # 
        # *   **true**: yes.
        # *   **false**: no.
        # 
        # Default value: **false**.
        self.ota_event_flag = ota_event_flag
        # Specifies whether to push notifications about the statuses of OTA update batches. Valid values:
        # 
        # *   **true**: yes. This parameter takes effect only if the **Type** parameter is set to **AMQP**.
        # *   **false**: no.
        # 
        # Default value: **false**.
        self.ota_job_flag = ota_job_flag
        # Specifies whether to push messages about OTA module version numbers. Valid values:
        # 
        # *   **true**: yes. This parameter takes effect only if the **Type** parameter is set to **AMQP**.
        # *   **false**: no.
        # 
        # Default value: **false**.
        self.ota_version_flag = ota_version_flag
        # The **ProductKey** of the product that is specified for the subscription.
        self.product_key = product_key
        self.subscribe_flags = subscribe_flags
        # Specifies whether to push upstream historical Thing Specification Language (TSL) data. Valid values:
        # 
        # *   **true**: yes.
        # *   **false**: no.
        # 
        # Default value: **false**.
        self.thing_history_flag = thing_history_flag
        # The type of the subscription. Valid values:
        # 
        # *   **MNS**\
        # *   **AMQP**\
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.consumer_group_ids is not None:
            result['ConsumerGroupIds'] = self.consumer_group_ids
        if self.device_data_flag is not None:
            result['DeviceDataFlag'] = self.device_data_flag
        if self.device_life_cycle_flag is not None:
            result['DeviceLifeCycleFlag'] = self.device_life_cycle_flag
        if self.device_status_change_flag is not None:
            result['DeviceStatusChangeFlag'] = self.device_status_change_flag
        if self.device_tag_flag is not None:
            result['DeviceTagFlag'] = self.device_tag_flag
        if self.device_topo_life_cycle_flag is not None:
            result['DeviceTopoLifeCycleFlag'] = self.device_topo_life_cycle_flag
        if self.found_device_list_flag is not None:
            result['FoundDeviceListFlag'] = self.found_device_list_flag
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.mns_configuration is not None:
            result['MnsConfiguration'] = self.mns_configuration
        if self.ota_event_flag is not None:
            result['OtaEventFlag'] = self.ota_event_flag
        if self.ota_job_flag is not None:
            result['OtaJobFlag'] = self.ota_job_flag
        if self.ota_version_flag is not None:
            result['OtaVersionFlag'] = self.ota_version_flag
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.subscribe_flags is not None:
            result['SubscribeFlags'] = self.subscribe_flags
        if self.thing_history_flag is not None:
            result['ThingHistoryFlag'] = self.thing_history_flag
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ConsumerGroupIds') is not None:
            self.consumer_group_ids = m.get('ConsumerGroupIds')
        if m.get('DeviceDataFlag') is not None:
            self.device_data_flag = m.get('DeviceDataFlag')
        if m.get('DeviceLifeCycleFlag') is not None:
            self.device_life_cycle_flag = m.get('DeviceLifeCycleFlag')
        if m.get('DeviceStatusChangeFlag') is not None:
            self.device_status_change_flag = m.get('DeviceStatusChangeFlag')
        if m.get('DeviceTagFlag') is not None:
            self.device_tag_flag = m.get('DeviceTagFlag')
        if m.get('DeviceTopoLifeCycleFlag') is not None:
            self.device_topo_life_cycle_flag = m.get('DeviceTopoLifeCycleFlag')
        if m.get('FoundDeviceListFlag') is not None:
            self.found_device_list_flag = m.get('FoundDeviceListFlag')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('MnsConfiguration') is not None:
            self.mns_configuration = m.get('MnsConfiguration')
        if m.get('OtaEventFlag') is not None:
            self.ota_event_flag = m.get('OtaEventFlag')
        if m.get('OtaJobFlag') is not None:
            self.ota_job_flag = m.get('OtaJobFlag')
        if m.get('OtaVersionFlag') is not None:
            self.ota_version_flag = m.get('OtaVersionFlag')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('SubscribeFlags') is not None:
            self.subscribe_flags = m.get('SubscribeFlags')
        if m.get('ThingHistoryFlag') is not None:
            self.thing_history_flag = m.get('ThingHistoryFlag')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class UpdateSubscribeRelationResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateSubscribeRelationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateSubscribeRelationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateSubscribeRelationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateThingModelRequest(TeaModel):
    def __init__(
        self,
        function_block_id: str = None,
        function_block_name: str = None,
        identifier: str = None,
        iot_instance_id: str = None,
        product_key: str = None,
        thing_model_json: str = None,
    ):
        # The identifier of the custom TSL module. Each identifier is unique in a product.
        # 
        # If you do not specify this parameter or the **FunctionBlockName** parameter, the system updates the features of the default module.
        self.function_block_id = function_block_id
        # The name of the custom module. The name must be 4 to 30 characters in length, and can contain letters, digits, and underscores (\_).
        # 
        # *   If you do not specify this parameter or the **FunctionBlockId** parameter, the system updates the features of the default module.
        # *   If you specify this parameter, the parameter must be used in combination with the **FunctionBlockId** parameter. You can modify the name of the specified custom module. The name corresponds to the value of the **FunctionBlockId** parameter.
        # 
        # >  You cannot modify the name of the default module.
        self.function_block_name = function_block_name
        # The identifier of the feature.
        # 
        # You can call the [GetThingModelTsl](~~150319~~) operation and view the identifier in the **TslStr** response parameter.
        self.identifier = identifier
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The **ProductKey** of the product.
        # 
        # You can view the ProductKey on the Product Details page of the IoT Platform console. You can also obtain the ProductKey by calling the [QueryProductList](~~69271~~) operation.
        self.product_key = product_key
        # The updated details of the feature.
        # 
        # *   If you specify the **Identifier** parameter, you can define only the identifier of the feature.
        # *   If you do not specify the **Identifier** parameter, you can define a maximum of 50 input and output parameters for a service or event.
        # 
        # For more information about how to specify this parameter, see [Data structure of ThingModelJson](~~150457~~).
        self.thing_model_json = thing_model_json

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.function_block_id is not None:
            result['FunctionBlockId'] = self.function_block_id
        if self.function_block_name is not None:
            result['FunctionBlockName'] = self.function_block_name
        if self.identifier is not None:
            result['Identifier'] = self.identifier
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.thing_model_json is not None:
            result['ThingModelJson'] = self.thing_model_json
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('FunctionBlockId') is not None:
            self.function_block_id = m.get('FunctionBlockId')
        if m.get('FunctionBlockName') is not None:
            self.function_block_name = m.get('FunctionBlockName')
        if m.get('Identifier') is not None:
            self.identifier = m.get('Identifier')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('ThingModelJson') is not None:
            self.thing_model_json = m.get('ThingModelJson')
        return self


class UpdateThingModelResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateThingModelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateThingModelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateThingModelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateThingScriptRequest(TeaModel):
    def __init__(
        self,
        iot_instance_id: str = None,
        product_key: str = None,
        script_content: str = None,
        script_type: str = None,
    ):
        # The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
        # 
        # >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
        # >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
        # 
        # For more information, see [Overview](~~356505~~).
        self.iot_instance_id = iot_instance_id
        # The **ProductKey** of the product.
        # 
        # You can view the **ProductKey** on the Product Details page of the IoT Platform console. You can also obtain the ProductKey by calling the [QueryProductList](~~69271~~) operation.
        self.product_key = product_key
        # The content of the script. You must specify this parameter.
        # 
        # For more information about script examples, see [What is data parsing](~~68702~~).
        self.script_content = script_content
        # The type of the script. Valid values:
        # 
        # *   JavaScript
        # *   Python\_27: Python 2.7
        # *   PHP\_72: PHP 7.2
        self.script_type = script_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.script_content is not None:
            result['ScriptContent'] = self.script_content
        if self.script_type is not None:
            result['ScriptType'] = self.script_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('ScriptContent') is not None:
            self.script_content = m.get('ScriptContent')
        if m.get('ScriptType') is not None:
            self.script_type = m.get('ScriptType')
        return self


class UpdateThingScriptResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        # The error message returned if the call fails.
        self.error_message = error_message
        # The ID of the request.
        self.request_id = request_id
        # Indicates whether the call was successful.
        # 
        # *   **true**: The call was successful.
        # *   **false**: The call failed.
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateThingScriptResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateThingScriptResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateThingScriptResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTopicConfigRequest(TeaModel):
    def __init__(
        self,
        codec: str = None,
        description: str = None,
        enable_broadcast: bool = None,
        enable_proxy_subscribe: bool = None,
        iot_instance_id: str = None,
        operation: str = None,
        product_key: str = None,
        topic_full_name: str = None,
    ):
        self.codec = codec
        self.description = description
        # Specifies whether to enable the retained message broadcasting feature for a custom topic.
        # 
        # *   **true**\
        # *   **false**\
        self.enable_broadcast = enable_broadcast
        self.enable_proxy_subscribe = enable_proxy_subscribe
        # The instance ID. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
        # 
        # >  If your instance has an ID, you must specify this parameter. Otherwise, the request fails. If no Overview page exists or no instance ID is displayed, you do not need to specify this parameter.
        # 
        # For more information, see the [Overview](~~356505~~) topic of IoT instances.
        self.iot_instance_id = iot_instance_id
        self.operation = operation
        # The **ProductKey** of the product to which the device belongs. The device receives the retained message.
        self.product_key = product_key
        # The custom topic for which you want to enable the retained message broadcasting feature.
        # 
        # *   If you use an MQTT gateway device, set this parameter to the original custom topic of the device. For more information, see [Topics](~~433806~~).
        # *   If you use a non-MQTT gateway device, set this parameter to a custom topic in the following format: `/broadcast/${productKey}/${Custom field}`. `${productKey}` is the value of the **ProductKey** request parameter. You can specify `${Custom field}` based on your business requirements.
        # 
        # >  When you develop devices, use code to define a broadcast topic. You do not need to create a topic in the IoT Platform console. You must grant devices the Subscribe permission or the Publish and Subscribe permission on the topic.
        self.topic_full_name = topic_full_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.description is not None:
            result['Description'] = self.description
        if self.enable_broadcast is not None:
            result['EnableBroadcast'] = self.enable_broadcast
        if self.enable_proxy_subscribe is not None:
            result['EnableProxySubscribe'] = self.enable_proxy_subscribe
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.operation is not None:
            result['Operation'] = self.operation
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.topic_full_name is not None:
            result['TopicFullName'] = self.topic_full_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EnableBroadcast') is not None:
            self.enable_broadcast = m.get('EnableBroadcast')
        if m.get('EnableProxySubscribe') is not None:
            self.enable_proxy_subscribe = m.get('EnableProxySubscribe')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('Operation') is not None:
            self.operation = m.get('Operation')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('TopicFullName') is not None:
            self.topic_full_name = m.get('TopicFullName')
        return self


class UpdateTopicConfigResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        # The error code returned if the request fails. For more information, see [Error codes](~~87387~~).
        self.code = code
        self.message = message
        # The request ID.
        self.request_id = request_id
        # Indicates whether the request was successful. Valid values:
        # 
        # *   **true**\
        # *   **false**\
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateTopicConfigResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateTopicConfigResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTopicConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class WriteDevicesHotStorageDataRequest(TeaModel):
    def __init__(
        self,
        device_name: str = None,
        iot_id: str = None,
        iot_instance_id: str = None,
        items: str = None,
        product_key: str = None,
        user_topic: str = None,
    ):
        self.device_name = device_name
        self.iot_id = iot_id
        self.iot_instance_id = iot_instance_id
        self.items = items
        self.product_key = product_key
        self.user_topic = user_topic

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_name is not None:
            result['DeviceName'] = self.device_name
        if self.iot_id is not None:
            result['IotId'] = self.iot_id
        if self.iot_instance_id is not None:
            result['IotInstanceId'] = self.iot_instance_id
        if self.items is not None:
            result['Items'] = self.items
        if self.product_key is not None:
            result['ProductKey'] = self.product_key
        if self.user_topic is not None:
            result['UserTopic'] = self.user_topic
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('DeviceName') is not None:
            self.device_name = m.get('DeviceName')
        if m.get('IotId') is not None:
            self.iot_id = m.get('IotId')
        if m.get('IotInstanceId') is not None:
            self.iot_instance_id = m.get('IotInstanceId')
        if m.get('Items') is not None:
            self.items = m.get('Items')
        if m.get('ProductKey') is not None:
            self.product_key = m.get('ProductKey')
        if m.get('UserTopic') is not None:
            self.user_topic = m.get('UserTopic')
        return self


class WriteDevicesHotStorageDataResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class WriteDevicesHotStorageDataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: WriteDevicesHotStorageDataResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = WriteDevicesHotStorageDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


