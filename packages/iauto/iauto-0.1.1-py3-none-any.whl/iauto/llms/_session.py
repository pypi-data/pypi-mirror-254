import re
from datetime import datetime
from typing import List, Optional

from .._logging import get_logger
from ..actions import Action
from ._llm import LLM, ChatMessage

_log = get_logger("LLM")


class Session:
    def __init__(self, llm: LLM, actions: Optional[List[Action]] = None) -> None:
        self._llm = llm
        self._actions = actions
        self._messages = []

    def add(self, message: ChatMessage):
        self._messages.append(message)

    @property
    def messages(self) -> List[ChatMessage]:
        return self._messages

    def run(self, history: int = 5, rewrite: bool = False, **kwargs):
        if rewrite:
            self.rewrite(history=history, **kwargs)

        m = self._llm.chat(messages=self._messages[-1 * history:], functions=self._actions, **kwargs)
        self.add(m)
        return m

    def react(self, history: int = 1, rewrite: bool = False, log=False, max_steps=3, **kwargs):
        """Ref : https://www.width.ai/post/react-prompting"""
        if len(self._messages) < 1 and self._messages[-1].role != "user":
            return ChatMessage(role="assistant", content="Ask me a question.")

        original_question = self._messages[-1].content

        if rewrite:
            self.rewrite(history=history, **kwargs)

        primary_prompt = """
Solve a question answering task with interleaving Thought, Action, Observation steps.

Thought can reason about the current situation, and Action can be three types:
(1) Generate[entity], which use tools to generate an obersvation.
If need current date, it's : {datetime}
(2) Finish[answer], which returns the answer and finishes the task.

Example:
```
Task: Who is Olivia Wilde's boyfriend? What is his current age raised to the 0.23 power?

Thought: I need to find out who Olivia Wilde's boyfriend is and then calculate his age raised to the 0.23 power.
Action: Generate["Olivia Wilde boyfriend"]
Observation: Olivia Wilde started dating Harry Styles after ending her years-long engagement to Jason Sudeikis \
â€” see their relationship timeline.
Thought: I need to find out Harry Styles' age.
Action: Generate["Harry Styles age"]
Observation: 29 years
Thought: I need to calculate 29 raised to the 0.23 power.
Action: Generate[29^0.23]
Observation: 2.169459462491557
Thought: I now know the final answer.
Action: Finish["Harry Styles, Olivia Wilde's boyfriend, is 29 years old and his age raised to the 0.23 power is \
2.169459462491557."]
```

Task: {task}

{steps}
        """
        THOUGHT = "Thought: "
        ACTION = "Action: "
        OBSERVATION = "Observation: "

        messages = self._messages[-1 * history:]
        task = self.plain_messages(messages=messages, norole=True, nowrap=True)
        if log:
            _log.info(f"Task: {task}")

        anwser = ChatMessage(role="assistant", content="NOT ENOUGH INFO")

        # Generate steps
        action_pattern = re.compile(r'Generate\[(.+?)\]')
        steps = []
        finished = False
        anwser_found = False

        def _save_step(s):
            steps.append(s)
            if log:
                _log.info(s)

        steps_count = 0
        while not finished and steps_count < max_steps:
            instructions = primary_prompt.format(task=task, steps="\n".join(steps), datetime=datetime.now())
            m = self._llm.chat(messages=[ChatMessage(role="user", content=instructions)], **kwargs)

            content = m.content
            ss = content.split("\n")

            for s in ss:
                s = s.strip()
                if s.startswith(OBSERVATION):
                    break  # drop observation and followed generated by LLM

                if s.startswith(ACTION):
                    _save_step(s)
                    if "Finish" in s:
                        finished = True
                        anwser_pattern = re.compile(r'Finish[(.*)]')
                        founds = anwser_pattern.findall(s)
                        if len(founds) > 0:
                            found = founds[0]
                            found = found.lstrip('"').rstrip('"')
                            anwser.content = found
                            anwser_found = True
                        break
                    else:
                        actions = action_pattern.findall(s)
                        new_obversation = False
                        for action in actions:
                            m = self._llm.chat(messages=[ChatMessage(
                                role="user", content=action)], functions=self._actions)
                            o_content = m.content.replace("\n", " ")
                            observation = f"Observation: {o_content}"
                            _save_step(observation)
                            new_obversation = True
                        if not new_obversation:
                            observation = "Observation: NOTHING. Think again:\n"
                            _save_step(observation)
                elif s.startswith(THOUGHT):
                    _save_step(s)

            steps_count += 1
            if steps_count > max_steps:
                _save_step("Thought: No enough infomation to solve this task, i have to give up.")
                _save_step("Action: Finish[NOT ENOUGH INFO]")

        final_anwser_prompt = """
        Please answer the final user question based on the following thought steps.

        Task: {task}
        Thought Steps:
        ```
        {steps}
        ```

        Final question: {question}
        Your Answer:
        """
        if not anwser_found:
            instructions = final_anwser_prompt.format(task=task, steps="\n".join(steps), question=original_question)
            anwser = self._llm.chat(messages=[ChatMessage(role="user", content=instructions)], **kwargs)
        self.add(anwser)
        return anwser

    def rewrite(self, history: int = 5, **kwargs):
        instructions = """
Rewrite the following user question into a clearer and more complete question based on the context of the conversation.

Conversation:
```
{conversation}
```

Question: {question}
Rewrite as:
        """

        if len(self._messages) < 1 or self._messages[-1].role != "user":
            return

        messages = self._messages[-1 * history:-1]
        plain = self.plain_messages(messages=messages)
        instructions = instructions.format(
            conversation=plain, question=self._messages[-1].content, datetime=datetime.now())

        m = self._llm.chat(messages=[ChatMessage(role="user", content=instructions)], **kwargs)
        self._messages[-1].content = m.content

    def plain_messages(self, messages: List[ChatMessage], norole=False, nowrap=False):

        plain = []
        for m in messages:
            role = "" if norole else f"{m.role}: "
            content = m.content if nowrap else m.content.replace("\n", "\\n")
            plain.append(f"{role}{content}")
        return "\n".join(plain)
