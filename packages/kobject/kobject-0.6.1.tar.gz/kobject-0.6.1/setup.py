# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['kobject']

package_data = \
{'': ['*']}

setup_kwargs = {
    'name': 'kobject',
    'version': '0.6.1',
    'description': 'Know your object is a attribute type checker',
    'long_description': '```\n                       ▄▄          ▄▄                      \n▀████▀ ▀███▀          ▄██          ██                 ██   \n  ██   ▄█▀             ██                             ██   \n  ██ ▄█▀      ▄██▀██▄  ██▄████▄  ▀███  ▄▄█▀██ ▄██▀████████ \n  █████▄     ██▀   ▀██ ██    ▀██   ██ ▄█▀   ███▀  ██  ██   \n  ██  ███    ██     ██ ██     ██   ██ ██▀▀▀▀▀▀█       ██   \n  ██   ▀██▄  ██▄   ▄██ ██▄   ▄██   ██ ██▄    ▄█▄    ▄ ██   \n▄████▄   ███▄ ▀█████▀  █▀█████▀    ██  ▀█████▀█████▀  ▀████\n                                ██ ██                      \n                                ▀███                       By CenturyBoys\n                                \nKnow your object is a __init__ type validator for class and dataclass\n```\n\n## Usage\n\nKobject can be use inside default class declaration and with dataclasses. Kobject uses the ```__init__``` signature to check types.\n\n### Default classes\n\n```python\nfrom kobject import Kobject\n\nclass StubClass(Kobject):\n    a_int: int\n    a_bool: bool\n    \n    def __init__(\n        self,\n        a_int: int,\n        a_bool: bool\n    ):\n        self.a_int = a_int\n        self.a_bool = a_bool\n        self.__post_init__()\n\ninstance = StubClass(a_int=1, a_bool=True)\n```\nNotice that in the default class declaration you need to call ```self.__post_init__()``` at the end of the ```__init__``` declaration.\n\n\n### Dataclass\n\n```python\nfrom dataclasses import dataclass\nfrom kobject import Kobject\n\n@dataclass\nclass StubClass(Kobject):\n    a_int: int\n    a_bool: bool\n\ninstance = StubClass(a_int=1, a_bool=True)\n```\nBy default, dataclass calls ```self.__post_init__()``` at the end of the ```__init__``` declaration [doc](https://docs.python.org/3/library/dataclasses.html#dataclasses.__post_init__). \n\n\n### Exception\n\nKobject raises ```TypeError``` with all validation errors, that means it checks all your object\'s attributes before raising the ```TypeError```. Types like List and Tuple will have all their elements checked.\n\n```python\nfrom dataclasses import dataclass\nfrom kobject import Kobject\nfrom typing import List, Tuple\n\n@dataclass\nclass StubClass(Kobject):\n    a_list_int: List[int]\n    a_tuple_bool: Tuple[bool]\n\ninstance = StubClass(a_list_int=[1, "", 2, ""], a_tuple_bool=["", True])\n```\n```bash\nTraceback (most recent call last):\n...\nTypeError: Class \'StubClass\' type error:\n Wrong type for a_list_int: typing.List[int] != \'<class \'list\'>\'\n Wrong type for a_tuple_bool: typing.Tuple[bool] != \'<class \'list\'>\'\n```\n\nYou can use lazy validation to improve performance, the code will stop in the first found error for this use\n\n```python\nfrom kobject import Kobject\n\nKobject.set_lazy_type_check(status=True)\n```\n\n### Default value\n\nKobject supports default values and will check them before any validation, that means if you declare a ```a_bool: bool = None``` it will not raise an error.\n\n```python\nfrom dataclasses import dataclass\nfrom kobject import Kobject\n\nclass StubClass(Kobject):\n    a_bool: bool = None\n\n    def __init__(self, a_bool: bool = 10):\n        self.a_bool = a_bool\n        self.__post_init__()\n\n@dataclass\nclass StubDataClass(Kobject):\n    a_bool: bool = 10\n```\n\n### Custom exception\n\nBy default, Kobject raise a ```TypeError``` but you can override this exception using `set_validation_custom_exception` for type validation or `set_content_check_custom_exception` for field check on from JSON operation.\n\n```python\nfrom dataclasses import dataclass\nfrom kobject import Kobject\n\n\nclass CustomException(Exception):\n    pass\n\n\nKobject.set_validation_custom_exception(CustomException)\n#Kobject.set_content_check_custom_exception(CustomException)\n\n@dataclass\nclass StubClass(Kobject):\n    a__int: int\n\n\ninstance = StubClass(a__int="")\n```\n```bash\nTraceback (most recent call last):\n...\nCustomException: Class \'StubClass\' type error:\n Wrong type for a__int: <class \'int\'> != \'<class \'str\'>\'\n```\n\n### ToJSON\n\nKobject has his own implementation to parse class instance to a JSON representation. \n\n```python\nfrom dataclasses import dataclass\nfrom typing import List, Tuple\n\nfrom kobject import Kobject\n    \n@dataclass\nclass BaseC(Kobject):\n    a_int: int\n    a_str: str\n    a_list_of_int: List[int]\n    a_tuple_of_bool: Tuple[bool]\n    \ninstance = BaseC(\n    a_int=1,\n    a_str="lala",\n    a_list_of_int=[1, 2, 3],\n    a_tuple_of_bool=(True,)\n)\n\njson_bytes = instance.to_json()\n\nprint(json_bytes)\n```\n```bash\nb\'{"a_int": 1, "a_str": "lala", "a_list_of_int": [1, 2, 3], "a_tuple_of_bool": [true]}\'\n```\n\nFor complex values ToJSON expose ```set_encoder_resolver``` to handler it. \n\nNotest, Before encoding the object to JSON bytes, it will be represented by `self.dict()`. Some objects, such as `datetime.datetime`, can be useful in dictionary structures but are not JSON serializable. In such cases, you can use the `on_dict: bool` parameter in the `Kobject.set_encoder_resolver()` method to encode only when JSON bytes are required, not in its dictionary representation.\n\n```python\nfrom dataclasses import dataclass\nfrom datetime import datetime\nfrom typing import List\nfrom uuid import UUID\n\nfrom kobject import Kobject\n\n\n@dataclass\nclass BaseA(Kobject):\n    a_datetime: datetime\n\n\n@dataclass\nclass BaseB:\n    a_uuid: UUID\n\n\n@dataclass\nclass BaseC(Kobject):\n    a_base_a: BaseA\n    a_base_b: BaseB\n    a_list_of_base_a: List[BaseA]\n\nKobject.set_encoder_resolver(datetime, lambda value: str(value), False)\nKobject.set_encoder_resolver(BaseB, lambda value: {"a_uuid": str(value.a_uuid)})\n\ninstance = BaseC(\n    a_base_a=BaseA(a_datetime=datetime.fromisoformat("2023-02-01 17:38:45.389426")),\n    a_base_b=BaseB(a_uuid=UUID("1d9cf695-c917-49ce-854b-4063f0cda2e7")),\n    a_list_of_base_a=[BaseA(a_datetime=datetime.fromisoformat("2023-02-01 17:38:45.389426"))]\n)\n\ndict_repr = instance.dict()\n\nisinstance(dict_repr["a_base_a"]["a_datetime"], datetime)\n\njson_bytes = instance.to_json()\n\nprint(json_bytes)\n```\n```bash\nb\'{"a_base_a": {"a_datetime": "2023-02-01 17:38:45.389426"}, "a_base_b": {"a_uuid": "1d9cf695-c917-49ce-854b-4063f0cda2e7"}, "a_list_of_base_a": [{"a_datetime": "2023-02-01 17:38:45.389426"}]}\'\n```\n\n### FromJSON\n\nKobject has his own implementation to parse JSON to a class instance.\n\n```python\nfrom dataclasses import dataclass\nfrom typing import List, Tuple\n\nfrom kobject import Kobject\n\n\n@dataclass\nclass BaseC(Kobject):\n    a_int: int\n    a_str: str\n    a_list_of_int: List[int]\n    a_tuple_of_bool: Tuple[bool]\n\npayload = (\n    b\'{"a_int": 1,"a_str": "lala","a_list_of_int": [1,2,3],\'\n    b\'"a_tuple_of_bool": [true]}\'\n)\ninstance = BaseC.from_json(payload=payload)\n\nprint(instance)\n```\n```bash\nBaseC(a_int=1, a_str=\'lala\', a_list_of_int=[1, 2, 3], a_tuple_of_bool=(True,))\n```\n\nFor complex values FromJSON expose ```set_decoder_resolver``` to handler it.\n\n```python\nfrom datetime import datetime\nfrom dataclasses import dataclass\nfrom typing import List\nfrom uuid import UUID\n\nfrom kobject import Kobject\n\n\n@dataclass\nclass BaseA(Kobject):\n    a_datetime: datetime\n\n\n@dataclass\nclass BaseB:\n    a_uuid: UUID\n\n\n@dataclass\nclass BaseC(Kobject):\n    a_base_a: BaseA\n    a_base_b: BaseB\n    a_list_of_base_a: List[BaseA]\n\nKobject.set_decoder_resolver(\n    datetime,\n    lambda attr_type, value: datetime.fromisoformat(value)\n    if isinstance(value, str)\n    else value,\n)\nKobject.set_decoder_resolver(\n    BaseB,\n    lambda attr_type, value: attr_type(a_uuid=UUID(value["a_uuid"]))\n    if isinstance(value, dict)\n    else value,\n)\npayload = (\n    b\'{"a_base_a": {"a_datetime": "2023-02-01 17:38:45.389426"},"a_base_b": {"a_\'\n    b\'uuid":"1d9cf695-c917-49ce-854b-4063f0cda2e7"}, "a_lis\'\n    b\'t_of_base_a": [{"a_datetime": "2023-02-01 17:38:45.389426"}]}\'\n)\ninstance = BaseC.from_json(payload=payload)\n\nprint(instance)\n```\n```bash\nBaseC(a_base_a=BaseA(a_datetime=datetime.datetime(2023, 2, 1, 17, 38, 45, 389426)), a_base_b=BaseB(a_uuid=UUID(\'1d9cf695-c917-49ce-854b-4063f0cda2e7\')), a_list_of_base_a=[BaseA(a_datetime=datetime.datetime(2023, 2, 1, 17, 38, 45, 389426))])\n```',
    'author': 'Marco Sievers de Almeida Ximit Gaia',
    'author_email': 'im.ximit@gmail.com',
    'maintainer': 'None',
    'maintainer_email': 'None',
    'url': 'None',
    'packages': packages,
    'package_data': package_data,
    'python_requires': '>=3.10,<4.0',
}


setup(**setup_kwargs)
