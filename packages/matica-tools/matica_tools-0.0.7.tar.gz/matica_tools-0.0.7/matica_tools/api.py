# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/api.ipynb.

# %% auto 0
__all__ = ['MaticaAPIClient']

# %% ../nbs/api.ipynb 5
import shutil
import paramiko
import scp as scp2
import base64
import requests
import time
import os
from requests.auth import HTTPBasicAuth
from urllib.parse import quote

# %% ../nbs/api.ipynb 6
class MaticaAPIClient(object):
    """
    A client for interacting with Matica's API for file uploading, transferring, and ingesting processes.
    """

    time_span = 2  # Time to wait in loops, in seconds

    def __init__(self, dashboard_url: str, dashboard_username: str, dashboard_api_key: str, storage_service_url: str,
                 
                 storage_service_username: str, storage_service_password: str):
        """
        Initializes the MaticaAPIClient with necessary details for API and SSH interactions.
        """

        self.dashbord_url = dashboard_url
        self.dashboard_username = dashboard_username
        self.dashboard_api_key = dashboard_api_key

        # , ssh_username: str, ssh_password: str
        
        # self.location_uuid = location_uuid

        # self.unzip = unzip

        # self.ssh_username = ssh_username
        # self.ssh_password = ssh_password

        # self.task_id = task_id

        # self.file_dir_path = file_dir_path  # f'/home/files'

        # self.task_dir_path = f'{self.file_dir_path}/{self.task_id}/'

        self.dash_board_headers = {
            'Authorization': f'ApiKey {dashboard_username}:{dashboard_api_key}',
            "Content-Type": "application/json"
        }

        # self.endpoint = f"http://{hostname}:81/api"

        self.dash_board_endpoint = f"{dashboard_url}/api"

        self.storage_service_url = storage_service_url
        self.storage_username = storage_service_username
        self.storage_password = storage_service_password

        # self.storage_username = storage_username
        # self.storage_password = storage_password

        # self.uploaded_file_path = uploaded_file_path
        # self.transfer_type = transfer_type



    def init_old(self, hostname: str, username: str, api_key: str, location_uuid: str, ssh_username: str, ssh_password: str,
                 task_id: str, uploaded_file_path: str, transfer_type: str, transfer_accession: str,
                 storage_username: str, storage_password: str, file_dir_path: str = '/home/files', unzip: bool = False):
        """
        Initializes the MaticaAPIClient with necessary details for API and SSH interactions.
        """
        self.hostname = hostname
        self.username = username
        self.api_key = api_key
        self.location_uuid = location_uuid

        self.unzip = unzip

        self.ssh_username = ssh_username
        self.ssh_password = ssh_password

        self.task_id = task_id

        self.file_dir_path = file_dir_path  # f'/home/files'

        self.task_dir_path = f'{self.file_dir_path}/{self.task_id}/'

        self.headers = {'Authorization': f'ApiKey {username}:{api_key}'}

        self.endpoint = f"http://{hostname}:81/api"

        self.storage_username = storage_username
        self.storage_password = storage_password

        self.uploaded_file_path = uploaded_file_path
        self.transfer_type = transfer_type
        self.transfer_accession = transfer_accession

    @staticmethod
    def main(hostname: str, username: str, api_key: str, location_uuid: str, ssh_username: str, ssh_password: str,
             task_id: str, uploaded_file_path: str, transfer_type: str, transfer_accession: str,
             storage_username: str, storage_password: str, file_dir_path: str = '/home/files') -> str:
        """
        Main method to execute the workflow of uploading, transferring, approving transfer, checking transfer status,
        ingesting, and retrieving the AIP URL.

        Returns:
            A string URL to the ingested AIP.
        """
        client = MaticaAPIClient(hostname, username, api_key, location_uuid, ssh_username, ssh_password, task_id,
                                 storage_username, storage_password, uploaded_file_path=uploaded_file_path,
                                 transfer_type=transfer_type, transfer_accession=transfer_accession,
                                 file_dir_path=file_dir_path)
        client.upload(uploaded_file_path)
        directory = client.transfer(transfer_type, transfer_accession)
        transfer_UUID = client.approve_transfer(transfer_type, directory)
        sip_UUID = client.check_transfer_status(transfer_UUID)
        ingest_UUID = client.ingest(sip_UUID)
        url = client.get_aip_url(ingest_UUID)
        return url

    # stage = 0

    

    

    def upload(self, uploaded_file_path: str, unzip: bool = False):
        """
        Uploads a file to the designated task directory via SSH and optionally unzips it.

        Args:
            uploaded_file_path: Path to the file to be uploaded.
            unzip: Flag to indicate if the uploaded file should be unzipped.
        """
        task_dir_path = self.task_dir_path
        with paramiko.SSHClient() as ssh:
            ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            ssh.connect(self.hostname, port=22, username=self.ssh_username, password=self.ssh_password)
            ssh.exec_command(f"rm -rf {task_dir_path} && mkdir -p {task_dir_path}")
            try:
                with scp2.SCPClient(ssh.get_transport()) as scp:
                    scp.put(uploaded_file_path, task_dir_path)
            except Exception as e:
                print(e)  # Consider logging this instead
            if unzip:
                filename = os.path.basename(uploaded_file_path)
                ssh.exec_command(f"cd {task_dir_path} && unzip {filename} && rm -rf {filename}")

    
    def transfer(self, transfer_type: str, transfer_accession: str, location_uuid, path, task_id) -> str:
        """
        Initiates a file transfer process.

        Args:
            transfer_type: The type of the transfer.
            transfer_accession: The accession number for the transfer.

        Returns:
            The directory associated with the transfer.
        """
        # task_dir_path = self.task_dir_path
        # path_encoded = base64.b64encode(f"{self.location_uuid}:{task_dir_path}".encode()).decode()
        path_encoded = base64.b64encode(f"{location_uuid}:{path}".encode()).decode()
        data = {
            "name": task_id, # self.task_id,
            "type": transfer_type,
            "accession": transfer_accession,
            "paths[]": [path_encoded],
            "processing_config": "automated",
            "row_ids[]": [""]
        }
        response = requests.post(f'{self.dashbord_url}/api/transfer/start_transfer/', headers=self.dash_board_headers, data=data)
        directory = response.json()["path"].split("/")[-2]
        self.directory = directory
        return directory
    
    def v2beta_package(self, transfer_type: str, transfer_accession: str, location_uuid, path, name, processing_config) -> str:
        """
        Initiates a file transfer process.

        Args:
            transfer_type: The type of the transfer.
            transfer_accession: The accession number for the transfer.

        Returns:
            The directory associated with the transfer.
        """

        path = f"{location_uuid}:{path}"

        path_encoded = base64.b64encode(path.encode()).decode()
        # path_encoded = base64.b64encode(f"{task_dir_path}".encode()).decode()
        # {location_uuid}:
        data = {
            "name": name, # self.task_id,
            "type": transfer_type,
            # "accession": transfer_accession,
            "processing_config": "automated",
            # "paths[]": [path_encoded],
            "path": path_encoded,
            # "row_ids[]": [""]
        }

        response = requests.post(f'{self.dashbord_url}/api/v2beta/package/', headers=self.dash_board_headers, json=data)
        # directory = response.json()["path"].split("/")[-2]
        # self.directory = directory
        # return directory

        self.transfer_UUID = response.json()["id"]
        return self.transfer_UUID
    

    def transfer222(self, transfer_type: str, transfer_accession: str) -> str:
        """
        Initiates a file transfer process.

        Args:
            transfer_type: The type of the transfer.
            transfer_accession: The accession number for the transfer.

        Returns:
            The directory associated with the transfer.
        """
        task_dir_path = self.task_dir_path
        path_encoded = base64.b64encode(f"{self.location_uuid}:{task_dir_path}".encode()).decode()
        data = {
            "name": self.task_id,
            "type": transfer_type,
            "accession": transfer_accession,
            "paths[]": [path_encoded],
            "row_ids[]": [""]
        }
        response = requests.post(f'{self.endpoint}/transfer/start_transfer/', headers=self.headers, data=data)
        directory = response.json()["path"].split("/")[-2]
        self.directory = directory
        return directory
    
    def approve_transfer(self, transfer_type: str, directory: str) -> str:
        """
        Approves a file transfer after initiation.

        Args:
            transfer_type: The type of the transfer.
            directory: The directory associated with the transfer.

        Returns:
            The UUID of the approved transfer.
        """
        while True:
            data = {"type": transfer_type, "directory": directory}
            response = requests.post(f'{self.dashbord_url}/api/transfer/approve/', headers=self.dash_board_headers, data=data)
            if "uuid" in response.json():
                self.transfer_UUID = response.json()["uuid"]
                break
            time.sleep(self.time_span)
        return self.transfer_UUID

    def approve_transfer222(self, transfer_type: str, directory: str) -> str:
        """
        Approves a file transfer after initiation.

        Args:
            transfer_type: The type of the transfer.
            directory: The directory associated with the transfer.

        Returns:
            The UUID of the approved transfer.
        """
        while True:
            data = {"type": transfer_type, "directory": directory}
            response = requests.post(f'{self.endpoint}/transfer/approve/', headers=self.headers, data=data)
            if "uuid" in response.json():
                self.transfer_UUID = response.json()["uuid"]
                break
            time.sleep(self.time_span)
        return self.transfer_UUID

    def check_transfer_status(self, transfer_UUID: str) -> str:
        """
        Checks the status of a file transfer until it is no longer processing.

        Args:
            transfer_UUID: The UUID of the transfer to check.

        Returns:
            The SIP UUID of the transfer.
        """
        while True:
            response = requests.get(f'{self.dashbord_url}/api/transfer/status/{transfer_UUID}', headers=self.dash_board_headers)
            r = response.json()
            if "status" in r and r["status"] != "PROCESSING":
                self.sip_uuid = r["sip_uuid"]
                break
            time.sleep(self.time_span)
        return self.sip_uuid

    def ingest(self, sip_UUID: str) -> str:
        """
        Waits for the ingestion process to complete and returns the UUID of the ingested AIP.

        Args:
            sip_UUID: The SIP UUID to ingest.

        Returns:
            The UUID of the ingested AIP.
        """
        while True:
            response = requests.get(f'{self.dash_board_endpoint}/ingest/status/{sip_UUID}', headers=self.dash_board_headers)
            r = response.json()
            if "status" in r and r["status"] != "PROCESSING":
                return r["uuid"]
            time.sleep(self.time_span)

    def get_aip_url(self, ingest_UUID: str) -> str:
        """
        Constructs and returns the URL for downloading the ingested AIP.

        Args:
            ingest_UUID: The UUID of the ingested AIP.

        Returns:
            The URL for downloading the AIP.
        """
        # endpoint = f"http://{self.hostname}:8001/api"
        # storage_service_url = self.storage_service_url
        endpoint = self.storage_service_url + "/api"
        url = f"{endpoint}/v2/file/{ingest_UUID}/download/"
        return url
    
    def get_current_full_path(self, ingest_UUID: str) -> str:

        endpoint = self.storage_service_url + "/api"
        url = f"{endpoint}/v2/file/{ingest_UUID}/"
        # return url

        username = self.storage_username
        password = self.storage_password

        response = requests.get(url, auth=HTTPBasicAuth(username, password))

        return response.json()["current_full_path"]
    
    def filesystem_metadata(self) -> str:
        """
        Returns the metadata of the file system.
        """
        response = requests.get(f'{self.dashbord_url}/api/filesystem/metadata/', headers=self.dash_board_headers)
        return response.json()
    
    def status(self, params):
        # if self.stage == 0:
        if not any(params):

            self.upload(self.uploaded_file_path, unzip=self.unzip)
            self.transfer(self.transfer_type, self.transfer_accession)

            self.stage = 1

            return {
                "data": {
                    "type": self.transfer_type,
                    "directory": self.directory
                },
                "status": "transfer started"
            }
        # elif self.stage == 1:
        elif "directory" in params:

            data = {
                "type": params["type"],  # self.transfer_type,
                "directory": params["directory"]  # self.directory
            }

            response3 = requests.post(
                f'{self.endpoint}/transfer/approve/', headers=self.headers, data=data)

            if "uuid" in response3.json():
                self.stage = 2

                self.transfer_UUID = response3.json()["uuid"]

                return {
                    "data": {
                        "transfer_UUID": self.transfer_UUID
                    },
                    "status": "transfer approved"
                }

            return {
                "status": "transfer approving"
            }
        # elif self.stage == 2:
        elif "transfer_UUID" in params:

            transfer_UUID = params["transfer_UUID"]  # self.transfer_UUID

            response5 = requests.get(
                f'{self.endpoint}/transfer/status/{transfer_UUID}', headers=self.headers)

            r = response5.json()

            if "status" in r and r["status"] != "PROCESSING":
                # break
                # self.stage = 3

                r = response5.json()

                if "sip_uuid" in r:

                    self.sip_UUID = r["sip_uuid"]

                    # time.sleep(self.time_span)

                    # return response5.json()["sip_uuid"]

                    return {
                        "data": {
                            "sip_UUID": self.sip_UUID
                        },
                        "status": "transfer done"
                    }

            return {
                "status": "transfer processing"
            }
        # elif self.stage == 3:
        elif "sip_UUID" in params:

            sip_UUID = params["sip_UUID"]  # self.sip_UUID

            response4 = requests.get(
                f'{self.endpoint}/ingest/status/{sip_UUID}', headers=self.headers)

            r = response4.json()

            if "status" in r and r["status"] != "PROCESSING":
                # break
                # self.stage = 4
                return {
                    "data": {
                        "ingest_UUID": response4.json()["uuid"],
                        # "download": 1
                    },
                    "status": "ingest done",
                }

            return {
                "status": "ingest processing"
            }

        #
        elif "ingest_UUID" in params:

            ingest_UUID = params["ingest_UUID"]  # self.ingest_UUID

            return {
                "status": "completed",
                "data": self.get_aip_url(ingest_UUID)
            }

    def __init2__(self, hostname, username, api_key, location_uuid, ssh_username, ssh_password, task_id, storage_username, storage_password, file_dir_path='/home/files'):
        self.hostname = hostname
        self.username = username
        self.api_key = api_key
        self.location_uuid = location_uuid

        self.ssh_username = ssh_username
        self.ssh_password = ssh_password

        self.task_id = task_id

        self.file_dir_path = file_dir_path  # f'/home/files'

        self.task_dir_path = f'{self.file_dir_path}/{self.task_id}/'

        self.headers = {'Authorization': f'ApiKey {username}:{api_key}'}

        self.endpoint = f"http://{hostname}:81/api"

        self.storage_username = storage_username
        self.storage_password = storage_password

        pass

