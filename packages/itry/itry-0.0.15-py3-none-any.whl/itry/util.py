# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_util.ipynb.

# %% auto 0
__all__ = ['Spec', 'trysig', 'getsig', 'setsig', 'newtype']

# %% ../nbs/02_util.ipynb 5
from importlib import import_module
from inspect import Signature, signature
from functools import wraps

# %% ../nbs/02_util.ipynb 7
from types import BuiltinFunctionType, FunctionType, MethodType, MethodWrapperType
from typing import (Union, Tuple, Callable, Optional, NamedTuple)

# %% ../nbs/02_util.ipynb 9
from .cons import CLS, NIL, __ANNOTATIONS__, __CALL__, __DOC__, __INIT__, __NEW__,  __NAME__, __SIGNATURE__
from .atyp import T, Types, Namespace, ImportedAsset

# %% ../nbs/02_util.ipynb 12
class Spec(NamedTuple):
    '''Specification information to import an asset.

    Parameters
    ----------
    name : str, optional
        The name of the module to import from, defaults to None.
        
    attr : str, optional
        The name of the attribute to import from the module, defaults to None.
        
    bases : Union[Types, type]
        Base classes for creating a new type if import fails and default is None.
        
    namespace : dict
        A namespace dictionary for creating a new type.
        
    default : type, optional
        A default value to return if import fails.
    '''
    name: Optional[str] = None
    attr: Optional[str] = None
    bases: Union[Types, type] = tuple()
    namespace: Namespace = dict()
    default: Optional[T] = None
    
    def asdict(self) -> dict:
        return self._asdict()
    
    def getvals(self, obj: object, __type: bool = False, **kwargs) -> dict:
        dct, res = self.asdict(), dict()
        itm = type(obj) if __type else obj
        for k, v in dct.items():
            val = kwargs.get(k, getattr(itm, k, v)) or v
            if val is not None and val:
                res[k] = val
            
        return res
    
    def setvals(self, obj: object, __type: bool = False, **kwargs):
        item = type(obj) if __type else obj
        kwargs.update(dict(__type = __type))
        vals = self.getvals(obj, **kwargs)
        for k, v in vals.items():
            setattr(item, k, v)
        return item

# %% ../nbs/02_util.ipynb 14
def makegetter(attr: str, retself: bool = False) -> Callable:
    @wraps(getattr)
    def get(obj: object, default = None) -> object:
        return getattr(obj, attr, obj if retself else default)
    return get

dunann, duncal, dundoc, dunini, dunnew, dunsig = map(makegetter, (
    __ANNOTATIONS__, __CALL__, __DOC__, __INIT__, __NEW__, __SIGNATURE__))

dunname = makegetter(__NAME__, True)

# %% ../nbs/02_util.ipynb 16
def trysig(o: object) -> Optional[Signature]:
    '''Attempt to retrieve the signature of an object.'''
    try: return signature(o)
    except: ...

def getsig(o: object) -> Signature:
    '''Retrieve the signature of an object, attempting multiple strategies if necessary.'''
    # NOTE: desparate try to get a signature from anywhere
    duns = (dunsig, duncal, dunini, dunnew, dunann)
    vals = {dunname(fn): fn(o) for fn in (lambda x: x, *duns)}
    for _, val in vals.items():
        if (sig := trysig(val)): return sig
        
    # NOTE: if all else fails, try to get a signature from the annotations
    for _, val in vals.items():
        if (sig := dunsig(val)): return sig
    return Signature([])

def setsig(wrapper: MethodWrapperType, attr: Callable) -> MethodWrapperType:
    '''Set the signature of a method wrapper based on an attribute's signature.'''
    sig = getsig(attr)
    setattr(wrapper, __SIGNATURE__, sig)
    
    if hasattr(wrapper, __CALL__) and hasattr(duncal(wrapper), __SIGNATURE__): wrapper.__call__.__signature__ = sig
    if hasattr(wrapper, __INIT__) and hasattr(dunini(wrapper), __SIGNATURE__): wrapper.__init__.__signature__ = sig
    
    setattr(wrapper, __ANNOTATIONS__, dunann(attr, dunann(wrapper)))
    setattr(wrapper, __DOC__, dundoc(attr, dundoc(wrapper)))
    return wrapper

# %% ../nbs/02_util.ipynb 18
def newtype(
    name: str = NIL,
    bases: Union[Types, type] = tuple(), 
    space: Namespace = dict(),
    *, 
    cls: Optional[type] = None, 
    **kwargs
) -> type:
    '''
    Create a new type using type.__new__.

    Parameters
    ----------
    name : str
        The name of the type.

    bases : Union[Types, type]
        A tuple containing base classes of the new type, or a single base class.
        
    space : Union[dict, namespace]
        A dictionary containing attributes and methods of the new type.

    cls : Optional[type]
        A metaclass for the new type, defaults to None.

    **kwargs
        Additional keyword arguments to be included in the type's dictionary.

    Returns
    -------
    type
        The newly created type.

    Notes
    -----
    Calls `newtype` is equvialent to either

    type(name, bases, dict) : 
        if no class `cls` is provided, or

    type.__new__(cls, name, bases, dict) : 
        if a class `cls` is provided.
    '''
    space.update(kwargs)
    if not isinstance(bases, tuple):
        bases = tuple((bases, ))
        
    if cls is None:
        return type(name, tuple(bases), space)
    
    return type.__new__(cls, name, tuple(bases), space)
