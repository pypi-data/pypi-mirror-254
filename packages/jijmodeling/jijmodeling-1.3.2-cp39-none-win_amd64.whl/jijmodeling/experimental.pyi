# This file is automatically generated by gen_stub.rs

from typing import final, Any, List, Dict
from enum import Enum, auto

@final
class EvaluationResult:
    objective: float
    constraints: Dict[str, Any]
    penalties: Dict[str, Any]

@final
class MeasuringTime:
    def __new__(cls,solving_time, system_time): ...
    def __str__(self) -> str:
        ...

    def __repr__(self) -> str:
        ...

    def total(self) -> float:
        ...

    def view_solving_time(self) -> Any:
        r"""
        Returns a readonly view of the internal `SolvingTime` field.
        """
        ...

    def view_system_time(self) -> Any:
        r"""
        Returns a readonly view of the internal `SystemTime` field.
        """
        ...


@final
class Sample:
    r"""
    A Sample representing an individual solution found by running the mathematical optimization model.
    
    Variables in `vars` are stored sparsely in a dictionary style, retaining
    only non-zero elements. For example, if the values are for a two-dimensional
    decision variable are `x = [[0, 1, 2], [1, 0, 0]]`, they will be stored in
    `vars` as `{(0,1): 1, (0,2): 2, (1,0): 1}`. If you want a dense array of decision variables,
    use the `to_dense()` method.
    
    `run_id` is a unique identifier of the run in which this sample was found.
    Note that this is not the same as a unique identifier of the Sample.
    """
    run_id: str
    num_occurrences: int
    run_info: Dict[str, Any]
    var_values: Dict[str, Any]
    eval: Any
    def __new__(cls,num_occurrences = ...,run_id = ...,run_info = ...): ...
    @staticmethod
    def from_dense_arrays(dict,num_occurrences = ...,var_types = ...,run_id = ...,meta_info = ...) -> Any:
        ...

    def __str__(self) -> str:
        ...

    def __repr__(self) -> str:
        ...

    def is_feasible(self, epsilon = ...) -> bool:
        ...

    def to_dense(self) -> Dict[str, Any]:
        ...


@final
class SampleIter:
    def __iter__(self) -> Any:
        ...

    def __next__(self) -> Any:
        ...


@final
class SampleSet:
    data: List[Any]
    set_id: str
    set_info: Dict[str, Any]
    run_info: Dict[str, Any]
    measuring_time: Any
    run_times: Dict[str, Any]
    def __new__(cls,data = ...,*,set_id = ...,set_info = ...,run_info = ...,measuring_time = ...,run_times = ...): ...
    def __str__(self) -> str:
        ...

    def __repr__(self) -> str:
        ...

    def __len__(self) -> int:
        ...

    def __getitem__(self, idx) -> Any:
        ...

    def __iter__(self) -> Any:
        ...

    @staticmethod
    def from_array(samples) -> Any:
        r"""
        Builds a SampleSet from a list of dictionaries, where each entry is interpreted as a sample.
        
        Args
        -----
        - `samples`(`list[dict[str, list | numpy.ndarray]]`)
        """
        ...

    @staticmethod
    def concat(family) -> Any:
        ...

    def feasibles(self, epsilon = ...) -> Any:
        r"""
        Returns a SampleSet containing only the feasible samples.
        
        Args
        -----
        - `epsilon` (`float`, optional): Tolerance threshold for constraint violations. Defaults to $1e-8$.
        
        Returns
        --------
        - `SampleSet`: a feasible subset of the current set.
        """
        ...

    def separate(self) -> Dict[str, Any]:
        ...


@final
class SolvingTime:
    compiling_time: float
    transpiling_time: float
    preprocess_time: float
    solving_time: float
    decoding_time: float
    postprocess_time: float
    def __new__(cls,compiling_time = ...,transpiling_time = ...,preprocess_time = ...,solving_time = ...,decoding_time = ...,postprocess_time = ...): ...
    def __str__(self) -> str:
        ...

    def __repr__(self) -> str:
        ...

    def total(self) -> float:
        ...


@final
class SparseVarValues:
    name: str
    var_type: Any

@final
class SystemTime:
    posting_time: Any
    request_queuing_time: Any
    fetching_problem_time: Any
    fetching_result_time: Any
    deserialize_time: Any
    def __new__(cls,posting_time = ...,request_queuing_time = ...,fetching_problem_time = ...,fetching_result_time = ...,deserialize_time = ...): ...
    def __str__(self) -> str:
        ...

    def __repr__(self) -> str:
        ...


@final
class Violation:
    name: str
    total_violation: float

@final
class VarType(Enum):
    CONTINUOUS = auto()
    INTEGER = auto()
    BINARY = auto()

def from_old_sampleset(sampleset) -> Any:
    ...

